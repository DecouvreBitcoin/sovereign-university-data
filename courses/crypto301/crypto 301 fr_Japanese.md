名前：暗号学入門
目標：暗号学的な観点からビットコインウォレットの作成を理解する
目的：

- ビットコインに関連する暗号学の用語を解明する
- ビットコインウォレットの作成をマスターする
- ビットコインウォレットの構造を理解する
- アドレスと派生パスを理解する

# 暗号学の中心への旅

ビットコインに魅了されていますか？ビットコインウォレットの動作原理について知りたいですか？暗号学の中心への魅惑的な旅に備えてください！私たちの専門家であるロワイックが、ハッシュ、キーの派生、楕円曲線などの技術的な用語の背後にある謎を明らかにしながら、ビットコインウォレットの作成の奥深さを案内します。

このトレーニングでは、ビットコインウォレットの構造を理解するための知識だけでなく、暗号学の魅力的な世界により深く没頭する準備もできます。さあ、この旅に出る準備はできましたか？私たちに参加して、あなたの好奇心をスキルに変えましょう！

+++

# 紹介

## 暗号学入門

### このトレーニングはあなたに適していますか？はい！

![Rogzyによる紹介](https://youtu.be/ul8zU5QWIXg)

私たちは、暗号学と HD ウォレットの紹介をテーマにした新しいトレーニング「Crypto 301：暗号学と HD ウォレットの入門」を、専門家のロワイック・モレルが主催することを大変喜んでお知らせします。このコースでは、データの暗号化とセキュリティを保証する数学の基礎である暗号学の魅力的な世界に没頭します。

私たちの日常生活や特にビットコインの世界では、暗号学は重要な役割を果たしています。プライベートキー、パブリックキー、アドレス、派生パス、シード、エントロピーなど、これらに関連する概念は、ビットコインウォレットの使用と作成の中心にあります。このコースでは、ロワイックが詳細に説明し、プライベートキーの生成方法とアドレスとの関連性を説明します。また、ロワイックは楕円曲線の数学的な詳細を 1 時間かけて説明します。さらに、ウォレットのセキュリティに HMAC SHA512 を使用する重要性や、シードとニーモニックフレーズの違いについても理解するでしょう。
このトレーニングの最終目標は、HD ウォレットの作成プロセスと使用される暗号化手法を技術的に理解できるようにすることです。年月が経つにつれて、Bitcoin ウォレットは、特定の BIP によってより使いやすく、より安全で標準化されるように進化してきました。Loïc は、これらの BIP を理解するために、Bitcoin の開発者と暗号学者の選択肢を把握するのを助けます。私たちの大学が提供するすべてのトレーニングと同様に、このトレーニングも完全に無料でオープンソースです。つまり、自由に再利用して自由に使用することができます。このエキサイティングなコースの終わりには、皆さんからのフィードバックをお待ちしています。

### 教授による挨拶！

![intro par loïc](https://youtu.be/mwuxXLk4Kws)

こんにちは、皆さん、私は Loïc Morel です。Bitcoin ウォレットで使用される暗号化技術の技術的な探求を通じて、皆さんをガイドします。

私たちの旅は、暗号化ハッシュ関数の深淵に飛び込むことから始まります。私たちは、不可欠な SHA256 の内部構造を解明し、派生に特化したさまざまなアルゴリズムを探求します。

次に、デジタル署名の神秘的な世界を解読することで冒険を続けます。楕円曲線の魔法がこれらの署名にどのように適用されるかを発見し、秘密鍵から公開鍵を計算する方法について明らかにします。そしてもちろん、デジタル署名のプロセスについても取り上げます。

その後、Bitcoin ウォレットの進化を振り返り、エントロピーと乱数の概念に踏み込みます。有名なニーモニックフレーズを復習しながら、パスフレーズについても触れます。さらに、128 回のサイコロの投げでシードを生成するというユニークな体験もできます！

これらの堅固な基礎を持っていれば、Bitcoin ウォレットの作成に向けて準備が整います。シードとマスターキーの生成から、拡張キーの研究、子キーペアの派生まで、各ステップを詳しく解説します。また、ウォレットの構造と派生パスについても議論します。

最後に、Bitcoin アドレスを調査することで、私たちの旅を締めくくります。アドレスの生成方法と Bitcoin ウォレットの動作における重要な役割について説明します。

私と一緒にこの魅力的な旅に出発し、かつてないほどの方法で暗号化の世界を探求しましょう。あらかじめ持っている概念を捨て、Bitcoin とその基本構造を理解する新しい方法に心を開いてください。

# ハッシュ関数

## Bitcoin に関連する暗号化ハッシュ関数の紹介

![2.1 - cryptographic hash functions](https://youtu.be/dvnGArYvVr8)
今日のセッションでは、ビットコインプロトコルのセキュリティにおいて重要な要素である、ハッシュ関数の暗号学的な世界について詳しく説明します。ハッシュ関数は、情報を一意かつ固定サイズのデジタルフィンガープリント（ハッシュ、フィンガープリント、またはコンデンセートとも呼ばれる）に変換する、非常に効率的な暗号解読ロボットのようなものです。

要約すると、ハッシュ関数は任意のサイズのメッセージを入力として受け取り、固定サイズのフィンガープリントに変換します。

ハッシュ関数の特性を説明するには、2 つの重要な品質、つまり不可逆性と偽造への耐性を理解する必要があります。

不可逆性またはプレイイメージへの耐性は、入力から出力を計算することは簡単ですが、出力から入力を復元することは不可能であるということです。これは一方向関数です。

![image](assets/image/section1/0.JPG)

偽造への耐性は、入力の最小の変更でも大きく異なる出力が得られるという事実によって生じます。これらの関数は、ダウンロードしたソフトウェアの整合性を検証するのに使用されます。

![image](assets/image/section1/1.JPG)

これらの関数が持つもう一つの重要な特徴は、衝突耐性と第二のプレイイメージへの耐性です。衝突とは、異なる入力が同じ出力を生成することです。ハッシュの世界では衝突は避けられないかもしれませんが、優れた暗号ハッシュ関数は衝突を極力少なくします。リスクはゼロと見なせるほど低くなければなりません。まるで各ハッシュが巨大な都市の家のようでありながら、優れたハッシュ関数は各家に固有の住所を持つようにします。
第二のプレイイメージへの耐性は、衝突への耐性に依存します。衝突への耐性があれば、第二のプレイイメージへの耐性もあります。
与えられた入力情報に対して、出力のハッシュで衝突する異なる第二の入力を見つける必要があります。第二のプレイイメージへの耐性は、衝突への耐性と似ていますが、入力が与えられるという点が異なります。
今度は、陳腐化したハッシュ関数の波乱に満ちた流れに乗りましょう。SHA0、SHA1、および MD5 は、暗号ハッシュの海で錆びた貝殻と見なされています。これらは、衝突耐性を失ったため、しばしば推奨されません。引き出しの原理は、出力サイズの制限により、衝突回避が不可能であることを説明しています。ハッシュ関数が真に安全と見なされるためには、衝突、第二原像、および原像に耐える必要があります。

ビットコインプロトコルの重要な要素である SHA-256 ハッシュ関数は、船の船長です。SHA-512 などの他の関数は、HMAC と PBKDF の派生に使用されます。さらに、RIPMD160 は、フィンガープリントを 160 ビットに縮小するために使用されます。HASH256 と HASH160 について話すとき、私たちは SHA-256 と RIPMD を使用したダブルハッシュの使用を指しています。

HASH256 は、メッセージを SHA256 関数で 2 回ハッシュすることです。

$$
SHA256(SHA256(message))
$$

HASH160 は、メッセージを最初に SHA256 関数でハッシュし、次に RIPMD160 を使用して 2 回ハッシュすることです。

$$
RIPMD160(SHA256(message))
$$

HASH160 の使用は特に有利であり、SHA-256 のセキュリティを享受しながらフィンガープリントのサイズを縮小することができます。

要約すると、暗号ハッシュ関数の究極の目標は、任意のサイズの情報を固定サイズのフィンガープリントに変換することです。安全と認識されるためには、逆変換不可能性、改竄耐性、衝突耐性、および第二原像耐性を持つ必要があります。

![image](assets/image/section1/2.JPG)

この探索の結果、暗号ハッシュ関数の謎を解き明かし、ビットコインプロトコルでの使用方法を明らかにし、それらの特定の目標を詳細に説明しました。ハッシュ関数が安全と見なされるためには、原像、第二原像、衝突、および改竄に耐性がある必要があります。また、ビットコインプロトコルで使用されるさまざまなハッシュ関数の範囲を見てきました。次のセッションでは、SHA256 ハッシュ関数の核心に飛び込み、そのユニークな特性を与える魅力的な数学を探求します。

## SHA256 の仕組み

![SHA256の仕組み](https://youtu.be/74SWg_ZbUj4)

ハッシュ関数の暗号的な迷宮を魅力的に旅する私たちの冒険の続きへようこそ。今日は、以前に紹介した複雑で巧妙なプロセスである SHA256 の謎を解き明かします。
再度説明しますが、SHA256 ハッシュ関数の目的は、任意のサイズのメッセージを入力として受け取り、256 ビットのハッシュを出力することです。

### 前処理

SHA256 の前処理から始めましょう。

#### パディングビット

この最初のステップの目的は、メッセージを 512 ビットの倍数に均等化することです。そのために、メッセージにパディングビットを追加します。

M を初期メッセージのサイズとします。
1 はセパレータ用のビットです。
P はパディングに使用されるビット数であり、64 は前処理の 2 番目のフェーズに割り当てられるビット数です。
合計は 512 ビットの倍数でなければなりません。

![image](assets/image/section1/3.JPG)

入力メッセージが 950 ビットの場合の例：

```
ステップ1：サイズを決定する。理想的な最終ビット数。
(M + 64 + 1) (M = 950)の最初の512の倍数は1024です。
1024 = 2 * 512
したがって、n = 2。

ステップ2：Pを決定する。最終ビット数に到達するために必要なパディングビットの数。
-> M + 1 + P + 64 = n * 512
-> M + 1 + P + 64 = 2 * 512
-> 940 + 1 + P + 64 = 1024
-> P = 1024 - 1 - 64 - 950
-> P = 9

したがって、512の倍数に均等化するために9ビットのパディングを追加する必要があります。
```

そして、初期メッセージの直後に、セパレータ 1 と P（この例では 9 個の 0）を追加します。

```
message + 1 000 000 000
```

#### サイズのパディング

次に、前処理の 2 番目のフェーズに移ります。これは、初期メッセージのサイズをビットで表したバイナリ表現を追加することを意味します。

950 ビットの入力の例を再度見てみましょう：

```
数字950のバイナリ表現は：11 1011 0110

前のステップで予約した64ビットを使用します。64ビットを均等化するためにゼロを追加し、初期メッセージ、パディングビット、サイズのパディングを結合して均等化された入力を得ます。
```

結果は以下の通りです：

![image](assets/image/section1/4.JPG)

### 処理

#### 理解のための前提条件

##### 定数と初期化ベクトル

現在、私たちは SHA-256 関数の処理の最初のステップに向けて準備をしています。良いレシピのように、私たちはいくつかの基本的な要素が必要です。これらは定数と初期化ベクトルと呼ばれます。
初期化ベクトル A から H は、最初の 8 つの素数の平方根の小数部の最初の 32 ビットです。これらは処理の最初のステップでの基本的な値として使用されます。これらの値は 16 進数形式です。

定数 K は、0 から 63 までの値で、最初の 64 個の素数の立方根の小数部の最初の 32 ビットを表します。これらは圧縮関数の各ラウンドで使用されます。これらの値も 16 進数形式です。

##### 使用される演算子

圧縮関数では、XOR、AND、NOT などの特定の演算子が使用されます。ビットごとにランクに従って処理を行い、XOR 演算子と真理値表を使用します。AND 演算子は、両方のオペランドが 1 と等しい場合にのみ 1 を返し、NOT 演算子はオペランドの反対の値を返します。また、指定した数だけビットを右にシフトするために SHR 演算も使用します。

真理値表：

![image](assets/image/section1/6.JPG)

ビットシフト演算：

![image](assets/image/section1/7.JPG)

#### 圧縮関数

圧縮関数を適用する前に、入力を 512 ビットのブロックに分割します。各ブロックは独立して処理されます。

各 512 ビットのブロックは、32 ビットの W ピースに再分割されます。つまり、W(0)は 512 ビットブロックの最初の 32 ビットを表し、W(1)は次の 32 ビットを表し、以降、ブロックの 512 ビットに到達するまで続きます。

すべての定数 K と W ピースが定義されたら、各 W ピースに対して以下の計算を各ラウンドで行います。

圧縮関数では 64 回の計算ラウンドが行われます。最後のラウンドでは、「関数の出力」で圧縮関数の初期状態に加算される中間状態が得られます。

その後、次の 512 ビットブロックに対して圧縮関数のすべてのステップを繰り返し、最後のブロックまで処理します。

圧縮関数内のすべての加算は、32 ビットの合計を常に保つために 2^32 で割った余りを使用します。

![image](assets/image/section1/9.JPG)

![image](assets/image/section1/8.JPG)

##### 圧縮関数の 1 ラウンド

![image](assets/image/section1/11.JPG)

![image](assets/image/section1/10.JPG)
圧縮関数のラウンドは 64 回行われます。入力には、以前に定義されたブロック W と定数 K が含まれます。
赤い四角/クロスは、2^32 ビットのモジュロ加算を示しています。

A、B、C、D、E、F、G、H の入力は、合計で 32 \* 8 = 256 ビットの値に関連付けられます。
また、新しい A、B、C、D、E、F、G、H のシーケンスも出力されます。この出力は次のラウンドの入力として使用され、64 番目のラウンドまで続きます。

圧縮関数の最初のラウンドの入力シーケンスの値は、前述の初期化ベクトルに対応します。
初期化ベクトルは、最初の 8 つの素数の平方根の小数部の 32 ビットを表します。

以下は、1 つのラウンドの例です。

![image](assets/image/section1/12.1.png)

##### 中間状態

メッセージは 512 ビットのブロックに分割され、それぞれのブロックは 32 ビットの部分に分割されます。512 ビットのブロックごとに、圧縮関数の 64 ラウンドを適用します。
中間状態は、1 つのブロックの 64 ラウンドの終わりに対応します。この 64 番目のラウンドの出力シーケンスの値は、次のブロックの最初のラウンドの初期値として使用されます。

![image](assets/image/section1/12.2.png)

#### ハッシュ関数の全体像

![image](assets/image/section1/13.JPG)

512 ビットの最初のメッセージの出力は、次の 512 ビットのメッセージの入力として使用されます。

最後のラウンド、最後の部分の出力は、SHA256 関数の最終結果に対応します。

最後に、CH、MAJ、σ0、および σ1 ボックスで行われる計算の重要性を強調したいと思います。これらの操作は、SHA256 ハッシュ関数の耐攻撃性を確保するガードとなっており、多くのデジタルシステムのセキュリティ確保において、特に Bitcoin プロトコル内での選択肢となっています。したがって、SHA256 の複雑さにもかかわらず、その美しさは、ハッシュから入力を復元する堅牢性にありますが、特定の入力のハッシュの検証は機械的に簡単な操作です。

## 派生に使用されるアルゴリズム

![Les algorithmes utilisés pour la dérivation](https://youtu.be/ZF1_BMsOJXc)

HMAC および PBKDF2 の派生アルゴリズムは、Bitcoin プロトコルのセキュリティメカニズムにおける重要な要素です。これらはさまざまな攻撃を防ぎ、Bitcoin ウォレットの完全性を保証します。
HMAC と PBKDF2 は、Bitcoin でさまざまなタスクに使用される暗号ツールです。HMAC は、階層的に決定されたウォレットの派生時に長さ拡張攻撃に対抗するために主に使用されます。一方、PBKDF2 はニーモニックフレーズをシードに変換するために使用されます。

#### HMAC-SHA512

HMAC-SHA512 は、2 つの入力、メッセージ m（入力 1）とユーザーが任意に選択したキー K（入力 2）を持つ特徴を持ちます。
また、固定サイズの出力（512 ビット）もあります。

```
以下のように定義します：
- m：ユーザーが任意に選択した任意のサイズのメッセージ（入力1）
- K：ユーザーが任意に選択した任意のキー（入力2）
- K'：Kを調整したキー。これはブロックのサイズBに合わせて調整されました。
- ||：連結操作
- opad：0x5cバイトをB回繰り返した定数
- ipad：0x36バイトをB回繰り返した定数
- B：使用されるハッシュ関数のブロックサイズ
```

![image](assets/image/section1/14.JPG)

HMAC-SHA512 は、メッセージとキーを入力として受け取り、固定サイズの出力を生成します。一貫性を確保するために、キーはハッシュ関数で使用されるブロックのサイズに合わせて調整されます。HD ウォレットの派生においては、HMAC-SHA-512 が使用されます。このアルゴリズムは 1024 ビット（128 バイト）のブロックを使用し、キーを適切に調整します。セキュリティを強化するために、OPAD（0x5c）と IPAD（0x36）の定数を必要な回数繰り返します。

HMAC-SHA-512 のプロセスは、キー XOR OPAD とキー XOR IPAD に SHA-512 を適用した結果をメッセージと連結することを含みます。1024 ビット（128 バイト）のブロックを使用する場合、入力キーは必要に応じてゼロで埋められ、次に IPAD と OPAD と XOR されます。変更されたキーは、その後、メッセージと連結されます。

![image](assets/image/section1/15.JPG)

追加のエントロピー源を組み込んだチェーンコードは、派生キーのセキュリティを向上させます。これがないと、攻撃者はウォレット全体を侵害し、すべてのビットコインを盗む可能性があります。

PBKDF2 は、ニーモニックフレーズをシードに変換するために使用されます。このアルゴリズムは、HMAC SHA512 を使用して 2048 回のラウンドを実行します。これらの派生アルゴリズムにより、異なる入力でも一意かつ固定の出力が生成され、SHA-2 ファミリの関数における長さ拡張攻撃の問題が解決されます。
長さ拡張攻撃は、特定の暗号ハッシュ関数の特性を利用した攻撃です。この攻撃では、既知のメッセージのハッシュを持つ攻撃者が、元のメッセージの拡張であるより長いメッセージのハッシュを計算することができます。これは、通常、元のメッセージの内容を知らなくても可能であり、整合性の検証などのタスクにこのようなハッシュ関数が使用されている場合、重大なセキュリティ上の脆弱性につながる可能性があります。

結論として、HMAC と PBKDF2 アルゴリズムは、Bitcoin プロトコルの HD ウォレットのセキュリティにおいて重要な役割を果たしています。HMAC-SHA-512 は、長さ拡張攻撃からの保護に使用され、PBKDF2 はニーモニックフレーズをシードに変換します。チェーンコードは、キーの派生に追加のエントロピー源を提供し、システムの堅牢性を確保します。

デジタル署名

デジタル署名と楕円曲線

これらの有名なビットコインはどこに保存されているのでしょうか？ビットコインウォレットには保存されていません。実際には、ビットコインウォレットにはビットコインの所有を証明するために必要な秘密鍵が保存されています。ビットコイン自体は、すべてのトランザクションをアーカイブする分散型データベースであるブロックチェーンに記録されています。

ビットコインシステムでは、ビットコイン（小文字の「b」に注意）が通貨単位です。ビットコインは 8 桁まで分割でき、最小単位はサトシです。UTXO（未使用トランザクション出力）は、トランザクションの出力であり、数学的に秘密鍵に関連付けられた公開鍵に属する未使用のトランザクション出力を表します。これらのビットコインを使用するには、トランザクションの支出条件を満たす必要があります。典型的な支出条件は、ネットワークの他のユーザーに対して、UTXO に関連付けられた公開鍵の正当な所有者であることを証明することです。これを行うために、ユーザーは UTXO に関連付けられた公開鍵に対応する秘密鍵を所有していることを証明しなければなりませんが、秘密鍵自体は公開してはなりません。

これがデジタル署名の役割です。デジタル署名は、特定の公開鍵に関連付けられた秘密鍵の所有を数学的に証明するための数学的な証拠となります。このデータ保護技術は、楕円曲線暗号学と呼ばれる魅力的な暗号学の分野に基づいています。

デジタル署名は、ビットコインネットワークの他の参加者によって数学的に検証することができます。
ビットコインのトランザクションのセキュリティを確保するために、ビットコインは 2 つのデジタル署名プロトコル、ECDSA（楕円曲線デジタル署名アルゴリズム）と Schnorr を使用しています。ECDSA は 2009 年のビットコインの開始以来、ビットコインに組み込まれた署名プロトコルであり、Schnorr の署名は 2021 年 11 月に追加されました。これら 2 つのプロトコルは楕円曲線暗号学に基づいており、数学的なメカニズムも似ていますが、主に署名の構造の違いがあります。
このコースでは、ECDSA アルゴリズムについて説明します。

### 楕円曲線とは何ですか？

楕円曲線暗号学は、楕円曲線の異なる幾何学的および数学的な特性を暗号目的で利用する一連のアルゴリズムであり、その安全性は離散対数の計算の困難さに基づいています。

楕円曲線は、ビットコインプロトコルにおける鍵交換、非対称暗号化、デジタル署名など、さまざまな暗号アプリケーションで役立ちます。

楕円曲線には興味深い特性があります：

- 対称性：楕円曲線上の 2 つの点を結ぶ垂直でない直線は、曲線上の 3 番目の点で交差します。
- 曲線上の点で接線となる垂直でない直線は、常に曲線上の 2 番目の一意の点で交差します。

ビットコインプロトコルでは、特定の楕円曲線である Secp256k1 を使用して暗号操作を行います。

これらの署名メカニズムにより深く理解する前に、楕円曲線の定義を理解することが重要です。楕円曲線は、方程式 y² = x³ + ax + b によって定義されます。この曲線上のすべての点には、暗号学での有用性の鍵となる特異な対称性があります。

![image](assets/image/section2/1.JPG)

最終的に、さまざまな楕円曲線が暗号目的で安全と認識されています。もっともよく知られているのは、secp256r1 という曲線かもしれません。しかし、ビットコインでは、Satoshi Nakamoto は別の曲線、secp256k1 を選択しました。

この曲線は、a=0、b=7 のパラメータで定義され、その方程式は y² = x³ + 7 modulo n です。ここで、n は曲線の次数を決定する素数です。

![image](assets/image/section2/2.JPG)

最初の画像は、実数体上の secp256k1 曲線とその方程式を表しています。
2 番目の画像は、ZP 体（非負の自然数体）上の secp256k1 曲線の表現であり、p は素数であり、点の集合を表しています。これは点の雲のように見えます。近似を避けるために、非負の自然数体を使用しています。
p は素数であり、曲線の次数として使用されます。
最終的に、Bitcoin プロトコルで使用される方程式は次のようになります：

$$
y^2 = (x^3 + 7) mod(p)
$$

Bitcoin の楕円曲線の方程式は、前の画像の最後の方程式に対応しています。

このコースの次のセクションでは、理解を容易にするために、実数体上にある曲線を使用します。

### 秘密鍵から公開鍵を計算する

![秘密鍵から公開鍵を計算する](https://youtu.be/NJENwFU889Y)

まず、楕円曲線デジタル署名アルゴリズム（ECDSA）の世界に入りましょう。Bitcoin は、このデジタル署名アルゴリズムを使用して、秘密鍵と公開鍵を関連付けます。このシステムでは、秘密鍵は 256 ビットのランダムまたは擬似ランダムな数値です。秘密鍵の可能性の総数は理論的には 2^256 ですが、実際にはそれよりもわずかに少なくなります。正確には、256 ビットの一部の秘密鍵は Bitcoin には有効ではありません。

Bitcoin と互換性を持つために、秘密鍵は 1 から n-1 の範囲にある必要があります。ここで、n は楕円曲線の次数を表します。したがって、Bitcoin の秘密鍵の可能性の総数は、おおよそ 1.158 x 10^77 です。これを考えると、それはおおよそ観測可能な宇宙に存在する原子の数と同じです。

![image](assets/image/section2/3.JPG)

一意の秘密鍵である k は、次に公開鍵を決定するために使用されます。

公開鍵である K は、ECDSA などの不可逆なアルゴリズムを使用して、秘密鍵から派生した楕円曲線上の点です。秘密鍵がわかっている場合、公開鍵を見つけることは非常に簡単ですが、公開鍵のみがわかっている場合、秘密鍵を見つけることは不可能です。この不可逆性は、Bitcoin ウォレットのセキュリティの基盤です。

公開鍵は 512 ビットであり、256 ビットの x 座標と 256 ビットの y 座標で表される曲線上の点に対応しています。ただし、264 ビットの数値に圧縮することもできます。

![image](assets/image/section2/4.JPG)

生成点（G）は、Bitcoin プロトコル上ですべての公開鍵が生成される曲線上の点です。それは特定の x 座標と y 座標を持ち、通常は 16 進数で表されます。secp256k1 の場合、G の座標は次のようになります：

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8`
  このポイントは、すべての公開鍵を派生させるために役立ちます。公開鍵 K を計算するには、ポイント G を秘密鍵 k で乗算するだけです。K = k.G

次に、楕円曲線上のポイントの加算と乗算について説明します。

#### 楕円曲線上のポイントの加算と倍化

##### 2 つのポイント M + L の加算

楕円曲線の特性の 1 つは、垂直でない直線が曲線上の 2 つのポイントで交差する場合、その直線は 3 番目のポイントである O とも交差するということです。この特性を利用して、ポイント U を決定します。U はポイント O の反対です。

M + L = U

![image](assets/image/section2/5.JPG)

##### ポイントの自己加算= ポイントの倍化

ポイント G を自身に加算するには、そのポイントで曲線の接線を引きます。この接線は、楕円曲線の特性により、曲線と必ず 2 番目のユニークなポイント-J で交差します。このポイントの反対である J は、ポイント G を自身に加算した結果です。
G + G = J

実際、ポイント G は、Bitcoin システムのユーザーのすべての公開鍵を計算するための出発点です。

![image](assets/image/section2/6.JPG)

#### 楕円曲線上のスカラー積

ポイントのスカラー積は、そのポイントを自身に n 回加算することを意味します。

ポイント G の 2 倍化と同様に、ポイント G の n 倍のスカラー積は、ポイント G で曲線の接線を引くことで行われます。この接線は、楕円曲線の特性により、曲線と必ず 2 番目のユニークなポイント-2G で交差します。このポイントの反対である 2G は、ポイント G を自身に加算した結果です。

n = 4 の場合、4G に到達するまで操作を繰り返します。

![image](assets/image/section2/7.JPG)

以下は、3G の計算例です。

![image](assets/image/section2/8.JPG)

これらの楕円曲線上のポイント操作は、公開鍵の計算の基礎です。秘密鍵を知っている場合、公開鍵の派生は非常に簡単です。
公開鍵は楕円曲線上のポイントであり、ポイント G を k 回加算および倍化した結果です。ここで、k は秘密鍵です。

この例では：

- 秘密鍵 k = 4
- 公開鍵 K = kG = 4G

![image](assets/image/section2/9.JPG)
秘密鍵 k を知っている場合、公開鍵 K を計算することは容易です。一方、公開鍵から秘密鍵を復元することは不可能です。これは、点の加算または倍加による結果ですか？
次のレッスンでは、ビットコインを使用して ECDSA アルゴリズムを使ってデジタル署名を行う方法について説明します。

## 秘密鍵で署名する

![秘密鍵で署名する](https://youtu.be/h2hIyGgPqkM)

デジタル署名のプロセスは、秘密鍵の所有者であることを証明するための重要な手段であり、秘密鍵を明かさずに行われます。これは ECDSA アルゴリズムを使用して行われ、一意のノンスの決定、特定の数値 V の計算、および 2 つの部分 S1 と S2 からなるデジタル署名の作成を含みます。
セキュリティ攻撃を回避するためには常に一意のノンスを使用することが重要です。このルールを守らなかった場合に起こり得る有名な例は、PlayStation 3 のハッキング事件です。これはノンスの再利用によって侵害されました。

![](assets/image/section2/10.JPG)

手順：

- ノンス v を決定する。つまり、一意のランダムな数値です。
  ノンス = Number Only Use Once（一度だけ使用する数値）。
  署名を行う人が決定します。
- 楕円曲線上の点 G から加算と倍加の計算を行い、V の楕円曲線上の位置を求めます。
  V = v.G
  x と y は平面上の V の座標です。
- S1 を計算します。
  S1 = x mod n（n は曲線の次数であり、x は平面上の V の座標です）。
  注：公開鍵の可能性の数は、ビットコインで使用される正の整数の有限体上の楕円曲線上の点の数よりも大きいです。
  曲線の次数は、公開鍵が取る可能性のある値に対応しています。
- S2 を計算します。
  H(Tx) = トランザクションのハッシュ
  k = 秘密鍵
- 署名を計算します：S1 + S2 の連結。
- 検証のための計算 P を行います。
  K = 公開鍵

例えば、公開鍵 3G を取得するには、点 G に接線を引き、-G の反対を計算して 2G を得た後、G と 2G を加算します。トランザクションを行うためには、公開鍵 3G に関連付けられたビットコインをロック解除するために、数値 3 を知っていることを証明する必要があります。
3G と関連する秘密鍵を知っていることを証明し、デジタル署名を作成するために、まず nonce を計算し、その nonce に関連する点 V（この例では 4G）を計算します。次に、公開鍵 3G と点 V を加算して点 T を計算し、結果は 7G です。

デジタル署名プロセスを簡単に説明します。
前の画像では、秘密鍵 k = 3 です。
この秘密鍵に関連する公開鍵 K を簡単に計算できます：K = 3G
次に、疑似乱数の nonce を生成します：v = 4。
この nonce から、V を以下のように計算できます：V = v.G = 4G。

この点 V から、以下のように点 T を計算します：
T = t.G = 7G（ただし、t = 7）

デジタル署名の検証を行う時が来ました。

デジタル署名の検証は、送信者の秘密鍵を必要とせずに、署名されたメッセージの真正性を確認するための ECDSA アルゴリズムの重要なステップです。以下に、詳細な手順を示します：

この例では、t と V という 2 つの重要な値があります。
t は数値（この例では 7）であり、V は楕円曲線上の点（ここでは 4G で表される）です。これらの値はデジタル署名の作成時に生成され、メッセージと共に送信されます。

検証者がメッセージを受け取ると、t と V の 2 つの値も受け取ります。

検証者が署名を検証するために以下の手順を実行します：

1. まず、メッセージのハッシュ値である H を計算します。
2. 次に、u1 と u2 を計算します。以下の式を使用します：
   - u1 = H /\* (S2)^-1 mod n
   - u2 = T /\* (S2)^-1 mod n
     ここで、S2 はデジタル署名の 2 番目の部分、n は楕円曲線の位数、(S2)^-1 は S2 の逆数 mod n です。
3. 次に、検証者は以下の式を使用して楕円曲線上の点 P'を計算します：P' = u1 _ G + u2 _ K
   - G は楕円曲線の生成点です。
   - K は送信者の公開鍵です。
4. 検証者は、単純に点 P'の x 座標を n で割った余りである I'を計算します。
5. 最後に、検証者は I'が t と等しいかどうかを確認します。等しい場合、署名は有効と見なされます。そうでない場合、署名は無効です。
   この手順により、対応する秘密鍵を持つ送信者のみが、この検証プロセスをパスする署名を生成できることが保証されます。
   ![image](assets/image/section2/12.JPG)

簡単に言うと、署名を生成する人は、検証する人に t（この例では t = 7）と点 V を提供します。

数字 7 と数字 V から公開鍵または秘密鍵を特定することは不可能です。

デジタル署名の検証手順は次のとおりです：

- 曲線上で、公開鍵の点と点 V を加算して点 T'を求めます。
- 数字 t.G を計算します。
- t.G の結果が数字 T'と等しいかどうかを確認します。

結論として、デジタル署名の検証はビットコイン取引において重要な手順です。これにより、署名されたメッセージが送信中に変更されていないこと、送信者が秘密鍵の所有者であることが保証されます。このデジタル認証技術は、楕円曲線算術などの複雑な数学的原理に基づいており、秘密鍵の機密性を維持しながら、暗号取引の堅固なセキュリティ基盤を提供します。

ただし、これらの鍵の管理と生成は、ビットコインにおいて別の重要な問題です。新しい鍵ペアを生成する方法は？多数の鍵を安全かつ効率的に管理する方法は？必要な場合にこれらの鍵を回復する方法は？

これらの質問に答え、暗号セキュリティの理解を深めるために、次のコースでは階層的決定的ウォレット（HD ウォレット）の概念とニーモニックフレーズの使用に焦点を当てます。これらのメカニズムは、暗号通貨の鍵を効率的に管理するための優れた手段を提供し、セキュリティを強化します。

# ニーモニックフレーズ

## ビットコインウォレットの進化

![ビットコインウォレットの進化](https://youtu.be/6tmu1R9cXyk)

階層的決定的ウォレット（HD ウォレット）は、暗号通貨のエコシステムにおいて重要な役割を果たしています。"ウォレット"という用語は、この分野に初めて触れる人にとっては誤解を招くかもしれませんが、お金や通貨を保持することを意味しません。それはむしろ、暗号鍵のコレクションを指します。

最初のウォレットは、疑似乱数的に決定されたプライベートキーをまとめたソフトウェアでしたが、それらのキーには何の関連性もありませんでした。これらのウォレットは"Just a Bunch Of Keys"（JBOK）と呼ばれています。

キーには関連性がないため、新しいキーペアが生成されるたびに新しいバックアップを作成する必要があります。
ユーザーは、常に同じキーペアを使用して機密性を失うか、ランダムに新しいキーペアを生成し、そのキーの新しいバックアップを作成する必要があります。

ただし、これらのキーの管理の複雑さは、Bitcoin Improvement Proposals（BIP）と呼ばれる一連のプロトコルによって補われています。これらのアップグレード提案は、HD ウォレットの機能とセキュリティの中心に位置しています。たとえば、2012 年に発表された[BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)は、これらのキーの生成と保存方法を革新し、決定論的かつ階層的に派生するキーの概念を導入しました。アイデアは、すべてのキーを一意の情報であるシードから決定論的かつ階層的に派生させることです。これにより、これらのキーのバックアッププロセスが大幅に簡素化され、同時にセキュリティレベルが維持されます。

その後、[BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)は、24 語のニーモニックフレーズという画期的なイノベーションを導入しました。このシステムにより、複雑で覚えにくい数字のシーケンスを、より簡単に覚えて保存できる一連の普通の単語に変換することができました。さらに、[BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki)では、個々のキーのセキュリティを強化するために追加のパスフレーズを提案しました。これらの連続的な改善により、BIP43 と BIP44 の標準化が実現され、HD ウォレットの構造と階層化が統一され、一般のユーザーにとってよりアクセスしやすく、使いやすくなりました。

次のセクションでは、HD ウォレットの動作について詳しく説明します。キーの派生の原則について取り上げ、ポートフォリオのセキュリティを確保するために不可欠なエントロピーと乱数生成の基本的な概念を検討します。

まとめとして、BIP32 と BIP39 の役割を強調することは重要です。これらのプロトコルは、ランダムまたは擬似ランダムなシードから複数のキーを生成することを可能にします。これらの規格は、現在、単一の暗号通貨に特化したウォレットや複数の通貨タイプをサポートするウォレットの大部分で採用されています。
ビットコインのエコシステムにおける秘密鍵のセキュリティの重要性は否定できません。実際、これらの鍵はビットコインのトランザクションのセキュリティを保証する基盤です。予測可能性に関連する脆弱性を回避するために、これらの鍵は真にランダムに生成する必要がありますが、これは容易な作業ではありません。コンピュータ上では、真にランダムな数値を生成することは不可能です。なぜなら、それは必ず決定論的なプロセス、つまりコードから派生しているからです。そのため、さまざまなランダム数値生成器（RNG）についての情報を得ることが重要です。RNG の種類は、疑似乱数生成器（PRNG）から真の乱数生成器（TRNG）やエントロピー源を組み込んだ PRNG までさまざまです。

エントロピーは、システムの「乱雑さ」を指します。外部エントロピー、つまり外部情報源を使用して、ランダム数値生成器を使用してランダムな数値を取得することができます。

![image](assets/image/section3/2.JPG)

では、疑似乱数生成器（PRNG）の動作を見てみましょう。

PRNG は、内部状態 0 に対応するシード、つまり情報を入力として受け取ります。
この内部状態に対して変換関数が適用され、結果である疑似乱数が内部状態 1 に対応します。
内部状態 1 に対しても再び変換関数が適用され、新しいランダムな数値=内部状態 2 が得られます。
そして、これが続きます。

主な欠点は、同じシードは常に同じ結果を出力するということです。また、変換関数の結果を知っていれば、プロセスの出力のランダムな数値を復元することができます。

変換関数の例として、PBKDF2 関数があります。

**要約すると、暗号的に安全な PRNG は次の条件を満たす必要があります：**

- 統計的にランダムであること
- 予測不可能であること
- 結果が公開されても耐性があること
- 十分に長い周期を持つこと

![image](assets/image/section3/3.JPG)

ビットコインの場合、秘密鍵はウォレットの基礎となる単一の情報から生成されます。この情報により、子鍵の決定論的かつ階層的な派生が可能となります。エントロピーは、すべての HD ウォレットの基盤ですが、このランダムな数値の生成には標準が存在しないため、ビットコインのトランザクションのセキュリティを確保するためにランダム数値の生成は重要な課題です。

## ニーモニックフレーズ

![ニーモニックフレーズ](https://youtu.be/uJERqH9Xp7I)
ビットコインウォレットのセキュリティは、すべてのユーザーにとって重要な問題です。ウォレットのバックアップを確保するための重要な方法は、エントロピーとチェックサムに基づいたニーモニックフレーズを生成することです。
![image](assets/image/section3/5.JPG)

エントロピーからニーモニックフレーズに変換するには、エントロピーのチェックサムを計算し、エントロピーとチェックサムを連結するだけです。

エントロピーが生成されたら、エントロピーに対して SHA256 関数を使用してハッシュを作成します。
ハッシュの最初の 8 ビットを取得し、それがチェックサムです。
ニーモニックフレーズは、エントロピーにチェックサムを加えた結果です。

チェックサムは、回復フレーズの正確性を確認するためのものです。このチェックサムがないと、フレーズの誤りにより異なるウォレットが作成され、資金が失われる可能性があります。エントロピーを SHA256 関数に通し、ハッシュの最初の 8 ビットを取得することでチェックサムを取得します。

![image](assets/image/section3/6.JPG)

エントロピーのサイズに応じて、ニーモニックフレーズの異なる標準が存在します。24 ワードの回復フレーズのために最も一般的に使用される標準は、256 ビットのエントロピーです。チェックサムのサイズは、エントロピーのサイズを 32 で割ることで決定されます。

例えば、256 ビットのエントロピーは 8 ビットのチェックサムを生成します。エントロピーとチェックサムの連結により、それぞれ 128 ビット、160 ビットなどのサイズが得られます。エントロピーのサイズに応じて、回復フレーズは 128 ビットの場合には 12 ワード、160 ビットの場合には 15 ワード、256 ビットの場合には 24 ワードとなります。

**ニーモニックフレーズのエンコーディング：**

![image](assets/image/section3/7.JPG)

最後の 8 ビットはチェックサムに対応します。
11 ビットのセグメントごとに 10 進数に変換されます。
各 10 進数は、BIP39 の 2048 語のリストから取得される単語に対応します。なお、同じ順序で最初の 4 文字を持つ単語は存在しません。

24 ワードの回復フレーズをバックアップすることは、ビットコインウォレットの完全性を保護するために重要です。最も一般的に使用される 2 つの標準は、128 ビットまたは 256 ビットのエントロピーと 12 または 24 ワードの連結です。パスフレーズの追加は、ウォレットのセキュリティを強化するための追加オプションです。

結論として、ビットコインウォレットのセキュリティを確保するためには、ニーモニックフレーズの生成は重要なプロセスです。エントロピーのサイズに応じて、ニーモニックフレーズの標準を遵守することが重要です。24 ワードの回復フレーズのバックアップは、資金の損失を防ぐために不可欠です。

## パスフレーズ

![パスフレーズ](https://youtu.be/dZkOYO7MXwc)
パスフレーズは、ビットコインウォレットに追加できる追加のパスワードであり、セキュリティを強化するために使用されます。その使用は任意であり、ユーザーの裁量に委ねられます。パスフレーズは、メモニックフレーズと組み合わせてウォレットのシードを計算するための任意の情報を追加することで、そのセキュリティを強化します。

![画像](assets/image/section3/8.JPG)

パスフレーズは、ユーザーが選択したサイズのオプションの暗号化ソルトです。これにより、メモニックフレーズに結合される任意の情報を追加することで、HD ウォレットのセキュリティを向上させることができます。

ウォレットの作成時に設定された場合、パスフレーズはウォレットのすべてのキーの派生に必要です。パスフレーズからシードを生成するためには、pbkdf2 関数が使用されます。このシードを使用して、ウォレットのすべての子キーペアを派生させることができます。パスフレーズが変更されると、ビットコインウォレットは完全に異なるものになります。

パスフレーズは、ビットコインウォレットのセキュリティを強化するための重要なツールです。さまざまなセキュリティ戦略を適用することができます。たとえば、メモニックフレーズのバックアップを作成しやすくするために、重複を作成するために使用することができます。また、メモニックフレーズのランダム生成に関連するリスクを軽減することで、ウォレットのセキュリティを向上させることもできます。

効果的なパスフレーズは、長さ（20〜40 文字）と多様性（大文字、小文字、数字、記号の使用）があります。ユーザーや環境に直接関連付けられていないほうが安全です。パスフレーズとして単純な単語ではなく、ランダムな文字列を使用する方が安全です。

![画像](assets/image/section3/9.JPG)

パスフレーズは、単純なパスワードよりも安全です。理想的なパスフレーズは、長く、多様で、ランダムです。ウォレットやホットウォレットのセキュリティを強化することができます。また、冗長で安全なバックアップを作成するためにも使用することができます。

ウォレットへのアクセスを失わないように、パスフレーズのバックアップに注意することが重要です。パスフレーズは HD ウォレットのオプションです。サイコロや他の擬似乱数生成器を使用してランダムに生成することができます。パスフレーズやメモニックフレーズを記憶することはお勧めしません。

次のレッスンでは、シードの動作とそれから生成される最初のキーペアについて詳しく説明します。学習を続けるために、このレッスンをフォローしてください。お会いできるのを楽しみにしています。

# ビットコインウォレットの作成

## シードとマスターキーの作成

![シードとマスターキーの作成](https://youtu.be/56yAt_JDWhY)
このコースのこの部分では、階層的決定ウォレット（HD ウォレット）の派生手順について説明します。HD ウォレットは、階層的かつ決定論的にプライベートキーとパブリックキーを作成および管理することができます。

![画像](assets/image/section4/0.JPG)

HD ウォレットの基礎は、ニーモニックフレーズとパスフレーズ（オプションの追加パスワード）の 2 つの要素に基づいています。これらはシードを構成し、ウォレットのキーを派生するための基盤となる 512 ビットのアルファベット数字のシーケンスです。このシードから、ビットコインウォレットのすべての子キーペアを派生することができます。シードは、パスフレーズの使用の有無に関係なく、ウォレットに関連するビットコイン全体にアクセスするためのキーです。

![画像](assets/image/section4/1.JPG)

シードを取得するために、ニーモニックフレーズとパスフレーズを使用して pbkdf2（Password-Based Key Derivation Function 2）関数を使用します。pbkdf2 の出力は 512 ビットのシードです。

シードから、HMAC SHA-512（Hash-based Message Authentication Code Secure Hash Algorithm 512）アルゴリズムを使用してマスタープライベートキーとチェーンコードを決定することができます。このアルゴリズムは、結果を生成するためにメッセージとキーを入力として必要とします。マスタープライベートキーは、シードと「Bitcoin SEED」というフレーズから計算されます。このフレーズは、すべての HD ウォレットのすべての派生において同じであり、ウォレット間の一貫性を保証します。

元々、SHA-512 関数は Bitcoin プロトコルに実装されていませんでしたので、HMAC SHA-512 を使用しています。HMAC SHA-512 を「Bitcoin SEED」というフレーズとともに使用することで、ユーザーは Bitcoin に特化したウォレットを生成するよう制約されます。HMAC SHA-512 の結果は、512 ビットの数値であり、左側の 256 ビットがマスタープライベートキーを表し、右側の 256 ビットがマスターチェーンコードを表します。

![画像](assets/image/section4/2.JPG)

マスタープライベートキーは、ウォレットの将来のすべてのキーの親キーであり、マスターチェーンコードは子キーの派生に関与します。親ペアの対応するチェーンコードを知らないと、子キーペアを派生することはできません。

ウォレット内のキーペアには、プライベートキー、パブリックキー、およびチェーンコードが含まれます。チェーンコードは、子キーの派生にランダム性を導入し、情報の漏洩を防ぐために各キーペアを分離するためのものです。
マスタープライベートキーは、シードから派生した最初のプライベートキーであり、ウォレットの拡張キーとは何の関係もありません。次のレッスンでは、xPub、xPRV、zPub などの拡張キーについて詳しく説明し、なぜそれらが使用されるのか、どのように構築されるのかを理解します。

## 拡張キー

![拡張キー](https://youtu.be/TRz760E_zUY)

このコースのこの部分では、拡張キー（xPub、zPub、yPub）とそのプレフィックスについて学びます。これらはヒエラルキカルディターミニスティックウォレット（HD ウォレット）内で子キーの派生に重要な役割を果たします。

![画像](assets/image/section4/3.JPG)

拡張キーはマスターキーとは異なります。HD ウォレットはニーモニックフレーズとシードを生成し、マスターキーとマスターチェーンコードを取得します。拡張キーは子キーの派生に使用され、親キーと対応するチェーンコードの両方が必要です。拡張キーはこれらの 2 つの情報を組み合わせて派生プロセスを簡素化します。

![画像](assets/image/section4/4.JPG)

拡張公開キーは通常の子公開キーからのみ派生できますが、拡張プライベートキーは通常またはハードニングの派生において、子公開キーと子プライベートキーの両方を派生させることができます。ハードニング派生は親プライベートキーからの派生であり、通常の派生は親公開キーからの派生に対応します。

XPUB プレフィックスを使用した拡張キーの使用により、対応するプライベートキーまで遡ることなく新しいアドレスを派生させることができ、より高いセキュリティを提供します。拡張キーに関連するメタデータは、キーの階層内での役割と位置に関する重要な情報を提供します。

拡張キーは、特定のプレフィックス（XPRV、XPUB、YPUB、ZPUB）で識別されます。これにより、それが拡張プライベートキーまたは拡張公開キーであるか、およびその特定の目的が示されます。拡張キーに関連するメタデータには、バージョン（プレフィックス）、深さ、親公開キーのフィンガープリント、インデックス、ペイロード（チェーンコードと親キー）が含まれます。

![画像](assets/image/section4/5.JPG)

バージョンはキータイプを示します：xpub、xprv、...

深さは、マスターキーからの派生の数を表します。

親のフィンガープリントは、親キーのハッシュ 160 の最初の 4 バイトです。
インデックスは、その兄弟姉妹の中で拡張キーを生成するために使用されるペアの番号です。（兄弟姉妹 = 同じ深さのキー）例：3 番目のアカウントの xpub を派生させたい場合、そのインデックスは 2 になります（インデックスは 0 から始まるため）。

ペイロードは、チェーンコード（32 バイト）と親キー（33 バイト）で構成されています。

圧縮された公開鍵は 33 バイトのサイズであり、生の公開鍵は 512 ビットです。圧縮された公開鍵は、生の公開鍵と同じ情報を持ちながら、サイズが小さくなっています。拡張キーは 82 バイトのサイズであり、そのプレフィックスは 16 進数に変換されたものを基数 58 で表現しています。チェックサムは、HASH256 ハッシュ関数を使用して計算されます。

![image](assets/image/section4/6.JPG)

強化派生は、2 のべき乗（2^31）から始まります。一般的に使用されるプレフィックスは、xpub と zpub であり、それぞれレガシーおよび segwit v1 および segwit v0 の標準に対応しています。

次のレッスンでは、拡張キーとウォレットのマスターキーを使用した子キーペアの派生について学びます。

## 子キーペアの派生

![子キーペアの派生](https://youtu.be/FXhI-GmE9Aw)

思い出に、シードとマスターキーの計算について説明しました。これらは HD ウォレット（階層的決定ウォレット）の階層化と派生において重要な最初の要素です。シードは、128 ビットから 256 ビットの長さで、ランダムに生成されるか秘密のフレーズから生成されます。他のすべてのキーの派生において決定論的な役割を果たします。マスターキーは、シードから派生した最初のキーであり、他のすべての子キーペアの派生に使用されます。

マスターコードは、シードからウォレットの復元に重要な役割を果たします。同じシードから派生したすべてのキーは、同じマスターコードを持つことに注意してください。

![image](assets/image/section4/7.JPG)

HD ウォレットの階層化と派生により、キーとウォレットの構造の効率的な管理が可能になります。拡張キーは、数学的な計算と特定のアルゴリズムを使用して、親キーから子キーペアを派生させることができます。
子鍵ペアには、強化キーと通常のキーの 2 種類があります。拡張公開鍵は通常の子公開鍵の派生のみを許可し、拡張秘密鍵は通常モードまたは強化モードの両方の子公開鍵および子秘密鍵の派生を許可します。各鍵ペアには、それらを区別するためのインデックスがあります。
![image](assets/image/section4/8.JPG)

子鍵の派生には、親鍵とインデックス、および鍵ペアに関連するチェーンコードを連結した HMAC-SHA512 関数が使用されます。通常の子鍵のインデックスは 0 から 2 の 31 乗-1 までであり、強化子鍵のインデックスは 2 の 31 乗から 2 の 32 乗-1 までです。

![image](assets/image/section4/9.JPG)

![image](assets/image/section4/10.JPG)

子鍵ペアには、強化ペアと通常のペアの 2 種類があります。子鍵の派生プロセスでは、公開鍵が支出条件の生成に使用され、秘密鍵が署名に使用されます。拡張公開鍵は通常の子公開鍵の派生のみを許可し、拡張秘密鍵は通常モードまたは強化モードの両方の子公開鍵および子秘密鍵の派生を許可します。

![image](assets/image/section4/11.JPG)
![image](assets/image/section4/12.JPG)

強化派生では親秘密鍵が使用され、通常の派生では親公開鍵が使用されます。強化派生には HMAC-SHA512 関数が使用され、通常の派生には 512 ビットのハッシュが使用されます。子公開鍵は楕円曲線の生成器に子秘密鍵を乗算することで得られます。

![image](assets/image/section4/13.JPG)
![image](assets/image/section4/14.JPG)

多数の鍵ペアを決定論的に階層化および派生することにより、階層的派生のためのツリースキームを作成することができます。このトレーニングの次のコースでは、HD ウォレットの構造と派生パスについて詳しく説明し、特に派生パスの表記に重点を置いて学習します。

## ウォレットの構造と派生パス

![ウォレットの構造と派生パス](https://youtu.be/etO9UxwyE2I)
この章では、HD ウォレット（階層的決定ウォレット）内の派生木の構造を学びます。すでにシードの計算、マスターキー、および子キーペアの派生について調査しました。今度は、ウォレット内のキーの組織に焦点を当てます。
HD ウォレットでは、キーを組織するために深さのレイヤーを使用します。親キーから子キーへの派生ごとに、深さのレイヤーが対応します。

![image](assets/image/section4/15.JPG)

- 深さ 0 はマスターキーとマスターチェーンコードに対応します。

- 深さ 1 は、特定の目的に基づいて子キーを派生させるために使用されます。目的は、BIP 84 および Segwit v0/v1 の標準に準拠しています。

- 深さ 2 は、異なる暗号通貨やネットワークのアカウントを区別するために使用されます。これにより、異なる資金源に基づいてウォレットを組織することができます。Bitcoin の場合、インデックスは 0 になります。

- 深さ 3 は、ウォレットを異なるアカウントに組織するために使用され、より明確で組織化された構造を提供します。

- 深さ 4 は、公に通信されるアドレスに使用される内部および外部チェーンに対応します。インデックス 0 は外部チェーンに関連付けられ、インデックス 1 は内部チェーンに関連付けられます。各アカウントには、外部チェーン（0）と内部チェーン（1）の 2 つのチェーンがあります。深さ 4 は、マルチシグウォレットの場合にスクリプトのタイプを管理するためにも使用されます。

- 深さ 5 は、通常のウォレット上の受信アドレスに使用されます。次のセクションでは、子キーペアの派生について詳しく調べます。

![image](assets/image/section4/16.JPG)

各深さのレイヤーごとに、子キーペアを区別するためにインデックスを使用します。

アポストロフなしのインデックスは実際に使用されるインデックスに対応し、アポストロフ付きのインデックスは実際のインデックス+2^31 に対応します。強化派生では、インデックスは 2^31 から 2^32-1 まで使用されます。たとえば、インデックス 44'は実際のインデックス 2^31 + 44 に対応します。

特定の受信アドレスを生成するために、マスターキーとマスターチェーンコードから子キーペアを派生させます。その後、インデックスを使用して同じ深さの異なる子キーペアを区別します。
拡張キー（XPUB）などの拡張キーは、複数の人とウォレットを共有するために使用されます。派生パスは、外部チェーン（共有するためのアドレス）と内部チェーン（取引所のアドレス）を区別するために使用されます。
次の章では、受信アドレス、その使用の利点、および構築手順について説明します。

# ビットコインアドレスとは何ですか？

## ビットコインアドレス

![ビットコインアドレス](https://youtu.be/nqGBMjPtFNI)

この章では、ビットコインシステムで重要な役割を果たす受信アドレスについて探求します。これらはコインの受け取りに使用され、秘密鍵と公開鍵のペアから生成されます。Pay2PublicKey と呼ばれるスクリプトタイプがあり、ビットコインを公開鍵にロックすることができますが、一般的には受信アドレスを使用することが好まれます。

![画像](assets/image/section5/0.JPG)

受信者がビットコインを受け取りたい場合、公開鍵ではなく受信アドレスを送信者に提供します。アドレスは実際には公開鍵のハッシュであり、特定の形式を持っています。公開鍵は、楕円曲線上の点の加算や倍加などの数学的操作を使用して、子秘密鍵から派生します。

![画像](assets/image/section5/1.JPG)

アドレスから公開鍵に逆算することや、公開鍵から秘密鍵に逆算することはできないことに注意してください。アドレスの使用により、元々 512 ビットの公開鍵情報のサイズが削減されます。

ビットコインアドレスは使用の容易さのためにサイズが縮小されました。アドレスにはチェックサムがあり、タイプミスを検出し、ビットコインの損失リスクを減らすことができます。一方、公開鍵にはチェックサムがないため、タイプミスにより対応する資金が失われる可能性があります。

アドレスは、公開情報と秘密情報の間に第二のセキュリティレイヤーを提供し、秘密鍵の乗っ取りを困難にします。

各アドレスは一度だけ使用することが重要です。同じアドレスを再利用すると、プライバシーの問題が発生し、避けるべきです。

ビットコインアドレスにはさまざまなプレフィックスが使用されます。たとえば、BC1Q は Segwit V0 アドレス、BC1P は Taproot/Segwit V1 アドレス、プレフィックス 1 と 3 は Pay2PublicKeyH/Pay2ScriptH（レガシー）アドレスに関連付けられています。次のレッスンでは、公開鍵からアドレスの派生をステップバイステップで説明します。

## ビットコインアドレスの作成方法

![ビットコインアドレスの作成方法](https://youtu.be/ewMGTN8dKjI)
この章では、ビットコインのトランザクションのための受信アドレスの作成について説明します。受信アドレスは、圧縮された公開鍵のアルファベットと数字の文字列表現です。公開鍵から受信アドレスへの変換には、いくつかのステップが必要です。

### ステップ 1：公開鍵の圧縮

![image](assets/image/section5/14.png)

アドレスは、子公開鍵から派生します。

公開鍵は楕円曲線上の点です。楕円曲線の対称性により、楕円曲線上の点は x 座標に対して 2 つの可能な y 値（正または負）のみを持ちます。
しかし、ビットコインプロトコルでは、実数の代わりに有限の正の整数体で作業しています。2 つの y 値の区別をするために、y が偶数か奇数かを示すだけで十分です。

公開鍵の圧縮により、そのサイズを 520 ビットから 264 ビットに減らすことができます。

y が偶数の場合は 0x02、y が奇数の場合は 0x03 のプレフィックスを使用します。これが公開鍵の圧縮形式です。

### ステップ 2：圧縮された公開鍵のハッシュ

![image](assets/image/section5/3.JPG)

圧縮された公開鍵のハッシュは SHA256 関数で行われます。その後、RIPEMD160 関数がハッシュに適用されます。

### ステップ 3：ペイロード=アドレスのペイロード

![image](assets/image/section5/4.JPG)

RIPEMD160(SHA256(K))のバイナリハッシュは、5 ビットのグループに分割されます。各グループは 16 進数（ヘキサデシマル）および/または 10 進数に変換されます。

### ステップ 4：BCH プログラムを使用したチェックサムのメタデータの追加

![image](assets/image/section5/5.JPG)

レガシーアドレスの場合、アドレスのチェックサムを生成するためにダブルハッシュ SHA256 が使用されます。ただし、Segwit V0 および V1 アドレスの場合、エラーの検出を確実にするために BCH のチェックサム技術が使用されます。BCH プログラムは、非常に低いエラー確率でエラーを検出および修正することができます。現在、BCH プログラムは変更を提案および修正するために使用されますが、ユーザーの代わりに自動的に変更は行いません。
BCH プログラムは、拡張が必要な HRP（Human Readable Part）を含む複数の入力情報を必要とします。 HRP の拡張は、各文字を ASCII コードに基づいて 2 進数でエンコードすることです。次に、各文字の結果の最初の 3 ビットを 10 進数に変換します（画像の青色部分）。セパレーター 0 を挿入します。次に、各文字の事前に 10 進数に変換された最後の 5 ビットを連結します（画像の黄色部分）。
HRP の 10 進数拡張により、各文字の最後の 5 ビットが分離され、チェックサムが強化されます。

Segwit V0 バージョンは、コード 00 で表され、"payload"は黒で、10 進数で表されます。これには、チェックサム用に予約された 6 つの文字が続きます。

### ステップ 5：BCH プログラムを使用してチェックサムを計算する

![image](assets/image/section5/6.JPG)

メタデータを含む入力は、次に BCH プログラムに提出され、10 進数のチェックサムを取得します。

ここにチェックサムがあります。

### ステップ 6：アドレスの構築と Bech32 への変換

![image](assets/image/section5/7.JPG)

バージョン、ペイロード、およびチェックサムの連結により、アドレスが構築されます。次に、10 進数の文字は、対応表を使用して Bech32 文字に変換されます。Bech32 アルファベットには、1、b、i、および o を除くすべての英数字が含まれており、混乱を避けるためです。

### ステップ 7：HRP とセパレーターの追加

![image](assets/image/section5/8.JPG)

ピンク色がチェックサムです。
黒色がペイロード=公開鍵のハッシュです。
青色がバージョンです。

すべてを Bech32 に変換し、ビットコインの場合は 'bc' を追加し、セパレーターとして '1' を追加して、アドレスが完成します。

# より進んでいく

## 128 回のダイスロールからシードの作成！

![Création d’une seed depuis 128 lancés de dés !](https://youtu.be/lUw-1kk75Ok)

ニーモニックフレーズの作成は、暗号通貨ウォレットのセキュリティ確保における重要なステップです。ニーモニックフレーズを生成するためのいくつかの方法がありますが、ここではダイスを使用した手動生成方法に焦点を当てます。ただし、この方法は高額なウォレットには適していません。ニーモニックフレーズを生成するためには、オープンソースのソフトウェアまたはハードウェアウォレットを使用することをお勧めします。ニーモニックフレーズを作成するために、ダイスを使用してバイナリ情報を生成します。目的は、ニーモニックフレーズの作成プロセスを理解することです。

**ステップ 1 - 準備：**
セキュリティのために、Tails OS などのメモリレスの Linux ディストリビューションを USB キーにインストールしてください。このチュートリアルはメインウォレットを作成するために使用しないでください。
**ステップ 2 - ランダムバイナリ数の生成：**
バイナリ情報を生成するためにダイスを使用します。128 回ダイスを振り、結果を記録します（奇数の場合は 1、偶数の場合は 0）。

**ステップ 3 - バイナリ数の整理：**
得られたバイナリ数を 11 桁の行に整理して、後の計算を容易にします。12 行目は 7 桁のみである必要があります。

**ステップ 4 - チェックサムの計算：**
12 行目の最後の 4 桁はチェックサムに対応します。このチェックサムを計算するには、Linux ディストリビューションのターミナルを使用する必要があります。[TailOs](https://tails.boum.org/index.fr.html)を使用することをお勧めします。これは USB キーからブート可能なメモリレスディストリビューションです。ターミナルに入り、`echo <binary number> | shasum -a 254 -0`というコマンドを入力します。`<binary number>`を 128 個の 0 と 1 のリストに置き換えます。出力は 16 進数のハッシュです。このハッシュの最初の文字を取得し、バイナリに変換します。[この表](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table)を参考にしてください。バイナリのチェックサム（4 桁）を 12 行目に追加します。

**ステップ 5 - 10 進数への変換：**
各行に関連付けられた単語を見つけるには、まず 11 ビットのシリーズを 10 進数に変換する必要があります。オンラインの変換ツールは使用できません。これらのビットはニーモニックフレーズを表しているためです。計算機と以下のトリックを使用して変換する必要があります。各ビットは 2 のべき乗に関連付けられており、左から右に 11 のランクがあります。それぞれ 1024、512、256、128、64、32、16、8、4、2、1 に対応しています。11 ビットのシリーズを 10 進数に変換するには、1 を含むランクのみを加算します。たとえば、シリーズ 00110111011 の場合、次のような加算になります：256 + 128 + 32 + 16 + 8 + 2 + 1 = 443。各行を 10 進数に変換できます。単語のエンコードに進む前に、すべての行に+1 を追加する必要があります。なぜなら、BIP39 の単語リストのインデックスは 0 ではなく 1 から始まるためです。

**ステップ 8 - ニーモニックフレーズの生成：**
まず、[2048 ワードリスト](https://seedxor.com/files/wordlist.pdf)を印刷して、10 進数と BIP39 の単語の変換を行います。このリストの特徴は、この辞書の他のすべての単語と共通して最初の 4 文字を持たないことです。次に、各行に関連する 10 進数の単語を検索します。
**ステップ 9 - ニーモニックフレーズのテスト：**
Sparrow Wallet でニーモニックフレーズをすぐにテストし、それを使用してウォレットを作成します。無効なチェックサムエラーが表示された場合、計算ミスをした可能性があります。このエラーを修正するには、ステップ 4 からやり直して、再度 Sparrow Wallet でテストしてください。これで、128 回のダイスロールから新しい Bitcoin ウォレットが作成されました。

ニーモニックフレーズを生成することは、暗号通貨ウォレットを保護するための重要なプロセスです。ソフトウェアのオープンソースやハードウェアウォレットの使用など、より安全な方法を使用することが推奨されます。ただし、このワークショップを行うことで、ランダムな数値から Bitcoin ウォレットを作成する方法をより理解することができます。

## ボーナス：Théo Pantamis へのインタビュー

Bitcoin プロトコルで広く使用されている別の暗号化メソッドは、デジタル署名のメソッドです。

## 結論と最後

### 感謝とウサギの穴を掘り続ける

Crypto 301 のトレーニングにご参加いただき、心から感謝申し上げます。この経験が有益で学びになったことを願っています。数学、暗号化、Bitcoin プロトコルの動作など、多くの興味深いトピックを取り上げました。

さらに学習を深めたい場合、追加のリソースを提供しています。Théo Pantamis と Loïc Morel とのインタビューを実施しました。これらの専門家は暗号化の分野で高名です。このインタビューでは、さまざまな側面を詳しく探求し、興味深い視点を提供しています。

暗号化の魅力的な領域をさらに探求するために、ぜひこのインタビューをご覧ください。あなたの旅に役立ち、インスピレーションを与えることを願っています。改めて、このトレーニングに参加していただき、ご協力いただきありがとうございました。

### サポートしてください

このコースおよびこの大学のすべてのコンテンツは、私たちのコミュニティによって無料で提供されています。私たちをサポートするために、周りで共有したり、大学のメンバーになったり、GitHub を通じて開発に貢献したりすることができます。チーム全員を代表して、ありがとうございます！

### コースの評価

この新しい E-learning プラットフォームには、コースの評価システムが近日中に統合される予定です！それまでの間、このコースを受講していただき、お楽しみいただけた場合は、周りで共有することをお考えください。
