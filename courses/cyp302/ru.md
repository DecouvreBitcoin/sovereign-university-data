---
name: Введение в формальную криптографию
goal: Глубокое погружение в науку и практику криптографии.
objectives:
  - Изучить шифры Била и современные криптографические методы для понимания базовых и исторических концепций криптографии.
  - Погрузиться в теорию чисел, группы и поля для освоения ключевых математических концепций, лежащих в основе криптографии.
  - Изучить потоковый шифр RC4 и AES с 128-битным ключом для изучения симметричных криптографических алгоритмов.
  - Исследовать криптосистему RSA, распределение ключей и хеш-функции для изучения асимметричной криптографии.

---
# Глубокое погружение в криптографию

Трудно найти много материалов, которые предлагали бы хорошее среднее положение в образовании по криптографии.

С одной стороны, есть длинные, формальные трактаты, доступные действительно только тем, у кого есть крепкий фон в математике, логике или какой-либо другой формальной дисциплине. С другой стороны, есть очень общие введения, которые действительно скрывают слишком много деталей для тех, кто хотя бы немного любопытен.

Это введение в криптографию стремится захватить среднее положение. Хотя оно должно быть относительно сложным и детализированным для кого-то, кто новичок в криптографии, это не кроличья нора типичного основополагающего трактата.

+++

# Введение в криптографию
<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## Краткое описание
<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

Эта книга предлагает глубокое погружение в науку и практику криптографии. Где это возможно, она сосредотачивается на концептуальном, а не формальном изложении материала.

> Этот курс основан на [репозитории JWBurgers](https://github.com/JWBurgers/An_Introduction_to_Cryptography). Все права принадлежат ему. Контент еще не завершен и здесь только для демонстрации того, как мы могли бы интегрировать его, если JWBurgers согласится.

### Мотивация и цели

Трудно найти много материалов, которые предлагали бы хорошее среднее положение в образовании по криптографии.

С одной стороны, есть длинные, формальные трактаты, доступные действительно только тем, у кого есть крепкий фон в математике, логике или какой-либо другой формальной дисциплине. С другой стороны, есть очень общие введения, которые действительно скрывают слишком много деталей для тех, кто хотя бы немного любопытен.

Это введение в криптографию стремится захватить среднее положение. Хотя оно должно быть относительно сложным и детализированным для кого-то, кто новичок в криптографии, это не кроличья нора типичного основополагающего трактата.

### Целевая аудитория

От разработчиков до интеллектуально любознательных, эта книга будет полезна всем, кто хочет более чем поверхностного понимания криптографии. Если ваша цель - овладеть областью криптографии, то эта книга также является хорошей отправной точкой.

### Рекомендации к чтению

На данный момент книга содержит семь глав: "Что такое криптография?" (Глава 1), "Математические основы криптографии I" (Глава 2), "Математические основы криптографии II" (Глава 3), "Симметричная криптография" (Глава 4), "RC4 и AES" (Глава 5), "Асимметричная криптография" (Глава 6) и "Криптосистема RSA" (Глава 7). Финальная глава, "Криптография на практике", еще будет добавлена. Она сосредоточена на различных криптографических приложениях, включая безопасность транспортного уровня, маршрутизацию через луковицу и систему обмена значениями Bitcoin.
Если у вас нет крепкой базы в математике, теория чисел, вероятно, является самой сложной темой в этой книге. Я предлагаю обзор этой темы в Главе 3, а также она встречается в изложении AES в Главе 5 и криптосистемы RSA в Главе 7.
Если вы действительно испытываете трудности с формальными деталями этих частей книги, я рекомендую вам для начала ограничиться высокоуровневым чтением.

### Благодарности

Наиболее влиятельной книгой, сформировавшей эту, была _Введение в современную криптографию_ Джонатана Каца и Йехуды Линделла, CRC Press (Бока-Ратон, Флорида), 2015. Сопутствующий курс доступен на Coursera под названием "Криптография".

Основные дополнительные источники, которые помогли создать обзор в этой книге, это Саймон Сингх, _Кодовая книга_, Fourth Estate (Лондон, 1999); Кристоф Паар и Ян Пельцль, _Понимание криптографии_, Springer (Гейдельберг, 2010) и курс, основанный на книге Паара под названием "Введение в криптографию" (доступен на https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg); и Брюс Шнайер, Прикладная криптография, 2-е издание, 2015 (Индианаполис, Индиана: John Wiley & Sons).

Я буду цитировать только очень конкретную информацию и результаты, которые я беру из этих источников, но хочу здесь признать мою общую благодарность им.

Тем читателям, которые после этого введения желают углубить свои знания в криптографии, я настоятельно рекомендую книгу Каца и Линделла. Курс Каца на Coursera является несколько более доступным, чем книга.

### Вклад

Пожалуйста, ознакомьтесь с файлом вклада в репозитории для получения некоторых рекомендаций о том, как поддержать проект.

# Что такое криптография?
<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

Давайте начнем наше исследование в области криптографии с одного из более очаровательных и развлекательных эпизодов в ее истории: истории шифров Бейла.<sup>[1](#footnote1)</sup>

На мой взгляд, история шифров Бейла скорее вымысел, чем реальность. Но, предположительно, все произошло следующим образом.

## Шифры Бейла
<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

Зимой 1820 и 1822 годов мужчина по имени Томас Дж. Бейл останавливался в гостинице, принадлежащей Роберту Моррису в Линчбурге (Вирджиния). В конце второго визита Бейла он передал Моррису железный ящик с ценными бумагами для хранения.

Через несколько месяцев Моррис получил письмо от Бейла, датированное 9 мая 1822 года. В нем подчеркивалась большая ценность содержимого железного ящика и излагались некоторые инструкции Моррису: если ни Бейл, ни кто-либо из его ассоциатов никогда не придут за ящиком, он должен открыть его ровно через десять лет с даты письма (то есть 9 мая 1832 года). Некоторые из бумаг внутри будут написаны обычным текстом. Несколько других, однако, будут «непонятны без помощи ключа». Этот «ключ», тогда, должен был быть доставлен Моррису неизвестным другом Бейла в июне 1832 года.
Несмотря на четкие инструкции, Моррис не открыл ящик в мае 1832 года, а загадочный друг Бейла так и не появился в июне того же года. Только в 1845 году хозяин таверны наконец решился открыть ящик. В нем Моррис нашел записку, объясняющую, как Бейл и его товарищи нашли золото и серебро на Западе и закопали его вместе с некоторыми ювелирными изделиями для сохранности. Кроме того, в ящике содержались три **шифротекста**: то есть тексты, написанные кодом, которые требуют **криптографического ключа**, или секрета, и сопутствующего алгоритма для их расшифровки. Этот процесс расшифровки шифротекста известен как **дешифрование**, в то время как процесс шифрования известен как **шифрование**. (Как объясняется в главе 3, термин шифр может иметь различные значения. В названии "шифры Бейла" он означает шифротексты.)
Три шифротекста, которые Моррис нашел в железном ящике, каждый состоят из серии чисел, разделенных запятыми. Согласно записке Бейла, эти шифротексты отдельно указывают местоположение сокровища, содержание сокровища и список имен с законными наследниками сокровища и их долями (последняя информация актуальна в случае, если Бейл и его товарищи так и не придут за ящиком).

Моррис пытался расшифровать три шифротекста в течение двадцати лет. Это было бы легко с ключом. Но у Морриса не было ключа, и ему не удалось восстановить оригинальные тексты, или **открытые тексты**, как они обычно называются в криптографии.

Приближаясь к концу своей жизни, Моррис передал ящик другу в 1862 году. Этот друг впоследствии опубликовал брошюру в 1885 году под псевдонимом Дж.Б. Уорд. В ней содержалось описание (предполагаемой) истории ящика, трех шифротекстов и решение, которое он нашел для второго шифротекста. (По-видимому, существует один ключ для каждого шифротекста, а не один ключ, который работает на все три шифротекста, как изначально, кажется, предполагал Бейл в своем письме Моррису.)

Вы можете увидеть второй шифротекст на *Рисунке 2* ниже.<sup>[2](#footnote2)</sup> Ключ к этому шифротексту - Декларация независимости Соединенных Штатов. Процедура дешифрования сводится к применению следующих двух правил:

* Для любого числа n в шифротексте найдите n-е слово в Декларации независимости Соединенных Штатов
* Замените число n первой буквой найденного вами слова

*Рисунок 1: Шифр Бейла № 2*

![Рисунок 1: Шифр Бейла № 2](assets/Figure1-1.webp "Рисунок 1: Шифр Бейла № 2")

Например, первое число второго шифротекста - 115. 115-е слово Декларации независимости - “instituted,” так что первая буква открытого текста - “i.” Шифротекст напрямую не указывает на разделение слов и использование заглавных букв. Но после дешифрования первых нескольких слов можно логически предположить, что первое слово открытого текста было просто “I.” (Открытый текст начинается с фразы “I have deposited in the county of Bedford.”)
После расшифровки второе сообщение предоставляет подробное содержание сокровища (золото, серебро и драгоценности) и предполагает, что оно было закопано в железных горшках и покрыто камнями в округе Бедфорд (Вирджиния). Людям нравятся хорошие тайны, поэтому были приложены большие усилия для расшифровки двух других шифров Бейла, особенно того, который описывает местоположение сокровища. Даже различные выдающиеся криптографы пытались их расшифровать. Однако, пока никому не удалось расшифровать два других шифротекста.

## Современная криптография
<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

Яркие истории, такие как шифры Бейла, это то, с чем большинство из нас ассоциирует криптографию. Тем не менее, современная криптография отличается по крайней мере в четырех важных аспектах от таких исторических примеров.

Во-первых, исторически криптография занималась только **секретностью** (или конфиденциальностью).<sup>[3](#footnote3)</sup> Шифротексты создавались для того, чтобы только определенные стороны могли быть посвящены в информацию в исходных текстах, как в случае с шифрами Бейла. Чтобы схема шифрования хорошо служила этой цели, расшифровка шифротекста должна быть возможна только если у вас есть ключ.

Современная криптография занимается более широким кругом тем, чем просто секретность. Эти темы включают в первую очередь (1) **целостность сообщения** — то есть, уверенность в том, что сообщение не было изменено; (2) **подлинность сообщения** — то есть, уверенность в том, что сообщение действительно было отправлено конкретным отправителем; и (3) **невозможность отказа** — то есть, уверенность в том, что отправитель не сможет позже ложно отрицать, что он отправил сообщение.<sup>[4](#footnote4)</sup>

Важное различие, которое следует иметь в виду, так это между **схемой шифрования** и **криптографической схемой**. Схема шифрования занимается только секретностью. Хотя схема шифрования является криптографической схемой, обратное не верно. Криптографическая схема также может служить другим основным темам криптографии, включая целостность, подлинность и невозможность отказа.

Темы целостности и подлинности так же важны, как секретность. Наши современные системы связи не смогли бы функционировать без гарантий относительно целостности и подлинности коммуникаций. Невозможность отказа также является важной проблемой, например, для цифровых контрактов, но нуждается в криптографических приложениях менее универсально, чем секретность, целостность и подлинность.

Во-вторых, классические схемы шифрования, такие как шифры Бейла, всегда включали один ключ, который делили между всеми заинтересованными сторонами. Однако, многие современные криптографические схемы включают не один, а два ключа: **личный** и **публичный ключ**. Первый должен оставаться приватным в любых приложениях, в то время как последний обычно является общедоступным (отсюда и их названия). В области шифрования публичный ключ может быть использован для шифрования сообщения, в то время как личный ключ может быть использован для расшифровки.

Отрасль криптографии, которая занимается схемами, где все стороны делят один ключ, известна как **симметричная криптография**. Единственный ключ в такой схеме обычно называется **личным ключом** (или секретным ключом). Отрасль криптографии, которая занимается схемами, требующими пары личного и публичного ключа, известна как **асимметричная криптография**. Эти отрасли иногда также называют **криптографией с закрытым ключом** и **криптографией с открытым ключом** соответственно (хотя это может вызвать путаницу, поскольку схемы криптографии с открытым ключом также имеют закрытые ключи).
Появление асимметричной криптографии в конце 1970-х годов стало одним из самых важных событий в истории криптографии. Без неё большинство наших современных систем коммуникации, включая Bitcoin, были бы невозможны или, по крайней мере, очень неудобны в использовании.

Важно, что современная криптография не ограничивается исключительно изучением симметричных и асимметричных криптографических схем (хотя это и составляет большую часть области). Например, криптография также занимается хеш-функциями и генераторами псевдослучайных чисел, и на этих примитивах можно строить приложения, не связанные с симметричной или асимметричной криптографией.

В-третьих, классические схемы шифрования, такие как использованные в шифрах Била, были скорее искусством, чем наукой. Их предполагаемая безопасность во многом основывалась на интуиции относительно их сложности. Обычно их модифицировали, когда узнавали о новой атаке, или полностью отказывались от них, если атака была особенно серьёзной. Современная криптография, однако, является строгой наукой с формальным, математическим подходом к разработке и анализу криптографических схем.

В частности, современная криптография сосредоточена на формальных **доказательствах безопасности**. Любое доказательство безопасности криптографической схемы состоит из трёх шагов:

1.	Формулировка **криптографического определения безопасности**, то есть набора целей безопасности и угрозы, исходящей от атакующего.
2.	Формулировка любых математических предположений относительно вычислительной сложности схемы. Например, криптографическая схема может содержать генератор псевдослучайных чисел. Хотя мы не можем доказать их существование, мы можем предполагать, что они существуют.
3.	Изложение математического **доказательства безопасности** схемы на основе формального понятия безопасности и любых математических предположений.

В-четвёртых, в то время как исторически криптография в основном использовалась в военных целях, она стала проникать в наши повседневные дела в цифровую эпоху. Будь то онлайн-банкинг, публикации в социальных сетях, покупка товара на Amazon с вашей кредитной картой или отправка чаевых в биткоинах, криптография является sine qua non нашей цифровой эпохи.

Учитывая эти четыре аспекта современной криптографии, мы могли бы охарактеризовать современную **криптографию** как науку, занимающуюся формальной разработкой и анализом криптографических схем для защиты цифровой информации от враждебных атак. Здесь безопасность следует понимать в широком смысле как предотвращение атак, угрожающих секретности, целостности, аутентификации и/или невозможности отказа в коммуникациях.

Криптографию лучше всего рассматривать как поддисциплину **кибербезопасности**, которая занимается предотвращением кражи, повреждения и неправомерного использования компьютерных систем. Стоит отметить, что многие вопросы кибербезопасности имеют мало или только частичное отношение к криптографии.

Например, если компания размещает дорогостоящие серверы локально, её может волновать защита этого оборудования от кражи и повреждения. Хотя это и является вопросом кибербезопасности, это мало связано с криптографией.

Для другого примера, **фишинговые атаки** являются общей проблемой в наше время. Эти атаки пытаются обмануть людей через электронное письмо или какой-либо другой мессенджер, чтобы они раскрыли конфиденциальную информацию, такую как пароли или номера кредитных карт. Хотя криптография может помочь решить проблему фишинговых атак до определённой степени, комплексный подход требует большего, чем просто использование криптографии.

## Открытые коммуникации

Современная криптография разработана для обеспечения гарантий безопасности в среде **открытых коммуникаций**. Если наш канал связи настолько хорошо защищён, что подслушивающие лица не имеют никакой возможности манипулировать или даже просто наблюдать за нашими сообщениями, тогда криптография становится излишней. Однако большинство наших каналов связи далеко не так хорошо защищены.
Основой коммуникации в современном мире является огромная сеть волоконно-оптических кабелей. Совершение телефонных звонков, просмотр телевизора и серфинг в интернете в современном домохозяйстве в основном зависят от этой сети волоконно-оптических кабелей (небольшой процент может полагаться исключительно на спутники). Действительно, у вас могут быть различные типы данных подключений в вашем доме, такие как коаксиальный кабель, (асимметричная) цифровая абонентская линия и волоконно-оптический кабель. Но, по крайней мере, в развитом мире, эти различные средства передачи данных быстро соединяются за пределами вашего дома с узлом в огромной сети волоконно-оптических кабелей, которая соединяет весь земной шар. Исключения составляют некоторые отдаленные районы развитого мира, такие как в Соединенных Штатах и Австралии, где трафик данных может все еще проходить на значительные расстояния по традиционным медным телефонным проводам.

Было бы невозможно предотвратить физический доступ потенциальных атакующих к этой сети кабелей и ее поддерживающей инфраструктуре. Фактически, мы уже знаем, что большая часть наших данных перехватывается различными национальными разведывательными агентствами на критически важных перекрестках Интернета. Это включает в себя все, от сообщений в Facebook до адресов веб-сайтов, которые вы посещаете.

Хотя наблюдение за данными в больших масштабах требует мощного противника, такого как национальное разведывательное агентство, атакующие с ограниченными ресурсами могут легко попытаться подслушать на более локальном уровне. Хотя это может происходить на уровне подключения к проводам, гораздо проще просто перехватить беспроводную связь.

Большая часть наших локальных сетевых данных — будь то в наших домах, в офисе или в кафе — теперь передается по радиоволнам к точкам беспроводного доступа на маршрутизаторах все-в-одном, а не через физические кабели. Таким образом, атакующему требуется мало ресурсов для перехвата любого вашего локального трафика. Это особенно тревожно, поскольку большинство людей очень мало делают для защиты данных, которые передаются через их локальные сети. Кроме того, потенциальные атакующие также могут нацеливаться на наши мобильные широкополосные соединения, такие как 3G, 4G и 5G. Все эти беспроводные коммуникации являются легкой целью для атакующих.

Следовательно, идея сохранения секретности коммуникаций путем защиты канала связи является безнадежно иллюзорной стремлением для большей части современного мира. Все, что мы знаем, требует серьезного паранойи: вы всегда должны предполагать, что кто-то слушает. И криптография является основным инструментом, который у нас есть для обеспечения какой-либо безопасности в этой современной среде.

### Примечания
[^1]: Для хорошего резюме истории см. Саймон Сингх, *Книга шифров*, Fourth Estate (Лондон, 1999), стр. 82-99. Короткий фильм об этой истории был сделан Эндрю Алленом в 2010 году. Вы можете найти фильм, "Шифр Томаса Била", на его веб-сайте [^1].

[^2]: Это изображение доступно на странице Википедии для шифров Била [^2].

[^3]: Быть точным, важные применения криптографических схем были связаны с секретностью. Дети, например, часто используют простые криптографические схемы для "веселья". Секретность в этих случаях действительно не является проблемой [^3].

[^4]: Брюс Шнайер, *Прикладная криптография*, 2-е изд., 2015 (Индианаполис, IN: John Wiley & Sons), стр. 2 [^4].

[^5]: См. Джонатан Кац и Йехуда Линделл, *Введение в современную криптографию*, CRC Press (Бока-Ратон, FL: 2015), особенно стр. 16–23, для хорошего описания [^5].

[^6]: Ср. Кац и Линделл, там же, стр. 3. Я думаю, что их характеристика имеет некоторые проблемы, поэтому представляю здесь немного другую версию их утверждения [^6].
[^7]: См., например, Ольга Хазан, "Жуткая, давняя практика подслушивания подводных кабелей", *The Atlantic*, 16 июля 2013 года (доступно на [The Atlantic](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/)) [^7].

# Математические основы криптографии I
<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

Криптография опирается на математику. И если вы хотите иметь более чем поверхностное понимание криптографии, вам нужно быть уверенным в этой математике.

В этой главе представлены основные математические понятия, с которыми вы столкнетесь, изучая криптографию. Темы включают случайные переменные, операции по модулю, операции XOR и псевдослучайность. Вы должны освоить материал в этих разделах для любого не поверхностного понимания криптографии.

Следующая глава посвящена теории чисел, которая намного сложнее.

## Случайные переменные
<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

Случайная переменная обычно обозначается не жирным, прописным буквой. Так, например, мы можем говорить о случайной переменной X, случайной переменной Y или случайной переменной Z. Это обозначение я также буду использовать в дальнейшем.

**Случайная переменная** может принимать два или более возможных значения, каждое с определенной положительной вероятностью. Возможные значения перечислены в **наборе исходов**.

Каждый раз, когда вы **выбираете** случайную переменную, вы извлекаете определенное значение из ее набора исходов в соответствии с определенными вероятностями.

Давайте рассмотрим простой пример. Предположим, переменная X определена следующим образом:

* X имеет набор исходов {1,2}
* Pr [X = 1] = 0.5
* Pr [X = 2] = 0.5

Легко видеть, что X является случайной переменной. Во-первых, есть два или более возможных значения, которые X может принять, а именно 1 и 2. Во-вторых, каждое возможное значение имеет положительную вероятность возникновения при выборке X, а именно 0.5.

Все, что требуется от случайной переменной, - это набор исходов с двумя или более возможностями, где каждая возможность имеет положительную вероятность возникновения при выборке. В принципе, тогда случайная переменная может быть определена абстрактно, без какого-либо контекста. В этом случае вы можете думать о «выборке» как о проведении некоторого естественного эксперимента для определения значения случайной переменной.

Переменная X выше была определена абстрактно. Таким образом, вы можете думать о выборке переменной X, как о подбрасывании честной монеты и присвоении «2» в случае орла и «1» в случае решки. При каждой выборке X вы подбрасываете монету снова.

Альтернативно, вы также можете думать о выборке X, как о броске честной кости и присвоении «2» в случае, если кость покажет 1, 3 или 4, и присвоении «1» в случае, если кость покажет 2, 5 или 6. Каждый раз, когда вы выбираете X, вы бросаете кость снова.

На самом деле, любой естественный эксперимент, который позволил бы вам определить вероятности возможных значений X выше, можно представить относительно выборки.
Часто случайные переменные вводятся не абстрактно. Вместо этого, набор возможных значений исходов имеет явное практическое значение (а не просто как числа). Кроме того, эти значения исходов могут быть определены в контексте какого-то конкретного эксперимента (а не любого естественного эксперимента с этими значениями).
Рассмотрим теперь пример переменной X, которая не определена абстрактно. X определена следующим образом, чтобы определить, какая из двух команд начинает футбольный матч:

* У X есть набор исходов {красные начинают, синие начинают}
* Подбрасывается конкретная монета C: решка = "красные начинают"; орел = "синие начинают"
* Pr [X = красные начинают] = 0.5
* Pr [X = синие начинают] = 0.5

В этом случае набор исходов X предоставлен с конкретным значением, а именно, какая команда начинает в футбольном матче. Кроме того, возможные исходы и их вероятности определены конкретным экспериментом, а именно подбрасыванием конкретной монеты C.

В дискуссиях о криптографии случайные переменные обычно вводятся в контексте набора исходов с практическим значением. Это может быть набор всех сообщений, которые могут быть зашифрованы, известный как пространство сообщений, или набор всех ключей, которые стороны, использующие шифрование, могут выбрать, известный как пространство ключей.

Однако, в дискуссиях о криптографии случайные переменные обычно не определяются в контексте какого-то конкретного естественного эксперимента, а против любого эксперимента, который может дать правильные распределения вероятностей.

Случайные переменные могут иметь дискретные или непрерывные распределения вероятностей. Случайные переменные с **дискретным распределением вероятностей** — то есть дискретные случайные переменные — имеют конечное число возможных исходов. Случайная переменная X в обоих приведенных до сих пор примерах была дискретной.

**Непрерывные случайные переменные** могут принимать значения в одном или нескольких интервалах. Можно сказать, например, что случайная переменная при выборке примет любое действительное значение между 0 и 1, и что каждое действительное число в этом интервале равновероятно. В этом интервале существует бесконечное количество возможных значений.

Для дискуссий о криптографии вам нужно будет понимать только дискретные случайные переменные. Любое обсуждение случайных переменных отсюда и далее следует понимать как относящееся к дискретным случайным переменным, если не указано иное.


### Графическое представление случайных переменных

Возможные значения и связанные с ними вероятности для случайной переменной можно легко визуализировать с помощью графика. Например, рассмотрим случайную переменную X из предыдущего раздела с набором исходов {1,2}, и Pr [X = 1] = 0.5 и Pr [X = 2] = 0.5. Такую случайную переменную мы обычно отображаем в виде столбчатой диаграммы, как на *Рисунке 1*.

*Рисунок 1: Случайная переменная X*

![Рисунок 1: Случайная переменная X.](assets/Figure2-1.webp)

Широкие столбцы на *Рисунке 1* очевидно не предполагают, что случайная переменная X на самом деле непрерывна. Вместо этого столбцы сделаны широкими, чтобы быть более визуально привлекательными (просто линия вверх обеспечивает менее интуитивную визуализацию).


### Равномерные переменные

В выражении "случайная переменная" термин "случайная" просто означает "вероятностная". Другими словами, это просто означает, что два или более возможных исхода переменной происходят с определенными вероятностями. Однако эти исходы *не обязательно* должны быть равновероятными (хотя термин "случайная" действительно может иметь такое значение в других контекстах).
**Равномерная переменная** является особым случаем случайной переменной. Она может принимать два или более значений, все с равной вероятностью. Случайная переменная X, изображенная на *Рисунке 1*, явно является равномерной переменной, так как оба возможных исхода происходят с вероятностью 0,5. Однако существует множество случайных переменных, которые не являются примерами равномерных переменных.
Рассмотрим, например, случайную переменную Y. У нее есть набор исходов {1,2,3,8,10} и следующее распределение вероятностей: Pr [Y = 1] = 0,25; Pr [Y = 2] = 0,35; Pr [Y = 3] = 0,1; Pr [Y = 8] = 0,25; Pr [Y = 10] = 0,05.

Хотя два возможных исхода действительно имеют равную вероятность наступления, а именно 1 и 8, Y также может принимать определенные значения с другими вероятностями, отличными от 0,25 при выборке. Следовательно, хотя Y действительно является случайной переменной, она не является равномерной переменной.

Графическое изображение Y представлено на *Рисунке 2*.

*Рисунок 2: Случайная переменная Y*

![Рисунок 2: Случайная переменная Y.](assets/Figure2-2.webp "Рисунок 2: Случайная переменная Y")

В качестве последнего примера рассмотрим случайную переменную Z. У нее есть набор исходов {1,3,7,11,12} и следующее распределение вероятностей: Pr (2) = 0,2; Pr (3) = 0,2; Pr (9) = 0,2; Pr (11) = 0,2; Pr (12) = 0,2. Вы можете увидеть ее изображение на Рисунке 3. В отличие от Y, случайная переменная Z действительно является равномерной переменной, так как все вероятности для возможных значений при выборке равны.

*Рисунок 3: Случайная переменная Z*

![Рисунок 3: Случайная переменная Z.](assets/Figure2-3.webp "Рисунок 3: Случайная переменная Z")


### Условная вероятность

Предположим, что Боб намерен равномерно выбрать день из последнего календарного года. Какова вероятность того, что выбранный день будет летом?

До тех пор, пока мы думаем, что процесс Боба действительно будет действительно равномерным, мы должны прийти к выводу, что вероятность выбора Бобом дня летом составляет 1/4. Это **безусловная вероятность** случайно выбранного дня быть летом.

Предположим теперь, что вместо равномерного выбора календарного дня Боб выбирает равномерно только из тех дней, когда температура в полдень у Кристал Лейк (Нью-Джерси) была 21 градус Цельсия или выше. Исходя из этой дополнительной информации, к какому выводу мы можем прийти о вероятности того, что Боб выберет день летом?

Мы действительно должны прийти к другому выводу, чем раньше, даже без какой-либо дополнительной конкретной информации (например, температуры в полдень каждый день в прошлом календарном году).

Зная, что Кристал Лейк находится в Нью-Джерси, мы определенно не ожидаем, что температура в полдень будет 21 градус Цельсия или выше зимой. Вместо этого гораздо вероятнее, что это будет теплый день весной или осенью, или день где-то летом. Следовательно, зная, что температура в полдень у Кристал Лейк в выбранный день была 21 градус Цельсия или выше, вероятность того, что выбранный Бобом день будет летом, становится гораздо выше. Это **условная вероятность** случайно выбранного дня быть летом, учитывая, что температура в полдень у Кристал Лейк была 21 градус Цельсия или выше.
В отличие от предыдущего примера, вероятности двух событий также могут быть полностью независимыми. В этом случае мы говорим, что они **независимы**.

Предположим, например, что определенная честная монета упала орлом вверх. Исходя из этого факта, какова же вероятность того, что завтра пойдет дождь? Условная вероятность в данном случае должна быть такой же, как и безусловная вероятность того, что завтра пойдет дождь, поскольку бросок монеты, как правило, не оказывает никакого влияния на погоду.

Мы используем символ “|” для записи выражений условной вероятности. Например, вероятность события A при условии, что событие B произошло, можно записать следующим образом: Pr[A|B]. Таким образом, когда два события, A и B, независимы, тогда Pr[A|B] = Pr[A] и Pr[B|A] = Pr[B]. Условие независимости можно упростить следующим образом: Pr[A,B] = Pr[A]*Pr[B].

Одним из ключевых результатов в теории вероятностей является **Теорема Байеса**. Она в основном утверждает, что Pr[A|B] можно переписать следующим образом:

Pr[A|B] = (Pr[B|A] • Pr[A]) / Pr[B]

Вместо использования условных вероятностей с конкретными событиями, мы также можем рассматривать условные вероятности, связанные с двумя или более случайными переменными на наборе возможных событий. Предположим, есть две случайные переменные, X и Y. Любое возможное значение для X мы можем обозначить как x, а любое возможное значение для Y как y. Мы могли бы сказать, тогда, что две случайные переменные независимы, если выполняется следующее утверждение:

Pr[X = x,Y = y] = Pr[X = x] • Pr[Y = y] для всех x и y

Давайте немного подробнее рассмотрим, что означает это утверждение.

Предположим, что наборы исходов для X и Y определены следующим образом: **X** = {x<sub>1</sub>,x<sub>2</sub>….,x<sub>i</sub>,….x<sub>n</sub>} и **Y** = {y<sub>1</sub>,y<sub>2</sub>….,y<sub>i</sub>,….y<sub>m</sub>}. (Обычно наборы значений обозначаются жирным шрифтом, заглавными буквами.)

Теперь предположим, вы выбрали Y и наблюдаете y<sub>1</sub>. Утверждение выше говорит нам, что вероятность теперь получить x<sub>1</sub> из выборки X точно такая же, как если бы мы никогда не наблюдали y<sub>1</sub>. Это верно для любого y<sub>i</sub>, который мы могли бы извлечь из нашей первоначальной выборки Y. Наконец, это справедливо не только для x<sub>1</sub>. Для любого x<sub>i</sub> вероятность наступления не зависит от результата выборки Y. Все это также применимо в случае, если сначала была выбрана X.

Закончим наш разговор немного более философской точкой. В любой реальной ситуации вероятность какого-либо события всегда оценивается на основе конкретного набора информации. В очень строгом смысле слова "безусловной вероятности" не существует.

Например, предположим, я спросил вас о вероятности того, что к 2030 году свиньи научатся летать. Хотя я не даю вам дополнительной информации, вы явно знаете много о мире, что может повлиять на ваше суждение. Вы никогда не видели летающих свиней. Вы знаете, что большинство людей не ожидают, что они будут летать. Вы знаете, что они не совсем созданы для полета. И так далее.
Следовательно, когда мы говорим о "безусловной вероятности" какого-либо события в реальном контексте, этот термин действительно может иметь смысл только если мы понимаем его как "вероятность без какой-либо дополнительной явной информации". Любое понимание "условной вероятности" должно, таким образом, всегда рассматриваться на фоне какой-то конкретной информации.
Например, я мог бы спросить вас о вероятности того, что свиньи научатся летать к 2030 году, после того как предоставил вам доказательства того, что некоторые козы в Новой Зеландии научились летать после нескольких лет тренировок. В этом случае вы, вероятно, скорректируете свое мнение о вероятности того, что свиньи научатся летать к 2030 году. Таким образом, вероятность того, что свиньи научатся летать к 2030 году, зависит от этого доказательства о козах в Новой Зеландии.

## Операция модуля
<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

Самое основное выражение с **операцией модуля** имеет следующий вид: x mod y.

Переменная x называется делимым, а переменная y - делителем. Чтобы выполнить операцию модуля с положительным делимым и положительным делителем, вы просто определяете остаток от деления.

Например, рассмотрим выражение 25 mod 4. Число 4 укладывается в число 25 в общей сложности 6 раз. Остаток от этого деления равен 1. Следовательно, 25 mod 4 равно 1. Аналогичным образом мы можем оценить нижеприведенные выражения:

* 29 mod 30 = 29 (так как 30 укладывается в 29 в общей сложности 0 раз, и остаток равен 29)
* 42 mod 2 = 0 (так как 2 укладывается в 42 в общей сложности 21 раз, и остаток равен 0)
* 12 mod 5 = 2 (так как 5 укладывается в 12 в общей сложности 2 раза, и остаток равен 2)
* 20 mod 8 = 4 (так как 8 укладывается в 20 в общей сложности 2 раза, и остаток равен 4)

Когда делимое или делитель отрицательные, операции модуля могут обрабатываться различными языками программирования по-разному.

Вы определенно столкнетесь с случаями с отрицательным делимым в криптографии. В этих случаях типичный подход следующий:

* Сначала определите ближайшее значение *меньшее или равное* делимому, на которое делитель делит без остатка. Назовем это значение p.
* Если делимое равно x, то результат операции модуля равен значению x – p.

Например, предположим, что делимое равно –20, а делитель 3. Ближайшее значение, меньшее или равное –20, на которое 3 делит без остатка, равно –21. Значение x – p в этом случае равно –20 – (–21). Это равно 1 и, следовательно, –20 mod 3 равно 1. Аналогичным образом мы можем оценить нижеприведенные выражения:

* –8 mod 5 = 2
* –19 mod 16 = 13
* –14 mod 6 = 4

Что касается обозначения, вы обычно увидите следующие типы выражений: x = [y mod z]. Из-за скобок операция модуля в этом случае применяется только к правой части выражения. Если y равно 25, а z равно 4, например, то x равно 1.
Без скобок операция модуля действует на *обе стороны* выражения. Предположим, например, следующее выражение: x = y mod z. Если y равно 25, а z равно 4, то все, что мы знаем, это то, что x mod 4 равно 1. Это соответствует любому значению x из множества {….– 7, – 3, 1, 5, 9….}.
Отрасль математики, которая включает операции модуля над числами и выражениями, называется **модульной арифметикой**. Можно думать об этой отрасли как об арифметике для случаев, когда числовая линия не бесконечно длинная. Хотя мы обычно сталкиваемся с операциями модуля для (положительных) целых чисел в криптографии, вы также можете выполнять операции модуля с любыми действительными числами.

### Шифр сдвига

Операция модуля часто встречается в криптографии. Для иллюстрации рассмотрим одну из самых известных исторических схем шифрования: шифр сдвига.

Давайте сначала определим его. Предположим словарь *D*, который соотносит все буквы английского алфавита, по порядку, с набором чисел {0,1,2…,25}. Предположим пространство сообщений **M**. **Шифр сдвига** тогда определяется следующим образом:

- Равномерно выберите ключ k из пространства ключей **K**, где **K** = {0,1,2,…,25}<sup>[1](#footnote1)</sup>
- Зашифруйте сообщение m є **M** следующим образом:
    - Разделите m на его отдельные буквы m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>
    - Преобразуйте каждый m<sub>i</sub> в число согласно *D*
    - Для каждого m<sub>i</sub>, c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - Преобразуйте каждый c<sub>i</sub> в букву согласно *D*
    - Затем объедините c<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub>, чтобы получить зашифрованный текст c
- Расшифруйте зашифрованный текст c следующим образом:
    -- Преобразуйте каждый c<sub>i</sub> в число согласно *D*
    -- Для каждого c<sub>i</sub>, m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    -- Преобразуйте каждый m<sub>i</sub> в букву согласно *D*
    -- Затем объедините m<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub>, чтобы получить исходное сообщение m

Оператор модуля в шифре сдвига гарантирует, что буквы зацикливаются, так что все буквы зашифрованного текста определены. Для иллюстрации рассмотрим применение шифра сдвига к слову “DOG”.

Предположим, что вы равномерно выбрали ключ со значением 17. Буква “O” соответствует 15. Без операции модуля сложение этого числа открытого текста с ключом дало бы число зашифрованного текста 32. Однако это число зашифрованного текста не может быть преобразовано в букву зашифрованного текста, поскольку в английском алфавите только 26 букв. Операция модуля гарантирует, что число зашифрованного текста на самом деле равно 6 (результат 32 mod 26), что соответствует букве зашифрованного текста “G”.

Полное шифрование слова “DOG” с ключом значением 17 выглядит следующим образом:
* Сообщение = DOG = D,O,G = 3,15,6* c<sub>0</sub> = [(3 + 17) Mod 26] = [(20) Mod 26] = 20 = U
* c<sub>1</sub> = [(15 + 17) Mod 26] = [(32) Mod 26] = 6 = G
* c<sub>2</sub> = [(6 + 17) Mod 26] = [(23) Mod 26] = 23 = X
* c = UGX

Каждый может интуитивно понять, как работает шифр сдвига, и, вероятно, использовать его самостоятельно. Однако для продвижения в знаниях криптографии важно начать чувствовать себя более уверенно с формализацией, поскольку схемы будут становиться гораздо сложнее. Вот почему шаги для шифра сдвига были формализованы.

## Операция XOR
<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

Все компьютерные данные обрабатываются, хранятся и передаются по сетям на уровне битов. Любые криптографические схемы, применяемые к компьютерным данным, также работают на уровне битов.

Например, предположим, что вы набрали электронное письмо в своем почтовом приложении. Любое шифрование, которое вы применяете, не происходит непосредственно над символами ASCII вашего электронного письма. Вместо этого оно применяется к битовому представлению букв и других символов в вашем электронном письме.

Ключевая математическая операция для понимания современной криптографии, помимо операции модуля, - это операция **XOR**, или операция "исключающее или". Эта операция принимает на вход два бита и выдает на выходе другой бит. Операция XOR будет просто обозначаться как "XOR". Она выдает 0, если два бита одинаковы, и 1, если два бита различны. Ниже вы можете увидеть четыре возможности.

* 0 XOR 0 = 0
* 0 XOR 1 = 1
* 1 XOR 0 = 1
* 1 XOR 1 = 0

Вы можете выполнить операцию XOR над двумя сообщениями, длиннее одного бита, выстроив биты этих двух сообщений в ряд и выполнив операцию XOR для каждой отдельной пары битов.

Для иллюстрации предположим, что у вас есть сообщение m<sub>1</sub> (01111001) и сообщение m<sub>2</sub> (01011001). Операция XOR этих двух сообщений может быть показана ниже.

* m<sub>1</sub> XOR m<sub>2</sub> = 01111001 XOR 01011001 = 00100000

Процесс прост. Сначала вы выполняете операцию XOR для крайних левых битов m<sub>1</sub> и m<sub>2</sub>. В данном случае это 0 XOR 0 = 0. Затем вы выполняете операцию XOR для второй пары битов слева. В данном случае это 1 XOR 1 = 0. Вы продолжаете этот процесс, пока не выполните операцию XOR для крайних правых битов.
Легко увидеть, что операция XOR является коммутативной, а именно m<sub>1</sub> XOR m<sub>2</sub> = m<sub>2</sub> XOR m<sub>1</sub>. Кроме того, операция XOR также ассоциативна. То есть, (m<sub>1</sub> XOR m<sub>2</sub>) XOR m<sub>3</sub> = m<sub>1</sub> XOR (m<sub>2</sub> XOR m<sub>3</sub>).
Операция XOR над двумя строками различной длины может иметь различные трактовки в зависимости от контекста. Здесь мы не будем заниматься операциями XOR над строками разной длины.

Операция XOR эквивалентна специальному случаю выполнения операции модуля над суммой битов, когда делитель равен 2. Эквивалентность можно увидеть в следующих результатах:

* (0 + 0) mod 2 = 0 XOR 0 = 0
* (1 + 0) mod 2 = 1 XOR 0 = 1
* (0 + 1) mod 2 = 0 XOR 1 = 1
* (1 + 1) mod 2 = 1 XOR 1 = 0

## Псевдослучайность
<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

В нашем обсуждении случайных и равномерных переменных мы провели конкретное различие между "случайным" и "равномерным". Это различие обычно сохраняется на практике при описании случайных переменных. Однако, в нашем текущем контексте, это различие нужно отбросить, и "случайный" и "равномерный" используются как синонимы. Я объясню почему в конце раздела.

Для начала, мы можем назвать двоичную строку длиной n **случайной** (или **равномерной**), если она была результатом выборки равномерной переменной S, которая дает каждой двоичной строке такой длины n равную вероятность выбора.

Предположим, например, набор всех двоичных строк длиной 8: {0000 0000,0000 0001,….,1111 1111}. (Обычно 8-битную строку записывают в два квартета, каждый из которых называется **нимбл**.) Назовем этот набор строк **S<sub>8</sub>**.

Согласно приведенному выше определению, мы можем, следовательно, назвать конкретную двоичную строку длиной 8 случайной (или равномерной), если она была результатом выборки равномерной переменной S, которая дает каждой строке в **S<sub>8</sub>** равную вероятность выбора. Учитывая, что набор **S<sub>8</sub>** включает 2<sup>8</sup> элементов, вероятность выбора при выборке должна быть 1/2<sup>8</sup> для каждой строки в наборе.

Ключевым аспектом случайности двоичной строки является то, что она определяется с учетом процесса, посредством которого она была выбрана. Форма любой конкретной двоичной строки сама по себе ничего не говорит о ее случайности при выборе.

Например, многие люди интуитивно считают, что строка вроде 1111 1111 не могла быть выбрана случайно. Но это явно не так.
Определив равномерную переменную S для всех двоичных строк длиной 8, вероятность выбора 1111 1111 из множества **S<sub>8</sub>** такая же, как и для строки типа 0111 01001. Таким образом, нельзя сказать ничего о случайности строки, просто анализируя саму строку.
Мы также можем говорить о случайных строках, не имея в виду исключительно двоичные строки. Например, мы можем говорить о случайной шестнадцатеричной строке AF 02 82. В этом случае строка была бы выбрана случайно из множества всех шестнадцатеричных строк длиной 6. Это эквивалентно случайному выбору двоичной строки длиной 24, так как каждая шестнадцатеричная цифра представляет 4 бита.

Обычно выражение «случайная строка», без уточнения, относится к строке, случайно выбранной из множества всех строк одинаковой длины. Вот как я это описал выше. Строка длиной n, конечно, также может быть случайно выбрана из другого множества. Например, из множества, которое составляет только подмножество всех строк длиной n, или возможно из множества, которое включает строки различной длины. В этих случаях, однако, мы не называем её «случайной строкой», а скорее «строкой, случайно выбранной из некоторого множества **S**».

Ключевым понятием в криптографии является псевдослучайность. **Псевдослучайная строка** длиной n кажется *как будто* она была результатом выборки равномерной переменной S, которая дает каждой строке в **S<sub>n</sub>** равную вероятность выбора. На самом деле, однако, строка является результатом выборки равномерной переменной S', которая определяет только распределение вероятностей — не обязательно с равными вероятностями для всех возможных исходов — на подмножестве **S<sub>n</sub>**. Ключевой момент здесь в том, что никто на самом деле не может отличить выборки из S и S', даже если вы возьмете их много.

Предположим, например, случайную переменную S. Её множество исходов — **S<sub>256</sub>**, это множество всех двоичных строк длиной 256. Это множество имеет 2<sup>256</sup> элементов. Каждый элемент имеет равную вероятность выбора, 1/2<sup>256</sup>, при выборке.

Кроме того, предположим случайную переменную S’. Её множество исходов включает только 2<sup>128</sup> двоичных строк длиной 256. У неё есть некоторое распределение вероятностей над этими строками, но это распределение не обязательно равномерное.

Предположим, что я теперь взял 1000 выборок из S и 1000 выборок из S' и дал вам два набора исходов. Я скажу вам, какой набор исходов ассоциирован с какой случайной переменной. Затем я возьму выборку из одной из двух случайных переменных. Но на этот раз я не скажу вам, из какой случайной переменной я взял выборку. Если S' была бы псевдослучайной, то идея состоит в том, что ваша вероятность сделать правильный выбор относительно того, из какой случайной переменной я взял выборку, практически не лучше, чем 1/2.

Обычно псевдослучайная строка длиной n производится путем случайного выбора строки размером n – x, где x — положительное целое число, и использования её в качестве входных данных для алгоритма расширения. Эта случайная строка размером n – x известна как **семя**.
Псевдослучайные последовательности являются ключевым понятием для практического применения криптографии. Рассмотрим, например, потоковые шифры. В потоковом шифре случайно выбранный ключ подается на вход алгоритма расширения для создания гораздо более длинной псевдослучайной последовательности. Эта псевдослучайная последовательность затем сочетается с открытым текстом с помощью операции XOR для получения шифртекста.
Если бы мы не могли создавать такого типа псевдослучайные последовательности для потокового шифра, тогда нам бы потребовался ключ, длина которого равна длине сообщения для его безопасности. Это не самый практичный вариант в большинстве случаев.

Понятие псевдослучайности, обсуждаемое в этом разделе, может быть определено более формально. Оно также распространяется на другие контексты. Но нам не нужно углубляться в это обсуждение здесь. Все, что вам действительно нужно интуитивно понять для большей части криптографии, это разница между случайной и псевдослучайной последовательностью.<sup>[2](#footnote2)</sup>

Теперь также должно быть ясно, почему мы отказываемся от различия между "случайным" и "равномерным" в нашем обсуждении. На практике все используют термин псевдослучайный, чтобы указать на последовательность, которая выглядит **как будто** она была результатом выборки из равномерной переменной S. Строго говоря, мы должны называть такую последовательность "псевдо-равномерной", используя наш язык из предыдущего. Поскольку термин "псевдо-равномерный" неудобен и никем не используется, мы не будем вводить его здесь для ясности. Вместо этого мы просто отказываемся от различия между "случайным" и "равномерным" в текущем контексте.

## Примечания
<chapterId>7cccd92c-15bc-5394-9024-af126988ecd7</chapterId>

[^1]: Мы можем точно определить это утверждение, используя терминологию из предыдущего раздела. Пусть равномерная переменная K имеет **K** как набор возможных исходов. Таким образом, Pr [K = 0] = 1/26, Pr [K = 1] = 1/26, и так далее. Выберите равномерную переменную K один раз, чтобы получить конкретный ключ [^1].

[^2]: Если вас интересует более формальное изложение этих вопросов, вы можете обратиться к книге Каца и Линделла *Введение в современную криптографию*, особенно глава 3 [^2].

# Математические основы криптографии II
<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

Эта глава охватывает более продвинутую тему математических основ криптографии: теорию чисел. Хотя теория чисел важна для симметричной криптографии (например, в шифре Риждаля), она особенно важна в контексте криптографии с открытым ключом.

Если вы находите детали теории чисел обременительными, я бы рекомендовал вам в первый раз ознакомиться с ними на высоком уровне. Вы всегда можете вернуться к ним позже.

## Что такое теория чисел?
<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

Теорию чисел можно охарактеризовать как изучение свойств целых чисел и математических функций, работающих с целыми числами.

Рассмотрим, например, что любые два числа a и N являются **взаимно простыми** (или **относительно простыми**), если их наибольший общий делитель равен 1. Предположим теперь определенное целое число N. Сколько целых чисел, меньших N, взаимно просты с N? Можем ли мы сделать общие утверждения относительно ответов на этот вопрос? Это типичные вопросы, на которые стремится ответить теория чисел.
Современная теория чисел опирается на инструменты абстрактной алгебры. Область **абстрактной алгебры** является поддисциплиной математики, где основными объектами анализа являются абстрактные объекты, известные как алгебраические структуры. **Алгебраическая структура** - это набор элементов, объединенных одной или несколькими операциями, которые удовлетворяют определенным аксиомам. Через алгебраические структуры математики могут получать представления о конкретных математических проблемах, абстрагируясь от их деталей.
Область абстрактной алгебры иногда также называется современной алгеброй. Вы также можете столкнуться с понятием **абстрактной математики** (или **чистой математики**). Этот последний термин не относится к абстрактной алгебре, а скорее означает изучение математики ради самой математики, и не только с учетом потенциальных приложений.

Наборы из абстрактной алгебры могут иметь дело с множеством типов объектов, от сохраняющих форму преобразований на равностороннем треугольнике до узоров обоев. Для теории чисел мы рассматриваем только наборы элементов, содержащие целые числа или функции, работающие с целыми числами.

## Группы
<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

Базовое понятие в математике - это понятие набора элементов. Набор обычно обозначается фигурными скобками с элементами, разделенными запятыми.

Например, набор всех целых чисел обозначается как {…,-2,-1,0,1,2,…}. Многоточие здесь означает, что определенный шаблон продолжается в определенном направлении. Таким образом, набор всех целых чисел также включает 3,4,5,6 и так далее, а также -3,-4,-5,-6 и так далее. Этот набор всех целых чисел обычно обозначается как ℤ.

Другой пример набора - это ℤ mod 11, или набор всех целых чисел по модулю 11. В отличие от всего набора ℤ, этот набор содержит только конечное количество элементов, а именно {0,1,…,9,10}.

Распространенная ошибка - думать, что набор ℤ mod 11 на самом деле является {-10,-9,….,0,….,9,10}. Но это не так, учитывая способ, которым мы определили операцию модуля ранее. Любые отрицательные целые числа, уменьшенные по модулю 11, переходят в {0,1,….,9,10}. Например, выражение -2 mod 11 переходит в 9, в то время как выражение -27 mod 11 переходит в 5.

Еще одно базовое понятие в математике - это понятие бинарной операции. Это любая операция, которая принимает два элемента для производства третьего. Например, из базовой арифметики и алгебры вы были бы знакомы с четырьмя основными бинарными операциями: сложение, вычитание, умножение и деление.

Эти два базовых математических понятия, наборы и бинарные операции, используются для определения понятия группы, наиболее существенной структуры в абстрактной алгебре.

В частности, предположим некоторую бинарную операцию ◌. Кроме того, предположим некоторый набор элементов **S**, оснащенный этой операцией. Все, что здесь означает "оснащенный", это то, что операцию ◌ можно выполнять между любыми двумя элементами в наборе **S**.

Тогда комбинация 〈**S**, ◌〉 является **группой**, если она удовлетворяет четырем конкретным условиям, известным как аксиомы группы.

1. Для любых a и b, которые являются элементами **S**, a ◌ b также является элементом **S**. Это известно как **условие замыкания**.
2. Для любых a, b и c, являющихся элементами **S**, выполняется условие (a ◌ b) ◌ c = a ◌ (b ◌ c). Это условие называется **условием ассоциативности**. 3. В **S** существует уникальный элемент e, такой что для каждого элемента a в **S** выполняется следующее уравнение: e ◌ a = a ◌ e = a. Поскольку такой элемент e единственный, он называется **нейтральным элементом**. Это условие известно как **условие нейтрального элемента**.
4. Для каждого элемента a в **S** существует элемент b в **S**, такой что выполняется следующее уравнение: a ◌ b = b ◌ a = e, где e является нейтральным элементом. Элемент b здесь известен как **обратный элемент**, и обычно обозначается как a<sup>-1</sup>. Это условие известно как **условие обратимости**.

Давайте подробнее рассмотрим группы. Обозначим множество всех целых чисел как ℤ. Это множество в сочетании со стандартным сложением, или 〈ℤ, +〉, явно соответствует определению группы, так как удовлетворяет четырем вышеупомянутым аксиомам.

1. Для любых x и y, являющихся элементами ℤ, x + y также является элементом ℤ. Таким образом, 〈ℤ, +〉 удовлетворяет условию замкнутости.
2. Для любых x, y и z, являющихся элементами ℤ, (x + y) + z = x + (y + z). Таким образом, 〈ℤ, +〉 удовлетворяет условию ассоциативности.
3. В 〈ℤ, +〉 существует нейтральный элемент, а именно 0. Для любого x в ℤ, действительно выполняется: 0 + x = x + 0 = x. Таким образом, 〈ℤ, +〉 удовлетворяет условию нейтрального элемента.
4. Наконец, для каждого элемента x в ℤ существует y такое, что x + y = y + x = 0. Если, например, x было бы 10, то y было бы –10 (в случае, если x равно 0, y также равно 0). Таким образом, 〈ℤ, +〉 удовлетворяет условию обратимости.

Важно отметить, что то, что множество целых чисел с операцией сложения образует группу, не означает, что оно образует группу с операцией умножения. Вы можете проверить это, сравнив 〈ℤ, •〉 с четырьмя аксиомами группы (где • означает стандартное умножение).

Первые две аксиомы очевидно выполняются. Кроме того, при умножении элемент 1 может служить нейтральным элементом. Любое целое число x, умноженное на 1, дает в результате x. Однако, 〈ℤ, •〉 не удовлетворяет условию обратимости. То есть, не существует уникального элемента y в ℤ для каждого x в ℤ, так чтобы x • y = 1.

Например, предположим, что x = 22. Какое значение y из множества ℤ, умноженное на x, даст нейтральный элемент 1? Значение 1/22 подошло бы, но оно не входит в множество ℤ. Фактически, вы сталкиваетесь с этой проблемой для любого целого числа x, кроме значений 1 и -1 (где y должно быть 1 и -1 соответственно).
Если мы разрешим использование вещественных чисел для нашего множества, тогда наши проблемы во многом исчезнут. Для любого элемента x в множестве, умножение на 1/x дает 1. Поскольку дроби включены в множество вещественных чисел, обратный элемент может быть найден для каждого вещественного числа. Исключение составляет ноль, поскольку любое умножение на ноль никогда не даст единичный элемент 1. Следовательно, множество ненулевых вещественных чисел, оснащенное умножением, действительно является группой.

Некоторые группы соответствуют пятому общему условию, известному как **условие коммутативности**. Это условие следующее:

* Предположим, что группа G с множеством **S** и бинарным оператором ◌. Предположим, что a и b являются элементами **S**. Если выполняется условие, что a ◌ b = b ◌ a для любых двух элементов a и b в **S**, тогда G соответствует условию коммутативности.

Любая группа, соответствующая условию коммутативности, известна как **коммутативная группа** или **абелева группа** (в честь Нильса Хенрика Абеля). Легко проверить, что как множество вещественных чисел по сложению, так и множество целых чисел по сложению являются абелевыми группами. Множество целых чисел по умножению вообще не является группой, так что, de facto, не может быть абелевой группой. В отличие от этого, множество ненулевых вещественных чисел по умножению также является абелевой группой.

Следует соблюдать два важных соглашения о нотации. Во-первых, знаки “+” или “x” часто используются для обозначения операций группы, даже когда элементы на самом деле не являются числами. В этих случаях вы не должны интерпретировать эти знаки как стандартное арифметическое сложение или умножение. Вместо этого они являются операциями, имеющими лишь абстрактное сходство с этими арифметическими операциями.

Если вы специально не ссылаетесь на арифметическое сложение или умножение, проще использовать символы, такие как ◌ и ◊ для операций группы, поскольку они не имеют глубоко укоренившихся культурных коннотаций.

Во-вторых, по той же причине, по которой “+” и “x” часто используются для обозначения неарифметических операций, единичные элементы групп часто символизируются “0” и “1”, даже когда элементы в этих группах не являются числами. Если вы не ссылаетесь на единичный элемент группы с числами, проще использовать более нейтральный символ, такой как “e”, для обозначения единичного элемента.

Многие различные и очень важные множества значений в математике, оснащенные определенными бинарными операциями, являются группами. Однако криптографические приложения работают только с множествами целых чисел или, по крайней мере, с элементами, которые описываются целыми числами, то есть в пределах теории чисел. Следовательно, множества с вещественными числами, отличными от целых, не используются в криптографических приложениях.

Закончим, предоставив пример элементов, которые могут быть “описаны целыми числами”, хотя они и не являются целыми числами. Хорошим примером являются точки эллиптических кривых. Хотя любая точка на эллиптической кривой явно не является целым числом, такая точка действительно описывается двумя целыми числами.

Эллиптические кривые, например, критически важны для Bitcoin. Любая стандартная частная и публичная пара ключей Bitcoin выбирается из множества точек, определенных следующей эллиптической кривой: x<sup>3</sup> + 7 = y<sup>2</sup> mod 2<sup>256</sup> – 232 – 29 – 28 – 27 – 26 - 24 - 1 (наибольшее простое число меньше 2<sup>256</sup>). Координата x является частным ключом, а координата y - вашим публичным ключом.
Транзакции в Биткойне обычно включают блокировку выходов на один или несколько публичных ключей каким-либо образом. Затем, значение из этих транзакций может быть разблокировано с помощью создания цифровых подписей соответствующими приватными ключами.

## Циклические группы
<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

Одно из главных различий, которое мы можем провести, это между **конечной** и **бесконечной группой**. Первая имеет конечное количество элементов, в то время как вторая имеет бесконечное количество элементов. Количество элементов в любой конечной группе известно как **порядок группы**. Вся практическая криптография, включающая использование групп, опирается на конечные (числовые) группы.

В криптографии с открытым ключом особенно важны определенные классы конечных абелевых групп, известные как циклические группы. Чтобы понять циклические группы, нам сначала нужно понять концепцию экспоненцирования элементов группы.

Предположим, что группа G с операцией группы ◌, и что a является элементом G. Тогда выражение a<sup>n</sup> следует интерпретировать как элемент a, комбинированный сам с собой в общей сложности n – 1 раз. Например, a<sup>2</sup> означает a ◌ a, a<sup>3</sup> означает a ◌ a ◌ a, и так далее. (Заметьте, что здесь экспоненцирование не обязательно соответствует экспоненцированию в стандартном арифметическом смысле.)

Давайте рассмотрим пример. Предположим, что G = 〈ℤ mod 7,+〉, и что наше значение для a равно 4. В этом случае, a<sup>2</sup> = [4 + 4 mod 7] = [8 mod 7] = 1 mod 7. В качестве альтернативы, a<sup>4</sup> будет представлять [4 + 4 + 4 + 4 mod 7] = [16 mod 7] = 2 mod 7.

Некоторые абелевы группы имеют один или несколько элементов, которые могут порождать все другие элементы группы через продолжительное экспоненцирование. Эти элементы называются **генераторами** или **примитивными элементами**.

Важным классом таких групп является 〈ℤ* mod N, •〉, где N - простое число. Обозначение ℤ* здесь означает, что группа содержит все ненулевые положительные целые числа меньше N. Таким образом, такая группа всегда имеет N – 1 элементов.

Рассмотрим, например, G = 〈ℤ* mod 11, •〉. Эта группа имеет следующие элементы: {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. Порядок этой группы равен 10 (что действительно равно 11 – 1).

Давайте исследуем экспоненцирование элемента 2 из этой группы. Расчеты до 2<sup>12</sup> показаны ниже. Обратите внимание, что слева от уравнения экспонента относится к экспоненцированию элемента группы. В нашем конкретном примере это действительно включает арифметическое экспоненцирование справа от уравнения (но это также могло включать, например, сложение). Для уточнения я выписал повторяющуюся операцию, а не форму экспоненты справа.

* 2<sup>1</sup> = 2 mod 11
* 2<sup>2</sup> = 2 · 2 mod 11 = 4 mod 11
* 2<sup>3</sup> = 2 · 2 · 2 mod 11 = 8 mod 11
* 2<sup>4</sup> = 2 · 2 · 2 · 2 mod 11 = 16 mod 11 = 5 mod 11
* 2<sup>5</sup> = 2 · 2 · 2 · 2 · 2 mod 11 = 32 mod 11 = 10 mod 11
* 2<sup>6</sup> = 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 64 mod 11 = 9 mod 11
* 2<sup>7</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 128 mod 11 = 7 mod 11
* 2<sup>8</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 256 mod 11 = 3 mod 11
* 2<sup>9</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 512 mod 11 = 6 mod 11
* 2<sup>10</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 1024 mod 11 = 1 mod 11
* 2<sup>11</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 2048 mod 11 = 2 mod 11
* 2<sup>12</sup> = 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 · 2 mod 11 = 4096 mod 11 = 4 mod 11

Если внимательно посмотреть, можно увидеть, что выполнение возведения в степень элемента 2 циклически проходит через все элементы 〈ℤ* mod 11, •〉 в следующем порядке: 2, 4, 8, 5, 10, 9, 7, 3, 6, 1. После 2<sup>10</sup> продолжение возведения в степень элемента 2 снова проходит через все элементы и в том же порядке. Следовательно, элемент 2 является генератором в 〈ℤ* mod 11, •〉.

Хотя 〈ℤ* mod 11, •〉 имеет несколько генераторов, не все элементы этой группы являются генераторами. Рассмотрим, например, элемент 3. Проход через первые 10 возведений в степень, не показывая громоздкие вычисления, дает следующие результаты:

* 3<sup>1</sup> = 3 mod 11
* 3<sup>2</sup> = 9 mod 11
* 3<sup>3</sup> = 5 mod 11
* 3<sup>4</sup> = 4 mod 11
* 3<sup>5</sup> = 1 mod 11
* 3<sup>6</sup> = 3 mod 11
* 3<sup>7</sup> = 9 mod 11
* 3<sup>8</sup> = 5 mod 11
* 3<sup>9</sup> = 4 mod 11
* 3<sup>10</sup> = 1 mod 11

Вместо того чтобы перебирать все значения в 〈ℤ* mod 11, •〉, возведение в степень элемента 3 приводит только к подмножеству этих значений: 3, 9, 5, 4 и 1. После пятого возведения в степень эти значения начинают повторяться.

Теперь мы можем определить **циклическую группу** как любую группу, имеющую по крайней мере один генератор. То есть, есть по крайней мере один элемент группы, из которого вы можете произвести все другие элементы группы через возведение в степень.

Вы могли заметить в нашем примере выше, что как 2<sup>10</sup>, так и 3<sup>10</sup> равны 1 mod 11. Фактически, хотя мы не будем выполнять расчеты, возведение в степень 10 любого элемента группы 〈ℤ* mod 11, •〉 даст в результате 1 mod 11. Почему это так?

Это важный вопрос, но для его ответа требуется некоторая работа.

Для начала предположим, что есть два положительных целых числа a и N. Важная теорема в теории чисел утверждает, что a имеет мультипликативный обратный элемент по модулю N (то есть, целое число b такое, что a • b = 1 mod N) тогда и только тогда, когда наибольший общий делитель между a и N равен 1. То есть, если a и N взаимно просты.

Таким образом, для любой группы целых чисел, оснащенной умножением по модулю N, в набор включаются только меньшие взаимно простые с N числа. Мы можем обозначить этот набор как ℤ<sup>c</sup> mod N.

Например, предположим, что N равно 10. Только целые числа 1, 3, 7 и 9 взаимно просты с 10. Таким образом, набор ℤ<sup>c</sup> mod 10 включает только {1, 3, 7, 9}. Вы не можете создать группу с целочисленным умножением по модулю 10, используя любые другие целые числа от 1 до 10. Для этой конкретной группы обратными парами являются 1 и 9, а также 3 и 7.

В случае, когда само N является простым числом, все целые числа от 1 до N – 1 взаимно просты с N. Такая группа, таким образом, имеет порядок N – 1. Используя нашу ранее введенную нотацию, ℤ<sup>c</sup> mod N равно ℤ* mod N, когда N простое. Группа, которую мы выбрали для нашего раннего примера, 〈ℤ* mod 11, •〉, является конкретным примером этого класса групп.

Далее, функция φ(N) вычисляет количество взаимно простых чисел до числа N и известна как **функция Эйлера**.<sup>[1](#footnote1)</sup> Согласно **теореме Эйлера**, когда два целых числа a и N взаимно просты, выполняется следующее:

* a<sup>φ(N)</sup> mod N = 1 mod N
Это имеет важное значение для класса групп 〈ℤ* mod N, •〉, где N является простым числом. Для этих групп экспоненцирование элементов группы представляет собой арифметическое возведение в степень. То есть, a<sup>φ(N)</sup> mod N представляет арифметическую операцию a<sup>φ(N)</sup> mod N. Поскольку любой элемент a в этих мультипликативных группах взаимно прост с N, это означает, что a<sup>φ(N)</sup> mod N = a<sup>N – 1</sup> mod N = 1 mod N.
Теорема Эйлера является действительно важным результатом. Во-первых, это подразумевает, что все элементы в 〈ℤ* mod N, •〉 могут циклически проходить через определенное количество значений при возведении в степень, которое делит N – 1. В случае с 〈ℤ* mod 11, •〉, это означает, что каждый элемент может циклически проходить через 2, 5 или 10 элементов. Количество значений, через которые проходит любой элемент при возведении в степень, известно как **порядок элемента**. Элемент с порядком, эквивалентным порядку группы, является генератором.

Более того, теорема Эйлера подразумевает, что мы всегда можем знать результат a<sup>N – 1</sup> mod N для любой группы 〈ℤ* mod N, •〉, где N является простым числом. Это так, независимо от того, насколько сложными могут быть фактические расчеты.

Например, предположим, что наша группа это ℤ* mod 160,481,182 (где 160,481,182 действительно является простым числом). Мы знаем, что все целые числа от 1 до 160,481,181 должны быть элементами этой группы, и что φ(n) = 160,481,181. Хотя мы не можем выполнить все шаги в расчетах, мы знаем, что выражения вроде 514<sup>160,481,181</sup>, 2,005<sup>160,481,181</sup> и 256,212<sup>160,481,181</sup> должны все равно быть равны 1 mod 160,481,182.

## Поля
<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

Группа является базовой алгебраической структурой в абстрактной алгебре, но существует еще много других. Единственной другой алгебраической структурой, с которой вам нужно быть знакомым, является поле, в частности конечное поле. Этот тип алгебраической структуры часто используется в криптографии, например, в Стандарте передового шифрования. Последний является основной схемой симметричного шифрования, с которой вы столкнетесь на практике.

Поле происходит из понятия группы. В частности, **поле** - это набор элементов **S**, оснащенный двумя бинарными операторами ◌ и ◊, которые удовлетворяют следующим условиям:

1. Набор **S**, оснащенный ◌, является абелевой группой.
2. Набор **S**, оснащенный ◊, является абелевой группой для "ненулевых" элементов.
3. Набор **S**, оснащенный двумя операторами, удовлетворяет так называемому условию дистрибутивности: Предположим, что a, b и c являются элементами **S**. Тогда **S**, оснащенный двумя операторами, удовлетворяет свойству дистрибутивности, когда a ◌ (b ◊ c) = a ◌ b ◊ a ◌ c.
Обратите внимание, что, как и в случае с группами, определение поля очень абстрактно. Оно не делает никаких утверждений о типах элементов в **S**, или о операциях ◌ и ◊. Просто говорится, что поле - это любой набор элементов с двумя операциями, для которых выполняются три вышеуказанных условия. (Элемент "ноль" во второй абелевой группе может быть абстрактно интерпретирован.)
Так что может быть примером поля? Хорошим примером является множество ℤ mod 7, или {0,1,…,7}, определенное над стандартным сложением (вместо ◌ выше) и стандартным умножением (вместо ◊ выше).

Во-первых, ℤ mod 7 удовлетворяет условию для того, чтобы быть абелевой группой по сложению, и оно удовлетворяет условию для того, чтобы быть абелевой группой по умножению, если рассматривать только ненулевые элементы. Во-вторых, сочетание множества с двумя операторами удовлетворяет условию дистрибутивности.

Дидактически полезно исследовать эти утверждения, используя некоторые конкретные значения. Давайте возьмем экспериментальные значения 5, 2 и 3, некоторые случайно выбранные элементы из множества ℤ mod 7, чтобы исследовать поле 〈ℤ mod 7, +, •〉. Мы будем использовать эти три значения по порядку, по мере необходимости, для исследования конкретных условий.

Давайте сначала исследуем, является ли ℤ mod 7, оснащенное сложением, абелевой группой.

1. Условие замыкания: Давайте возьмем 5 и 2 в качестве наших значений. В этом случае, [5 + 2] mod 7 = 7 mod 7 = 0. Это действительно элемент ℤ mod 7, так что результат согласуется с условием замыкания.
2. Условие ассоциативности: Давайте возьмем 5, 2 и 3 в качестве наших значений. В этом случае, [(5 + 2) + 3] mod 7 = [5 + (2 + 3)] mod 7 = 10 mod 7 = 3. Это согласуется с условием ассоциативности.
3. Условие идентичности: Давайте возьмем 5 в качестве нашего значения. В этом случае, [5 + 0] mod 7 = [0 + 5] mod 7 = 5. Так что 0 выглядит как элемент идентичности для сложения.
4. Условие обратного элемента: Рассмотрим обратное для 5. Должно быть так, что [5 + d] mod 7 = 0, для некоторого значения d. В этом случае, уникальное значение из ℤ mod 7, которое удовлетворяет этому условию, это 2.
5. Условие коммутативности: Давайте возьмем 5 и 3 в качестве наших значений. В этом случае, [5 + 3] mod 7 = [3 + 5] mod 7 = 1. Это согласуется с условием коммутативности.

Множество ℤ mod 7, оснащенное сложением, явно является абелевой группой. Теперь давайте исследуем, является ли ℤ mod 7, оснащенное умножением, абелевой группой для всех ненулевых элементов.

1. Условие замыкания: Давайте возьмем 5 и 2 в качестве наших значений. В этом случае, [5 • 2] mod 7 = 10 mod 7 = 3. Это также элемент ℤ mod 7, так что результат согласуется с условием замыкания.
2. Условие ассоциативности: Возьмем значения 5, 2 и 3. В этом случае [(5 • 2) • 3] mod 7 = [5 • (2 • 3)] mod 7 = 30 mod 7 = 2. Это соответствует условию ассоциативности.
3. Условие нейтрального элемента: Возьмем 5 как наше значение. В этом случае, [5 • 1] mod 7 = [1 • 5] mod 7 = 5. Таким образом, 1 является нейтральным элементом для умножения.
4. Условие обратного элемента: Рассмотрим обратный элемент к 5. Должно выполняться условие [5 • d] mod 7 = 1 для некоторого значения d. Уникальное значение из ℤ mod 7, удовлетворяющее этому условию, - это 3. Это соответствует условию обратного элемента.
5. Условие коммутативности: Возьмем 5 и 3 как наши значения. В этом случае, [5 • 3] mod 7 = [3 • 5] mod 7 = 15 mod 7 = 1. Это соответствует условию коммутативности.

Множество ℤ mod 7 явно соответствует правилам абелевой группы при объединении либо с операцией сложения, либо с операцией умножения над ненулевыми элементами.

Наконец, это множество в сочетании с обеими операциями, кажется, соответствует условию дистрибутивности. Возьмем 5, 2 и 3 как наши значения. Мы видим, что [5 • (2 + 3)] mod 7 = [5 • 2 + 5 • 3] mod 7 = 25 mod 7 = 4.

Теперь мы видели, что ℤ mod 7, оснащенное сложением и умножением, соответствует аксиомам конечного поля при тестировании с конкретными значениями. Конечно, мы также можем показать это в общем случае, но не будем делать этого здесь.

Ключевое различие между двумя типами полей: конечные и бесконечные поля.

**Бесконечное поле** включает в себя поле, где множество **S** бесконечно велико. Множество вещественных чисел ℝ, оснащенное операциями сложения и умножения, является примером бесконечного поля. **Конечное поле**, также известное как **поле Галуа**, - это поле, где множество **S** конечно. Наш пример выше 〈ℤ mod 7, +, •〉 является конечным полем.

В криптографии нас преимущественно интересуют конечные поля. В общем, можно показать, что конечное поле существует для некоторого множества элементов **S** тогда и только тогда, когда оно имеет p<sup>m</sup> элементов, где p - простое число, а m - положительное целое число, большее или равное одному. Другими словами, если порядок некоторого множества **S** является простым числом (p<sup>m</sup>, где m = 1) или степенью простого числа (p<sup>m</sup>, где m > 1), тогда можно найти два оператора ◌ и ◊ так, что условия для поля удовлетворены.

Если некоторое конечное поле имеет простое число элементов, то оно называется **простым полем**. Если количество элементов в конечном поле является степенью простого числа, то поле называется **расширенным полем**. В криптографии нас интересуют как простые, так и расширенные поля.<sup>[2](#footnote2)</sup>
Основные первичные поля интереса в криптографии - это те, где множество всех целых чисел модулируется некоторым простым числом, а операторы являются стандартными сложением и умножением. Этот класс конечных полей включал бы ℤ mod 2, ℤ mod 3, ℤ mod 5, ℤ mod 7, ℤ mod 11, ℤ mod 13 и так далее. Для любого простого поля ℤ mod p множество целых чисел поля следующее: {0,1,….,p – 2, p – 1}.
В криптографии нас также интересуют расширенные поля, особенно любые поля с 2<sup>m</sup> элементами, где m > 1. Такие конечные поля, например, используются в шифре Рейндала, который лежит в основе Стандарта передового шифрования. Хотя первичные поля относительно интуитивно понятны, эти расширенные поля на основе 2, вероятно, не для тех, кто не знаком с абстрактной алгеброй.

Для начала, действительно верно, что любому множеству целых чисел с 2<sup>m</sup> элементами можно назначить два оператора, которые сделают их комбинацию полем (при условии, что m является положительным целым числом). Однако, то, что поле существует, не обязательно означает, что его легко обнаружить или что оно особенно практично для определенных приложений.

Как оказалось, особенно применимые расширенные поля 2<sup>m</sup> в криптографии - это те, которые определены над особыми множествами полиномиальных выражений, а не некоторым множеством целых чисел.

Например, предположим, что мы хотели расширенное поле с 2<sup>3</sup> (то есть, 8) элементами в множестве. Хотя может существовать много различных множеств, которые могут быть использованы для полей такого размера, одно такое множество включает все уникальные полиномы вида a<sub>2</sub>x<sup>2</sup> + a<sub>1</sub>x + a<sub>0</sub>, где каждый коэффициент a<sub>i</sub> либо 0, либо 1. Следовательно, это множество **S** включает следующие элементы:

1. 0: Случай, когда a<sub>2</sub> = 0, a<sub>1</sub> = 0, и a<sub>0</sub> = 0.
2. 1: Случай, когда a<sub>2</sub> = 0, a<sub>1</sub> = 0, и a<sub>0</sub> = 1.
3. x: Случай, когда a<sub>2</sub> = 0, a<sub>1</sub> = 1, и a<sub>0</sub> = 0.
4. x + 1: Случай, когда a<sub>2</sub> = 0, a<sub>1</sub> = 1, и a<sub>0</sub> = 1.
5. x<sup>2</sup>: Случай, когда a<sub>2</sub>= 1, a<sub>1</sub> = 0, и a<sub>0</sub> = 0.
6. x<sup>2</sup> + 1: Случай, когда a<sub>2</sub> = 1, a<sub>1</sub> = 0, и a<sub>0</sub> = 1.
7. \(x^2 + x\): Случай, когда \(a_2 = 1\), \(a_1 = 1\), и \(a_0 = 0\). 8. \(x^2 + x + 1\): Случай, когда \(a_2 = 1\), \(a_1 = 1\), и \(a_0 = 1\).

Таким образом, **S** будет множеством \(\{0,1,x,x + 1, x^2,x^2 + 1, x^2 + x, x^2 + x + 1\}\). Какие две операции можно определить над этим набором элементов, чтобы их комбинация образовала поле?

Первая операция над множеством S (◌) может быть определена как стандартное сложение полиномов по модулю 2. Всё, что вам нужно сделать, это сложить полиномы как обычно, а затем применить модуль 2 к каждому из коэффициентов результирующего полинома. Вот некоторые примеры:

* \([(x^2) + (x^2 + x + 1)] \mod 2 = [2x^2 + x + 1] \mod 2 = x + 1\)
* \([(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2\)
* \([(x + 1) + (x^2 + x + 1)] \mod 2 = [x^2 + 2x + 2] \mod 2 = x^2 + 1\)

Вторая операция над множеством S (◌), необходимая для создания поля, более сложная. Это своего рода умножение, но не стандартное умножение из арифметики. Вместо этого, вы должны рассматривать каждый элемент как вектор и понимать операцию как умножение этих двух векторов по модулю неприводимого полинома.

Давайте сначала обратимся к понятию неприводимого полинома. **Неприводимый полином** - это такой, который не может быть разложен на множители (так же, как простое число не может быть разложено на компоненты, отличные от 1 и самого простого числа). Для наших целей нас интересуют полиномы, которые являются неприводимыми относительно множества всех целых чисел. (Заметим, что вы можете разложить на множители определенные полиномы, используя, например, действительные или комплексные числа, даже если вы не можете разложить их, используя целые числа.)

Например, рассмотрим полином \(x^2 - 3x + 2\). Его можно переписать как \((x – 1)(x – 2)\). Следовательно, он не является неприводимым. Теперь рассмотрим полином \(x^2 + 1\). Используя только целые числа, нет способа дальше разложить это выражение. Следовательно, это неприводимый полином относительно целых чисел.
Далее давайте обратимся к концепции умножения векторов. Мы не будем глубоко изучать эту тему, вам просто нужно понять основное правило: любое деление векторов возможно, пока степень делимого выше или равна степени делителя. Если степень делимого ниже, чем у делителя, то делимое больше не может быть разделено на делитель.

Например, рассмотрим выражение x<sup>6</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>. Оно допускает дальнейшее упрощение, так как степень делимого, 6, выше степени делителя, 5. Теперь рассмотрим выражение x<sup>5</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>. Это выражение также допускает дальнейшее упрощение, так как степень делимого, 5, и делителя, 5, равны.

Однако теперь рассмотрим выражение x<sup>4</sup> + x + 1 mod x<sup>5</sup> + x<sup>2</sup>. Оно не допускает дальнейшего упрощения, так как степень делимого, 4, ниже степени делителя, 5.

Исходя из этой информации, мы теперь готовы найти нашу вторую операцию для множества {0,1,x,x + 1,x<sup>2</sup>,x<sup>2</sup> + 1,x<sup>2</sup> + x,x<sup>2</sup> + x + 1}.

Я уже сказал, что вторая операция должна быть понята как умножение векторов по модулю некоторого неприводимого полинома. Этот неприводимый полином должен обеспечивать, чтобы вторая операция определяла абелеву группу над **S** и была согласована с распределительным условием. Так каким же должен быть этот неприводимый полином?

Поскольку все векторы в множестве имеют степень 2 или ниже, неприводимый полином должен быть степени 3. Если любое умножение двух векторов в множестве дает полином степени 3 или выше, мы знаем, что по модулю полинома степени 3 всегда получается полином степени 2 или ниже. Это так, потому что любой полином степени 3 или выше всегда делится на полином степени 3. Кроме того, полином, который функционирует как делитель, должен быть неприводимым.

Оказывается, существует несколько неприводимых полиномов степени 3, которые мы могли бы использовать в качестве нашего делителя. Каждый из этих полиномов определяет различное поле в сочетании с нашим множеством S и сложением по модулю 2. Это означает, что у вас есть несколько вариантов при использовании расширенных полей 2<sup>m</sup> в криптографии.

Для нашего примера предположим, что мы выбираем полином x<sup>3</sup> + x + 1. Он действительно неприводим, потому что его нельзя разложить с использованием целых чисел. Кроме того, он обеспечит, что любое умножение двух элементов даст полином степени 2 или меньше.
Давайте рассмотрим пример второй операции, используя полином x<sup>3</sup> + x + 1 в качестве делителя, чтобы проиллюстрировать, как это работает. Предположим, что вы умножаете элементы x<sup>2</sup> + 1 на x<sup>2</sup> + x в нашем множестве **S**. Затем нам нужно вычислить выражение [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1. Это можно упростить следующим образом:
* [(x<sup>2</sup> + 1) • (x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 =
* [x<sup>2</sup> • x<sup>2</sup> + x<sup>2</sup> • x + 1 • x<sup>2</sup> + 1 • x] mod x<sup>3</sup> + x + 1 = 
* [x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1
    
Мы знаем, что [x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x] mod x<sup>3</sup> + x + 1 может быть уменьшено, так как степень делимого (4) выше, чем степень делителя (3).

Для начала, вы можете видеть, что выражение x<sup>3</sup> + x + 1 входит в x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x всего x раз. Вы можете проверить это, умножив x<sup>3</sup> + x + 1 на x, что дает x<sup>4</sup> + x<sup>2</sup> + x. Поскольку последний член имеет ту же степень, что и делимое, а именно 4, мы знаем, что это работает. Вы можете вычислить остаток от этого деления на x следующим образом:

* [(x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x) – (x<sup>4</sup> + x<sup>2</sup> + x)] mod x<sup>3</sup> + x + 1 = 
* [x<sup>3</sup>] mod x<sup>3</sup> + x + 1 =
* x<sup>3</sup>

Таким образом, после деления x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x на x<sup>3</sup> + x + 1 всего x раз, у нас остается остаток x<sup>3</sup>. Можно ли это дальше разделить на x<sup>3</sup> + x + 1?
Интуитивно может показаться, что x<sup>3</sup> больше нельзя разделить на x<sup>3</sup> + x + 1, потому что последний член кажется больше. Однако, вспомните наше обсуждение деления векторов ранее. До тех пор, пока степень делимого больше или равна степени делителя, выражение может быть дополнительно упрощено. В частности, выражение x<sup>3</sup> + x + 1 может войти в x<sup>3</sup> ровно 1 раз. Остаток рассчитывается следующим образом:
[(x<sup>3</sup>) – (x<sup>3</sup> + x + 1)] mod x<sup>3</sup> + x + 1 = 
[x + 1] mod x<sup>3</sup> + x + 1 = 
x + 1

Возможно, вы задаетесь вопросом, почему (x<sup>3</sup>) – (x<sup>3</sup> + x + 1) дает в результате x + 1, а не – x – 1. Помните, что первая операция в нашем поле определена по модулю 2. Следовательно, вычитание двух векторов дает точно такой же результат, как и сложение двух векторов.

Подводя итог умножению x<sup>2</sup> + 1 и x<sup>2</sup> + x: Когда вы умножаете эти два члена, вы получаете полином 4-й степени, x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x, который необходимо уменьшить по модулю x<sup>3</sup> + x + 1. Полином 4-й степени делится на x<sup>3</sup> + x + 1 ровно x + 1 раз. Остаток после деления x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup> + x на x<sup>3</sup> + x + 1 ровно x + 1 раз равен x + 1. Это действительно элемент в нашем наборе {0,1,x,x + 1,x<sup>2</sup>,x<sup>2</sup> + 1,x<sup>2</sup> + x,x<sup>2</sup> + x + 1}.

Почему расширенные поля с основанием 2 над множествами полиномов, как в приведенном выше примере, могут быть полезны для криптографии? Причина в том, что коэффициенты в полиномах таких множеств, будь то 0 или 1, можно рассматривать как элементы двоичных строк определенной длины. Набор **S** в нашем примере выше, например, можно было бы вместо этого рассматривать как набор S, который включает все двоичные строки длиной 3 (000 до 111). Таким образом, операции над **S** также могут быть использованы для выполнения операций над этими двоичными строками и производства двоичной строки той же длины.

## Абстрактная алгебра на практике
<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>
Несмотря на формальный язык и абстрактность обсуждения, понятие группы не должно быть слишком сложным для понимания. Это просто набор элементов вместе с бинарной операцией, где выполнение этой бинарной операции на этих элементах удовлетворяет четырем общим условиям. Абелева группа имеет дополнительное условие, известное как коммутативность. Циклическая группа, в свою очередь, является особым видом абелевой группы, а именно той, у которой есть генератор. Поле - это просто более сложная конструкция из базового понятия группы.

Но если вы практически настроенный человек, вы могли бы на этом этапе задаться вопросом: Кому это интересно? Имеет ли значение знание о том, что некоторый набор элементов с оператором является группой, или даже абелевой или циклической группой, для реального мира? Имеет ли значение знание о том, что что-то является полем?

Не вдаваясь в слишком много деталей, ответ - "да". Группы были впервые созданы в 19 веке французским математиком Эваристом Галуа. Он использовал их для выводов о решении полиномиальных уравнений степени выше пяти.

С тех пор концепция группы помогла осветить ряд проблем в математике и в других областях. Например, на их основе физик Мюррей-Гелл-Ман смог предсказать существование частицы до того, как она была фактически наблюдена в экспериментах.<sup>[3](#footnote3)</sup> Для другого примера, химики используют теорию групп для классификации форм молекул. Математики даже использовали концепцию группы для выводов о чем-то таком конкретном, как обои!

По сути, показывая, что набор элементов с некоторым оператором является группой, означает, что то, что вы описываете, имеет определенную симметрию. Не симметрию в обычном смысле слова, а в более абстрактной форме. И это может предоставить значительные инсайты в отношении конкретных систем и проблем. Более сложные понятия из абстрактной алгебры просто дают нам дополнительную информацию.

Что наиболее важно, вы увидите значение групп и полей в теории чисел на практике через их применение в криптографии, особенно в криптографии с открытым ключом. Мы уже видели в нашем обсуждении полей, например, как расширенные поля используются в шифре Рижндаль. Мы рассмотрим этот пример в *Главе 5*.

## Дальнейшее изучение
<chapterId>ab51038d-82bd-5c5d-a759-276cfbf7fbce</chapterId>

Для дальнейшего обсуждения абстрактной алгебры я бы рекомендовал отличную серию видео по абстрактной алгебре от Socratica.<sup>[4](#footnote4)</sup> Я бы особенно рекомендовал следующие видео: “Что такое абстрактная алгебра?”, “Определение группы (расширенное)”, “Определение кольца (расширенное)”, и “Определение поля (расширенное)”. Эти четыре видео дадут вам дополнительное понимание многих обсуждаемых выше вопросов. (Мы не обсуждали кольца, но поле - это просто особый тип кольца.)

Для дальнейшего обсуждения современной теории чисел, вы можете обратиться к многим продвинутым обсуждениям криптографии. Я бы предложил для дальнейшего обсуждения "Введение в современную криптографию" Джонатана Каца и Йехуды Линделла или "Понимание криптографии" Кристофа Паара и Яна Пельцля.<sup>[5](#footnote5)</sup>
[^1]: Функция работает следующим образом. Любое целое число N может быть разложено на произведение простых чисел. Предположим, что конкретное N разложено следующим образом: p<sub>1</sub><sup>e1</sup> • p<sub>2</sub><sup>e2</sup> …. • p<sub>m</sub><sup>em</sup>, где все p являются простыми числами, а все e - целыми числами, большими или равными 1. Тогда, φ(N) = Сумма<sub>i=1…m</sub>[p<sub>i</sub><sup>ei</sup> – p<sub>i</sub><sup>ei - 1</sup>] [^1].
[^2]: Расширенные поля становятся очень контринтуитивными. Вместо элементов целых чисел они содержат наборы полиномов. Кроме того, любые операции выполняются по модулю некоторого неприводимого полинома [^2].

[^3]: Смотрите [Видео на YouTube](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be) [^3].

[^4]: Socratica, [Абстрактная алгебра](https://www.socratica.com/subject/abstract-algebra) [^4].

[^5]: Katz и Lindell, *Введение в современную криптографию*, 2-е изд., 2015 (CRC Press: Boca Raton, FL). Paar и Pelzl, *Понимание криптографии*, 2010 (Springer-Verlag: Берлин) [^5].

# Симметричная криптография
<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

Одно из двух основных направлений криптографии - симметричная криптография. Она включает в себя схемы шифрования, а также схемы, связанные с аутентификацией и целостностью. До 1970-х годов вся криптография состояла бы из симметричных схем шифрования.

Основное обсуждение начинается с рассмотрения симметричных схем шифрования и важного различия между потоковыми шифрами и блочными шифрами. Затем мы переходим к кодам аутентификации сообщений, которые являются схемами для обеспечения целостности и подлинности сообщений. Наконец, мы исследуем, как симметричные схемы шифрования и коды аутентификации сообщений могут быть объединены для обеспечения безопасной коммуникации.

В этой главе обсуждаются различные симметричные криптографические схемы из практики. Следующая глава предлагает подробное изложение шифрования с использованием потокового шифра и блочного шифра из практики, а именно RC4 и AES соответственно.

Прежде чем начать наше обсуждение симметричной криптографии, я хочу кратко сделать несколько замечаний о иллюстрациях с Алисой и Бобом в этой и последующих главах.

## Алиса и Боб
<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

При иллюстрации принципов криптографии люди часто опираются на примеры с участием Алисы и Боба. Я тоже буду придерживаться этого. 

Особенно если вы новичок в криптографии, важно понимать, что эти примеры с Алисой и Бобом предназначены только для иллюстрации криптографических принципов и конструкций в упрощенной среде. Однако принципы и конструкции применимы к гораздо более широкому кругу реальных контекстов.

Вот пять ключевых моментов, которые следует иметь в виду о примерах с участием Алисы и Боба в криптографии:

1. Их легко можно перевести на примеры с другими типами акторов, такими как компании или государственные организации.
2. Их легко можно расширить, чтобы включить трех или более акторов.
3. В примерах Боб и Алиса обычно являются активными участниками создания каждого сообщения и применения криптографических схем к этому сообщению. Но на самом деле электронная коммуникация в большинстве своем автоматизирована. Например, когда вы посещаете веб-сайт, использующий безопасность транспортного уровня, криптография обычно полностью обрабатывается вашим компьютером и веб-сервером. 4. В контексте электронной коммуникации "сообщения", которые отправляются по каналу связи, обычно являются пакетами TCP/IP. Они могут принадлежать электронной почте, сообщению в Facebook, телефонному разговору, передаче файла, веб-сайту, загрузке программного обеспечения и так далее. Это не сообщения в традиционном смысле. Тем не менее, криптографы часто упрощают эту реальность, утверждая, что сообщение, например, является электронной почтой.
5. Примеры обычно сосредоточены на электронной коммуникации, но они также могут быть расширены на традиционные формы коммуникации, такие как письма.

## Схемы симметричного шифрования
<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

Мы можем условно определить **схему симметричного шифрования** как любую криптографическую схему с тремя алгоритмами:

1. **Алгоритм генерации ключа**, который генерирует приватный ключ.
2. **Алгоритм шифрования**, который принимает приватный ключ и открытый текст в качестве входных данных и выдает шифротекст.
3. **Алгоритм дешифрования**, который принимает приватный ключ и шифротекст в качестве входных данных и выдает исходный открытый текст.

Обычно схема шифрования — будь то симметричная или асимметричная — предлагает шаблон для шифрования на основе базового алгоритма, а не точную спецификацию.

Например, рассмотрим Salsa20, схему симметричного шифрования. Ее можно использовать как с 128-битными, так и с 256-битными длинами ключей. Выбор длины ключа влияет на некоторые мелкие детали алгоритма (точное количество раундов в алгоритме).

Но нельзя сказать, что использование Salsa20 с 128-битным ключом является другой схемой шифрования, чем Salsa20 с 256-битным ключом. Базовый алгоритм остается тем же. Только при изменении базового алгоритма мы действительно говорим о двух разных схемах шифрования.

Схемы симметричного шифрования обычно полезны в двух типах случаев: (1) Когда два или более агента общаются на расстоянии и хотят сохранить содержание своих коммуникаций в секрете; и (2) когда один агент хочет сохранить содержание сообщения в секрете со временем.

Вы можете увидеть изображение ситуации (1) на *Рисунке 1* ниже. Боб хочет отправить сообщение M Алисе на расстоянии, но не хочет, чтобы другие могли прочитать это сообщение.

Боб сначала шифрует сообщение M с помощью приватного ключа K. Затем он отправляет шифротекст C Алисе. Как только Алиса получает шифротекст, она может расшифровать его с помощью ключа K и прочитать открытый текст. С хорошей схемой шифрования любой злоумышленник, перехвативший шифротекст C, не сможет узнать ничего действительно значимого о сообщении M.

Вы можете увидеть изображение ситуации (2) на *Рисунке 2* ниже. Боб хочет предотвратить просмотр определенной информации другими. Типичная ситуация может заключаться в том, что Боб является сотрудником, хранящим конфиденциальные данные на своем компьютере, которые не должны читать ни посторонние, ни его коллеги.
Боб шифрует сообщение M в момент времени T<sub>0</sub> с помощью ключа K, получая шифротекст C. В момент времени T<sub>1</sub> ему снова нужно сообщение, и он расшифровывает шифротекст C с помощью ключа K. Любой злоумышленник, который мог бы столкнуться с шифротекстом C в промежутке времени, не должен был бы иметь возможности вывести что-либо значимое о M из него.
*Рисунок 1: Секретность в пространстве*

![Рисунок 1: Секретность в пространстве](assets/Figure4-1.webp "Рисунок 1: Секретность в пространстве")

*Рисунок 2: Секретность во времени*

![Рисунок 2: Секретность во времени](assets/Figure4-2.webp "Рисунок 2: Секретность во времени")

## Пример: Шифр сдвига
<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

В главе 2 мы столкнулись с шифром сдвига, который является примером очень простой симметричной схемы шифрования. Давайте рассмотрим его снова здесь.

Предположим, что существует словарь *D*, который соотносит все буквы английского алфавита, по порядку, с набором чисел {0,1,2…,25}. Предположим набор возможных сообщений **M**. Тогда шифр сдвига - это схема шифрования, определенная следующим образом:

- Случайным образом выбирается ключ k из набора возможных ключей **K**, где **K** = {0,1,2,…,25}
- Шифрование сообщения m є **M** происходит следующим образом:
    - Разделить m на отдельные буквы m<sub>0</sub>, m<sub>1</sub>,….m<sub>i</sub>….,m<sub>l</sub>
    - Конвертировать каждую m<sub>i</sub> в число согласно *D*
    - Для каждой m<sub>i</sub>, c<sub>i</sub> = [(m<sub>i</sub> + k) mod 26]
    - Конвертировать каждую c<sub>i</sub> обратно в букву согласно *D*
    - Затем объединить c<sub>0</sub>, c<sub>1</sub>,….,c<sub>l</sub> для получения шифротекста c
- Расшифровка шифротекста c происходит следующим образом:
    - Конвертировать каждую c<sub>i</sub> в число согласно *D*
    - Для каждой c<sub>i</sub>, m<sub>i</sub> = [(c<sub>i</sub> – k) mod 26]
    - Конвертировать каждую m<sub>i</sub> обратно в букву согласно *D*
    - Затем объединить m<sub>0</sub>, m<sub>1</sub>,….,m<sub>l</sub> для получения исходного сообщения m

То, что делает шифр сдвига симметричной схемой шифрования, заключается в том, что для процессов шифрования и расшифровки используется один и тот же ключ. Например, предположим, что вы хотите зашифровать сообщение “DOG” с использованием шифра сдвига, и случайным образом выбрали ключ "24". Шифрование сообщения с этим ключом даст “BME”. Единственный способ восстановить исходное сообщение - использовать тот же ключ, "24", для процесса расшифровки.
Шифр сдвига является примером **моноалфавитного шифра подстановки**: схемы шифрования, где алфавит шифртекста фиксирован (то есть используется только один алфавит). Предполагая, что алгоритм дешифрования детерминирован, каждый символ в шифре подстановки может соответствовать не более чем одному символу в исходном тексте.
До 1700-х годов многие применения шифрования в значительной степени опирались на моноалфавитные шифры подстановки, хотя часто они были гораздо сложнее шифра сдвига. Например, вы могли случайным образом выбрать букву из алфавита для каждой буквы исходного текста при условии, что каждая буква встречается в алфавите шифртекста только один раз. Это означает, что у вас было бы факториал 26 возможных секретных ключей, что было огромным количеством в эпоху до появления компьютеров.

Обратите внимание, что термин **шифр** вы будете встречать очень часто в криптографии. Имейте в виду, что этот термин имеет различные значения. Фактически, я знаю по крайней мере пять различных значений этого термина в контексте криптографии.

В некоторых случаях он относится к схеме шифрования, как это происходит в шифре сдвига и моноалфавитном шифре подстановки. Однако термин также может относиться конкретно к алгоритму шифрования, секретному ключу или просто к шифртексту любой такой схемы шифрования.

Наконец, термин шифр также может относиться к базовому алгоритму, из которого можно построить криптографические схемы. Это могут включать различные алгоритмы шифрования, но также и другие типы криптографических схем. Этот смысл термина становится актуальным в контексте блочных шифров (см. раздел "Блочные шифры" ниже).

Вы также можете столкнуться с терминами **зашифровать** или **расшифровать**. Эти термины являются просто синонимами шифрования и дешифрования.

## Атаки полным перебором и принцип Керкгоффса
<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

Шифр сдвига является очень ненадежной симметричной схемой шифрования, по крайней мере, в современном мире.<sup>[1](#footnote1)</sup> Атакующий может просто попытаться расшифровать любой шифртекст со всеми 26 возможными ключами, чтобы увидеть, какой результат имеет смысл. Этот тип атаки, при котором атакующий просто перебирает ключи, чтобы увидеть, что работает, известен как **атака полным перебором** или **исчерпывающий поиск ключа**.

Для того чтобы схема шифрования соответствовала минимальному понятию безопасности, она должна иметь набор возможных ключей, или **пространство ключей**, которое настолько велико, что атаки полным перебором становятся невозможными. Все современные схемы шифрования соответствуют этому стандарту. Это известно как **принцип достаточного пространства ключей**. Подобный принцип обычно применяется в различных типах криптографических схем.

Чтобы представить себе огромный размер пространства ключей в современных схемах шифрования, предположим, что файл был зашифрован с использованием 128-битного стандарта передового шифрования. Это означает, что атакующему нужно перебрать набор из 2<sup>128</sup> ключей для атаки полным перебором. Шанс успеха в 0,78% с этой стратегией потребовал бы от атакующего перебрать примерно 2,65 x 10<sup>36</sup> ключей.
Допустим, мы оптимистично предполагаем, что атакующий может попытаться проверить 10 квадриллионов ключей в секунду (то есть 10<sup>16</sup> ключей в секунду). Чтобы проверить 0,78% всех ключей в пространстве ключей, его атаке придется длиться 2,65 x 10<sup>20</sup> секунд. Это примерно 8,4 триллиона лет. Таким образом, даже атака методом полного перебора со стороны абсурдно мощного противника не реалистична с современной 128-битной схемой шифрования. Здесь действует принцип достаточного пространства ключей.

Будет ли шифр сдвига более безопасным, если атакующий не знает алгоритм шифрования? Возможно, но не на много.

В любом случае, современная криптография всегда предполагает, что безопасность любой симметричной схемы шифрования зависит только от сохранения в секрете приватного ключа. Предполагается, что атакующий всегда знает все остальные детали, включая пространство сообщений, пространство ключей, пространство шифртекста, алгоритм выбора ключа, алгоритм шифрования и алгоритм дешифрования.

Идея о том, что безопасность симметричной схемы шифрования может зависеть только от секретности приватного ключа, известна как **принцип Керкгоффса**.

Как изначально предполагал Керкгоффс, принцип применяется только к симметричным схемам шифрования. Однако более общая версия принципа также применяется ко всем другим современным типам криптографических схем: дизайн любой криптографической схемы не должен быть секретным, чтобы схема была безопасной; секретность может распространяться только на некоторые строки информации, обычно на приватный ключ.

Принцип Керкгоффса является центральным в современной криптографии по четырем причинам.<sup>[2](#footnote2)</sup> Во-первых, существует лишь ограниченное количество криптографических схем для определенных типов приложений. Например, большинство современных приложений симметричного шифрования используют шифр Рейндал. Так что ваша секретность относительно дизайна схемы очень ограничена. Однако, есть гораздо больше гибкости в сохранении в секрете некоторого приватного ключа для шифра Рейндал.

Во-вторых, заменить некоторую строку информации проще, чем целую криптографическую схему. Предположим, что все сотрудники компании используют одно и то же программное обеспечение для шифрования, и каждые два сотрудника имеют приватный ключ для конфиденциального общения. Компрометация ключей в этом сценарии проблематична, но по крайней мере компания могла бы сохранить программное обеспечение даже при таких нарушениях безопасности. Если бы компания полагалась на секретность схемы, то любое нарушение этой секретности потребовало бы замены всего программного обеспечения.

В-третьих, принцип Керкгоффса позволяет стандартизировать и обеспечивать совместимость между пользователями криптографических схем. Это имеет огромные преимущества для эффективности. Например, трудно представить, как миллионы людей могли бы безопасно подключаться к веб-серверам Google каждый день, если бы эта безопасность требовала сохранения в секрете криптографических схем.

В-четвертых, принцип Керкгоффса позволяет публичному анализу криптографических схем. Такой анализ абсолютно необходим для достижения безопасных криптографических схем. Например, основной алгоритм в симметричной криптографии, шифр Рейндал, был результатом конкурса, организованного Национальным институтом стандартов и технологий с 1997 по 2000 год.

Любая система, которая пытается достичь **безопасности за счет неясности**, полагается на сохранение в секрете деталей своего дизайна и/или реализации. В криптографии это была бы конкретно система, полагающаяся на сохранение в секрете деталей дизайна криптографической схемы. Таким образом, безопасность за счет неясности находится в прямом противоречии с принципом Керкгоффса.
Способность открытости улучшать качество и безопасность также широко распространяется в цифровом мире, не ограничиваясь только криптографией. Свободные и открытые дистрибутивы Linux, такие как Debian, например, обычно имеют несколько преимуществ перед их аналогами Windows и MacOS с точки зрения конфиденциальности, стабильности, безопасности и гибкости. Хотя это может иметь множество причин, самым важным принципом, вероятно, является то, как выразился Эрик Реймонд в своем знаменитом эссе "Кафедраль и Базар", что "[п]ри достаточном количестве глаз все баги становятся очевидными." Этот принцип мудрости толпы дал Linux его наибольший успех.
Нельзя однозначно утверждать, что криптографическая схема "безопасна" или "небезопасна". Вместо этого существуют различные понятия безопасности для криптографических схем. Каждое **определение криптографической безопасности** должно указывать (1) цели безопасности, а также (2) возможности атакующего. Анализ криптографических схем с точки зрения одного или нескольких конкретных понятий безопасности дает представление о их применении и ограничениях.

Хотя мы не будем углубляться во все детали различных понятий криптографической безопасности, вы должны знать, что два предположения являются общими для всех современных понятий криптографической безопасности, касающихся симметричных и асимметричных схем (и в какой-то форме к другим криптографическим примитивам):

* Знания атакующего о схеме соответствуют принципу Керкгоффса.
* Атакующий не может осуществимо выполнить атаку методом полного перебора на схему. В частности, модели угроз криптографических понятий безопасности обычно даже не допускают атак методом полного перебора, поскольку предполагается, что они не являются релевантными.

## Потоковые шифры

Симметричные шифровальные схемы обычно делятся на два типа: потоковые шифры и блочные шифры. Однако это различие несколько проблематично, поскольку люди используют эти термины неоднозначно. В следующих нескольких разделах я изложу различие так, как считаю это наилучшим образом. Однако вы должны быть осведомлены, что многие люди могут использовать эти термины несколько иначе, чем я изложил.

Давайте сначала обратимся к потоковым шифрам. **Потоковый шифр** — это симметричная шифровальная схема, где шифрование состоит из двух шагов.

Сначала с помощью приватного ключа создается строка, длина которой равна длине открытого текста. Эта строка называется **ключевым потоком**.

Затем ключевой поток математически сочетается с открытым текстом для получения шифртекста. Это сочетание обычно является операцией XOR. Для расшифровки можно просто выполнить обратную операцию. (Заметьте, что A XOR B = B XOR A, в случае если A и B являются битовыми строками. Таким образом, порядок операции XOR в потоковом шифре не имеет значения для результата. Это свойство известно как коммутативность.)

Типичный XOR потоковый шифр изображен на *Рисунке 3*. Сначала вы берете приватный ключ K и используете его для генерации ключевого потока. Затем ключевой поток сочетается с открытым текстом с помощью операции XOR для получения шифртекста. Любой агент, получивший шифртекст, может легко расшифровать его, если у него есть ключ K. Все, что ему нужно сделать, это создать ключевой поток такой же длины, как шифртекст, согласно указанной процедуре схемы, и выполнить с ним операцию XOR.

*Рисунок 3: XOR потоковый шифр*

![Рисунок 3: XOR потоковый шифр](assets/Figure4-3.webp "Рисунок 3: XOR потоковый шифр")
Напоминаем, что схема шифрования обычно является шаблоном для шифрования с использованием одного и того же базового алгоритма, а не точной спецификацией. Соответственно, потоковый шифр обычно является шаблоном для шифрования, в котором можно использовать ключи разной длины. Хотя длина ключа может влиять на некоторые мелкие детали схемы, это не повлияет на ее существенную форму.
Шифр сдвига является примером очень простого и ненадежного потокового шифра. Используя одну букву (приватный ключ), вы можете произвести строку букв длиной с сообщение (ключевой поток). Затем этот ключевой поток сочетается с открытым текстом с помощью операции по модулю для получения шифртекста. (Эта операция по модулю может быть упрощена до операции XOR при представлении букв в битах).

Другой известный пример потокового шифра - **шифр Виженера**, названный в честь Блеза де Виженера, который полностью разработал его в конце 16-го века (хотя другие уже сделали много предшествующей работы). Это пример **полиалфавитного шифра подстановки**: схемы шифрования, где алфавит шифртекста для символа открытого текста меняется в зависимости от его позиции в тексте. В отличие от моноалфавитного шифра подстановки, символы шифртекста могут быть связаны с более чем одним символом открытого текста.

По мере того как шифрование набирало популярность в Ренессансной Европе, также набирало популярность и **криптоанализ** — то есть, взлом шифртекстов — особенно с использованием **частотного анализа**. Последний использует статистические закономерности в нашем языке для взлома шифртекстов и был открыт арабскими учеными уже в девятом веке. Это техника, которая особенно хорошо работает с более длинными текстами. И даже самые сложные моноалфавитные шифры подстановки уже не были достаточны против частотного анализа к 1700-м годам в Европе, особенно в военных и безопасностных настройках. Поскольку шифр Виженера предложил значительный прогресс в безопасности, он стал популярным в этот период и широко распространился к концу 1700-х годов.

Неформально говоря, схема шифрования работает следующим образом:

1. Выберите слово из нескольких букв в качестве приватного ключа
2. Для любого сообщения примените шифр сдвига к каждой букве сообщения, используя соответствующую букву в ключевом слове в качестве сдвига
3. Если вы прошли через ключевое слово, но еще не зашифровали весь открытый текст, снова примените буквы ключевого слова как шифр сдвига к соответствующим буквам в оставшейся части текста
4. Продолжайте этот процесс, пока весь сообщение не будет зашифровано

Чтобы проиллюстрировать, предположим, что ваш приватный ключ - GOLD, и вы хотите зашифровать сообщение "CRYPTOGRAPHY". В этом случае вы бы действовали следующим образом согласно шифру Виженера:

- c<sub>0</sub> = [(2 + 6) Mod 26] = 8 = I
- c<sub>1</sub> = [(17 + 14) Mod 26] = 5 = F
- c<sub>2</sub> = [(24 + 11) Mod 26] = 9 = J
- c<sub>3</sub> = [(15 + 3) Mod 26] = 18 = S
- c<sub>4</sub> = [(19 + 6) Mod 26] = 25 = Z
- c<sub>5</sub> = [(14 + 14) Mod 26] = 2 = C
- c<sub>6</sub> = [(6 + 11) Mod 26] = 17 = R
- c<sub>7</sub> = [(17 + 3) Mod 26] = 20 = U
- c<sub>8</sub> = [(0 + 6) Mod 26] = 6 = G
- c<sub>9</sub> = [(15 + 14) Mod 26] = 3 = D
- c<sub>10</sub> = [(7 + 11) Mod 26] = 18 = S
- c<sub>11</sub> = [(24 + 3) Mod 26] = 1 = B
- c = "IFJSZCRUGDSB"

Еще один известный пример потокового шифра - это **одноразовый блокнот**. С одноразовым блокнотом вы просто создаете строку случайных битов такой же длины, как и сообщение открытого текста, и производите шифротекст с помощью операции XOR. Таким образом, приватный ключ и ключевой поток эквивалентны при использовании одноразового блокнота.

В то время как шифр сдвига и шифр Виженера очень ненадежны в современном мире, одноразовый блокнот очень безопасен при правильном использовании. Вероятно, самое известное применение одноразового блокнота было, по крайней мере до 1980-х годов, для **горячей линии Вашингтон-Москва**.

Горячая линия - это прямая связь между Вашингтоном и Москвой для срочных дел, которая была установлена после Карибского кризиса. Технология для нее трансформировалась на протяжении годов. В настоящее время она включает прямой оптоволоконный кабель, а также две спутниковые связи (для резервирования), которые позволяют отправлять электронные письма и текстовые сообщения. Связь заканчивается в различных местах в США. Известными конечными точками являются Пентагон, Белый дом и гора Рейвен Рок. Вопреки популярному мнению, горячая линия никогда не включала телефоны.

По сути, схема одноразового блокнота работала следующим образом. И Вашингтон, и Москва имели два набора случайных чисел. Один набор случайных чисел, созданный русскими, относился к шифрованию и дешифрованию любых сообщений на русском языке. Один набор случайных чисел, созданный американцами, относился к шифрованию и дешифрованию любых сообщений на английском языке. Время от времени больше случайных чисел доставлялось другой стороне доверенными курьерами.

Таким образом, Вашингтон и Москва могли тайно общаться, используя эти случайные числа для создания одноразовых блокнотов. Каждый раз, когда вам нужно было общаться, вы использовали следующую часть случайных чисел для вашего сообщения.

Несмотря на высокую степень безопасности, одноразовый блокнот сталкивается с значительными практическими ограничениями: ключ должен быть такой же длины, как и сообщение, и ни одна часть одноразового блокнота не может быть использована повторно. Это означает, что вам нужно отслеживать, где вы находитесь в одноразовом блокноте, хранить огромное количество битов и время от времени обмениваться случайными битами с вашими контрагентами. В результате, одноразовый блокнот на практике используется нечасто.

Вместо этого, в практике чаще используются **псевдослучайные потоковые шифры**. Salsa20 и тесно связанный с ним вариант ChaCha являются примерами часто используемых псевдослучайных потоковых шифров.

С этими псевдослучайными потоковыми шифрами вы сначала случайным образом выбираете ключ K, который короче длины открытого текста. Такой случайный ключ K обычно создается нашим компьютером на основе непредсказуемых данных, которые он собирает со временем, таких как время между сетевыми сообщениями, движения мыши и так далее.
Этот случайный ключ K затем вставляется в алгоритм расширения, который создает псевдослучайный ключевой поток такой же длины, как и сообщение. Вы можете точно указать, какой длины должен быть ключевой поток (например, 500 бит, 1000 бит, 1200 бит, 29 117 бит и так далее).
Псевдослучайный ключевой поток выглядит *как будто* он был выбран совершенно случайно из множества всех строк той же длины. Следовательно, шифрование с использованием псевдослучайного ключевого потока выглядит так, как будто оно было выполнено с использованием одноразового блокнота. Но это, конечно, не так.

Поскольку наш секретный ключ короче ключевого потока и наш алгоритм расширения должен быть детерминированным, чтобы процесс шифрования/дешифрования работал, не каждый ключевой поток данной длины мог бы получиться в результате нашей операции расширения.

Предположим, например, что наш секретный ключ имеет длину 128 бит и что мы можем вставить его в алгоритм расширения, чтобы создать гораздо более длинный ключевой поток, скажем, 2500 бит. Поскольку наш алгоритм расширения должен быть детерминированным, наш алгоритм может выбрать максимум 1/2<sup>128</sup> строк длиной 2500 бит. Таким образом, такой ключевой поток никогда не мог бы быть выбран полностью случайно из всех строк той же длины.

Наше определение потокового шифра имеет два аспекта: (1) ключевой поток такой же длины, как открытый текст, генерируется с помощью секретного ключа; и (2) этот ключевой поток комбинируется с открытым текстом, обычно через операцию XOR, для создания шифртекста.

Иногда люди определяют условие (1) более строго, утверждая, что ключевой поток должен быть специфически псевдослучайным. Это означает, что ни шифр сдвига, ни одноразовый блокнот не будут считаться потоковыми шифрами.

На мой взгляд, более широкое определение условия (1) предоставляет более простой способ организации схем шифрования. Кроме того, это означает, что нам не нужно переставать называть определенную схему шифрования потоковым шифром только потому, что мы узнали, что она на самом деле не полагается на псевдослучайные ключевые потоки.

## Блочные шифры
<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

Первый способ, которым обычно понимается **блочный шифр**, - это как что-то более примитивное, чем потоковый шифр: основной алгоритм, который выполняет преобразование с сохранением длины на строке подходящей длины с помощью ключа. Этот алгоритм может использоваться для создания схем шифрования и, возможно, других типов криптографических схем.

Часто блочный шифр может принимать входные строки различной длины, такие как 64, 128 или 256 бит, а также ключи различной длины, такие как 128, 192 или 256 бит. Хотя некоторые детали алгоритма могут изменяться в зависимости от этих переменных, основной алгоритм не меняется. Если бы это было не так, мы говорили бы о двух разных блочных шифрах. Заметьте, что использование терминологии "основной алгоритм" здесь такое же, как и для схем шифрования.

Иллюстрация работы блочного шифра может быть видна на *Рисунке 4* ниже. Сообщение M длиной L и ключ K служат входными данными для блочного шифра. Он выдает сообщение M’ длиной L. Ключ не обязательно должен быть той же длины, что и M и M’, для большинства блочных шифров.

*Рисунок 4: Блочный шифр*

![Рисунок 4: Блочный шифр](assets/Figure4-4.webp "Рисунок 4: Блочный шифр")
Блочный шифр сам по себе не является схемой шифрования. Однако блочный шифр может использоваться с различными **режимами работы** для создания разных схем шифрования. Режим работы просто добавляет некоторые дополнительные операции вне блочного шифра.
Чтобы проиллюстрировать, как это работает, предположим, что блочный шифр (BC) требует 128-битную входную строку и 128-битный закрытый ключ. На рисунке 5 ниже показано, как этот блочный шифр может использоваться с **режимом электронной кодовой книги** (**ECB режим**) для создания схемы шифрования. (Многоточия справа указывают на то, что вы можете повторять этот шаблон столько, сколько необходимо).

*Рисунок 5: Блочный шифр с режимом ECB*

![Рисунок 5: Блочный шифр с режимом ECB](assets/Figure4-5.webp "Рисунок 5: Блочный шифр с режимом ECB")

Процесс шифрования электронной кодовой книги с блочным шифром следующий. Проверьте, можно ли разделить ваше исходное сообщение на блоки по 128 бит. Если нет, добавьте **дополнение** к сообщению, чтобы результат мог быть равномерно разделен на блоки размером 128 бит. Это ваши данные, используемые для процесса шифрования.

Теперь разделите данные на части по 128-битным строкам (M<sub>1</sub>, M<sub>2</sub>, M<sub>3</sub> и так далее). Пропустите каждую 128-битную строку через блочный шифр с вашим 128-битным ключом, чтобы получить 128-битные блоки шифртекста (C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub> и так далее). Эти блоки, объединенные вместе, формируют полный шифртекст.

Расшифровка - это просто обратный процесс, хотя получателю действительно нужен какой-то узнаваемый способ удалить любое дополнение из расшифрованных данных, чтобы восстановить исходное сообщение.

Хотя это относительно просто, блочный шифр с режимом электронной кодовой книги имеет недостатки в безопасности. Это связано с тем, что он приводит к **детерминированному шифрованию**. Любые две идентичные 128-битные строки данных шифруются абсолютно одинаково. Эту информацию можно использовать.

Вместо этого, любая схема шифрования, построенная на основе блочного шифра, должна быть **вероятностной**: то есть шифрование любого сообщения M или любого конкретного фрагмента M, как правило, должно приводить к разному результату каждый раз.<sup>[5](#footnote5)</sup>

**Режим цепочки блоков шифрования** (**CBC режим**) вероятно, является наиболее распространенным режимом, используемым с блочным шифром. Комбинация, если сделана правильно, создает вероятностную схему шифрования. Ниже на рисунке 6 вы можете увидеть изображение этого режима работы.

*Рисунок 6: Блочный шифр с режимом CBC*

![Рисунок 6: Блочный шифр с режимом CBC](assets/Figure4-6.webp "Рисунок 6: Блочный шифр с режимом CBC")

Предположим, размер блока снова составляет 128 бит. Так что для начала вам снова нужно убедиться, что ваше исходное текстовое сообщение получает необходимое дополнение.

Затем вы выполняете операцию XOR первой 128-битной части вашего исходного текста с **вектором инициализации** размером 128 бит. Результат помещается в блочный шифр для получения шифртекста первого блока. Для второго блока из 128 бит вы сначала выполняете операцию XOR исходного текста с шифртекстом из первого блока, прежде чем вставить его в блочный шифр. Вы продолжаете этот процесс, пока не зашифруете все ваше исходное сообщение.

По завершении вы отправляете зашифрованное сообщение вместе с незашифрованным вектором инициализации получателю. Получателю необходимо знать вектор инициализации, иначе он не сможет расшифровать шифртекст.
Эта конструкция намного безопаснее, чем режим электронной кодовой книги, при правильном использовании. В первую очередь, вы должны убедиться, что вектор инициализации является случайной или псевдослучайной строкой. Кроме того, вы должны использовать разный вектор инициализации каждый раз при использовании этой схемы шифрования.
Другими словами, ваш вектор инициализации должен быть случайным или псевдослучайным nonce, где **nonce** означает "число, используемое только один раз". Если вы будете придерживаться этой практики, то режим CBC с блочным шифром обеспечит, что любые два идентичных блока открытого текста будут зашифрованы по-разному каждый раз.

Наконец, давайте обратим наше внимание на **режим обратной связи по выходу** (**OFB mode**). Вы можете увидеть изображение этого режима на *Рисунке 7*.

*Рисунок 7: Блочный шифр с режимом OFB*

![Рисунок 7: Блочный шифр с режимом OFB](assets/Figure4-7.webp "Рисунок 7: Блочный шифр с режимом OFB")

В режиме OFB вы также выбираете вектор инициализации. Но здесь, для первого блока, вектор инициализации напрямую вставляется в блочный шифр вместе с вашим ключом. Полученные 128 бит затем рассматриваются как ключевой поток. Этот ключевой поток складывается по модулю 2 (XOR) с открытым текстом для получения шифртекста блока. Для последующих блоков вы используете ключевой поток из предыдущего блока в качестве входа в блочный шифр и повторяете шаги.

Если вы внимательно посмотрите, то увидите, что здесь, с использованием блочного шифра в режиме OFB, на самом деле был создан потоковый шифр. Вы генерируете части ключевого потока размером 128 бит до тех пор, пока не получите длину открытого текста (отбрасывая биты, которые вам не нужны из последней части ключевого потока размером 128 бит). Затем вы складываете по модулю 2 (XOR) ключевой поток с вашим сообщением открытого текста, чтобы получить шифртекст.

В предыдущем разделе о потоковых шифрах я утверждал, что вы производите ключевой поток с помощью закрытого ключа. Точнее, он не обязательно должен быть создан только с закрытым ключом. Как вы можете видеть в режиме OFB, ключевой поток производится с поддержкой как закрытого ключа, так и вектора инициализации.

Обратите внимание, что, как и в случае с режимом CBC, важно выбирать псевдослучайный или случайный nonce для вектора инициализации каждый раз, когда вы используете блочный шифр в режиме OFB. В противном случае одна и та же 128-битная строка сообщения, отправленная в разных сообщениях, будет зашифрована одинаково. Это один из способов создания вероятностного шифрования с потоковым шифром.

Некоторые потоковые шифры используют только закрытый ключ для создания ключевого потока. Для этих потоковых шифров важно, чтобы вы использовали случайный nonce для выбора закрытого ключа для каждого случая коммуникации. В противном случае результаты шифрования с этими потоковыми шифрами также будут детерминированными, что приведет к проблемам безопасности.

Самым популярным современным блочным шифром является **шифр Рейндал**. Он был победителем среди пятнадцати предложений на конкурсе, проведенном Национальным институтом стандартов и технологий (NIST) между 1997 и 2000 годами с целью замены старого стандарта шифрования, **стандарта шифрования данных** (**DES**).
Шифр Рейндал может использоваться с различными спецификациями длин ключей и размеров блоков, а также в разных режимах работы. Комитет конкурса NIST принял ограниченную версию шифра Рейндал — а именно, ту, которая требует размеров блоков и длин ключей 128 бит, 192 бита или 256 бит — в качестве части **стандарта продвинутого шифрования** (**AES**). Это действительно основной стандарт для приложений симметричного шифрования. Он настолько безопасен, что даже АНБ, по-видимому, готово использовать его с 256-битными ключами для секретных документов.<sup>[6](#footnote6)</sup>
Блочный шифр AES будет подробно объяснен в *Главе 5*.

## Разъяснение путаницы
<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

Путаница в отличии блочных шифров от потоковых шифров возникает, потому что иногда люди понимают термин блочный шифр как относящийся специально к *блочному шифру с режимом шифрования блока*.

Рассмотрим режимы ECB и CBC из предыдущего раздела. Эти режимы конкретно требуют, чтобы данные для шифрования делились на размер блока (что может потребовать использования дополнения для исходного сообщения). Кроме того, данные в этих режимах также обрабатываются блочным шифром напрямую (а не просто комбинируются с результатом операции блочного шифра, как в режиме OFB).

Следовательно, альтернативно, вы можете определить **блочный шифр** как любую схему шифрования, которая работает с фиксированными блоками сообщения за раз (где любой блок должен быть длиннее байта, иначе он превращается в потоковый шифр). И данные для шифрования, и шифртекст должны равномерно делиться на этот размер блока. Обычно размер блока составляет 64, 128, 192 или 256 бит. В отличие от этого, потоковый шифр может шифровать любые сообщения блоками по одному биту или байту за раз.

С этим более конкретным пониманием блочного шифра, вы действительно можете утверждать, что современные схемы шифрования являются либо потоковыми, либо блочными шифрами. Отныне я буду использовать термин блочный шифр в более общем смысле, если не указано иное.

Обсуждение режима OFB в предыдущем разделе также поднимает еще один интересный момент. Некоторые потоковые шифры созданы из блочных шифров, как Рейндал с OFB. Некоторые, как Salsa20 и ChaCha, не созданы из блочных шифров. Последние можно назвать **примитивными потоковыми шифрами**. (На самом деле нет стандартизированного термина для обозначения таких потоковых шифров.)

Когда люди говорят о преимуществах и недостатках потоковых и блочных шифров, они обычно сравнивают примитивные потоковые шифры с схемами шифрования на основе блочных шифров.

Хотя вы всегда можете легко построить потоковый шифр из блочного шифра, обычно очень сложно создать какой-либо конструкт с режимом шифрования блока (например, с режимом CBC) из примитивного потокового шифра.

Из этого обсуждения вы теперь должны понимать *Рисунок 8*. Он дает обзор схем симметричного шифрования. Мы используем три типа схем шифрования: примитивные потоковые шифры, потоковые шифры на основе блочных шифров и блочные шифры в режиме блока (также называемые "блочными шифрами" на диаграмме).

*Рисунок 8: Обзор схем симметричного шифрования*

![Рисунок 8: Обзор схем симметричного шифрования](assets/Figure4-8.webp "Рисунок 8: Обзор схем симметричного шифрования")


## Коды аутентификации сообщений
<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>
Шифрование связано с секретностью. Но криптография также затрагивает более широкие темы, такие как целостность сообщений, подлинность и невозможность отказа. Так называемые **коды аутентификации сообщений** (MACs) представляют собой симметричные криптографические схемы, поддерживающие подлинность и целостность в коммуникациях.

Почему в коммуникации нужно что-то кроме секретности? Предположим, что Боб отправляет Алисе сообщение, используя практически непробиваемое шифрование. Любой атакующий, перехвативший это сообщение, не сможет получить значимых сведений о его содержании. Однако атакующий все еще имеет как минимум два других вектора атаки:

1. Она может перехватить шифротекст, изменить его содержимое и отправить измененный шифротекст Алисе.
2. Она может полностью заблокировать сообщение Боба и отправить свой собственный созданный шифротекст.

В обоих этих случаях атакующий может не иметь никаких сведений о содержимом шифротекстов (1) и (2). Но она все равно может нанести значительный ущерб таким образом. Вот здесь и становятся важны коды аутентификации сообщений.

Коды аутентификации сообщений определяются как симметричные криптографические схемы с тремя алгоритмами: алгоритм генерации ключа, алгоритм генерации тега и алгоритм верификации. Безопасный MAC обеспечивает, что теги являются **экзистенциально неподделываемыми** для любого атакующего, то есть они не могут успешно создать тег для сообщения, который проходит проверку, если у них нет приватного ключа.

Боб и Алиса могут бороться с манипуляцией конкретного сообщения, используя MAC. Предположим на момент, что им не важна секретность. Они только хотят убедиться, что сообщение, полученное Алисой, действительно от Боба и не было изменено никаким образом.

Процесс изображен на *Рисунке 9*. Чтобы использовать MAC, они сначала генерируют приватный ключ K, который является общим между ними. Боб создает тег T для сообщения, используя приватный ключ K. Затем он отправляет сообщение, а также тег сообщения Алисе. Она может затем проверить, что тег действительно создан Бобом, запустив через алгоритм верификации приватный ключ, сообщение и тег.

*Рисунок 9: Обзор симметричных схем шифрования*

![Рисунок 9: Обзор симметричных схем шифрования](assets/Figure4-9.webp "Рисунок 9: Обзор симметричных схем шифрования")

Благодаря экзистенциальной неподделываемости, атакующий не может изменить сообщение M никаким образом или создать свое собственное сообщение с действительным тегом. Это так, даже если атакующий наблюдает за тегами многих сообщений между Бобом и Алисой, которые используют один и тот же приватный ключ. В лучшем случае, атакующий может помешать Алисе получить сообщение M (проблема, с которой криптография не может справиться).

MAC гарантирует, что сообщение действительно было создано Бобом. Эта подлинность автоматически подразумевает целостность сообщения — то есть, если Боб создал какое-то сообщение, то, следовательно, оно не было изменено никаким образом атакующим. Таким образом, с этого момента любая забота об аутентификации должна автоматически подразумевать заботу о целостности.

Хотя я провел различие между подлинностью и целостностью сообщений в своем обсуждении, также обычно эти термины используются как синонимы. Тогда они относятся к идее сообщений, которые были созданы конкретным отправителем и не были изменены никаким образом. В этом духе коды аутентификации сообщений часто также называют **кодами целостности сообщений**.

## Аутентифицированное шифрование
<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>
Обычно вы хотите гарантировать как секретность, так и подлинность в коммуникации, и поэтому схемы шифрования и схемы MAC обычно используются вместе. 
**Схема аутентифицированного шифрования** — это схема, которая сочетает в себе шифрование с MAC на высоком уровне безопасности. В частности, она должна соответствовать стандартам экзистенциальной нефальсифицируемости, а также очень строгому понятию секретности, а именно такому, которое устойчиво к **атакам с выбранным шифротекстом**.<sup>[7](#footnote7)</sup>

Для того чтобы схема шифрования была устойчива к атакам с выбранным шифротекстом, она должна соответствовать стандартам **немодифицируемости**: то есть любое изменение шифротекста атакующим должно привести либо к недействительному шифротексту, либо к шифротексту, который расшифровывается в текст, не имеющий никакого отношения к оригинальному.<sup>[8](#footnote8)</sup>

Поскольку схема аутентифицированного шифрования обеспечивает, что шифротекст, созданный атакующим, всегда является недействительным (поскольку тег не будет проверен), она соответствует стандартам устойчивости к атакам с выбранным шифротекстом. Интересно, что можно доказать, что схема аутентифицированного шифрования всегда может быть создана из комбинации экзистенциально нефальсифицируемого MAC и схемы шифрования, которая соответствует менее строгому понятию безопасности, известному как **безопасность от атак с выбранным открытым текстом**.

Мы не будем углубляться во все детали создания схем аутентифицированного шифрования. Но важно знать две детали их конструкции.

Во-первых, схема аутентифицированного шифрования сначала обрабатывает шифрование, а затем создает тег сообщения на шифротексте. Оказывается, что другие подходы, такие как объединение шифротекста с тегом на открытом тексте, или сначала создание тега, а затем шифрование как открытого текста, так и тега, являются небезопасными. Кроме того, для обеих операций используются свои собственные случайно выбранные секретные ключи, иначе ваша безопасность серьезно скомпрометирована.

Упомянутый принцип применим более общим образом: *вы всегда должны использовать различные ключи при комбинировании базовых криптографических схем*.

Схема аутентифицированного шифрования изображена на *Рисунке 10*. Боб сначала создает шифротекст C из сообщения M, используя случайно выбранный ключ K<sub>C</sub>. Затем он создает тег сообщения T, пропуская шифротекст и другой случайно выбранный ключ K<sub>T</sub> через алгоритм генерации тега. И шифротекст, и тег сообщения отправляются Алисе.

Теперь Алиса сначала проверяет, действителен ли тег, учитывая шифротекст C и ключ K<sub>T</sub>. Если действителен, она может затем расшифровать сообщение, используя ключ K<sub>C</sub>. Таким образом, она уверена в очень строгом понятии секретности в их коммуникациях, а также знает, что сообщение было создано Бобом.

*Рисунок 10: Схема аутентифицированного шифрования*

![Рисунок 10: Схема аутентифицированного шифрования](assets/Figure4-10.webp "Рисунок 10: Схема аутентифицированного шифрования")

Как создаются MAC? Хотя MAC можно создать различными методами, общим и эффективным способом их создания является использование криптографических хеш-функций.

Мы более подробно рассмотрим криптографические хеш-функции в *Главе 6*. Пока просто знайте, что **хеш-функция** — это эффективно вычисляемая функция, которая принимает на вход данные произвольного размера и выдает выходные данные фиксированной длины. Например, популярная хеш-функция **SHA-256** (алгоритм безопасного хеширования 256) всегда генерирует 256-битный выход независимо от размера входных данных. Некоторые хеш-функции, такие как SHA-256, имеют полезные применения в криптографии.
Наиболее распространенным типом тега, создаваемым с использованием криптографической хеш-функции, является **хеш-основанный код аутентификации сообщений** (HMAC). Процесс показан на *Рисунке 11*. Сторона создает два различных ключа из приватного ключа K, внутренний ключ K<sub>1</sub> и внешний ключ K<sub>2</sub>. Затем открытый текст M или шифртекст C хешируется вместе с внутренним ключом. Полученный результат T' затем хешируется с внешним ключом для создания тега сообщения T.
Существует палитра хеш-функций, которые можно использовать для создания HMAC. Наиболее часто используемой хеш-функцией является SHA-256.

*Рисунок 11: HMAC*

![Рисунок 11: HMAC](assets/Figure4-11.webp "Рисунок 11: HMAC")


## Безопасные сессии связи
<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

Предположим, что две стороны находятся в сессии связи, и они отправляют друг другу множество сообщений.

Схема аутентифицированного шифрования позволяет получателю сообщения проверить, что оно было создано его партнером в сессии связи (при условии, что приватный ключ не был скомпрометирован). Это работает достаточно хорошо для одного сообщения. Однако, как правило, две стороны отправляют сообщения туда и обратно в сессии связи. И в такой ситуации простая схема аутентифицированного шифрования, описанная в предыдущем разделе, не обеспечивает достаточной безопасности.

Основная причина заключается в том, что схема аутентифицированного шифрования не дает гарантий, что сообщение действительно было отправлено агентом, который его создал в рамках сессии связи. Рассмотрим следующие три вектора атаки:

1. **Атака повторного воспроизведения**: Атакующий повторно отправляет шифртекст и тег, которые он перехватил между двумя сторонами в более ранний момент.
2. **Атака изменения порядка**: Атакующий перехватывает два сообщения в разное время и отправляет их получателю в обратном порядке.
3. **Атака отражения**: Атакующий наблюдает за сообщением, отправленным от A к B, и также отправляет это сообщение A.

Хотя атакующий не имеет знаний о шифртексте и не может создавать поддельные шифртексты, вышеупомянутые атаки все же могут нанести значительный ущерб связи.

Предположим, например, что конкретное сообщение между двумя сторонами включает перевод финансовых средств. Атака повторного воспроизведения может привести к повторному переводу средств. Простая схема аутентифицированного шифрования не имеет защиты от таких атак.

К счастью, эти виды атак могут быть легко предотвращены в сессии связи с использованием **идентификаторов** и **относительных временных индикаторов**.

Идентификаторы могут быть добавлены к открытому тексту сообщения перед шифрованием. Это предотвратит любые атаки отражения. Относительный временной индикатор может, например, быть порядковым номером в определенной сессии связи. Каждая сторона добавляет порядковый номер к сообщению перед шифрованием, так что получатель знает, в каком порядке сообщения были отправлены. Это исключает возможность атак изменения порядка. Также это исключает атаки повторного воспроизведения. Любое сообщение, которое атакующий отправляет дальше по линии, будет иметь старый порядковый номер, и получатель будет знать, что не стоит обрабатывать сообщение снова.

Чтобы проиллюстрировать, как работают безопасные сессии связи, предположим снова Алису и Боба. Они отправляют в общей сложности четыре сообщения туда и обратно. Вы можете увидеть, как работает схема аутентифицированного шифрования с идентификаторами и порядковыми номерами ниже на *Рисунке 11*.
Сессия связи начинается с того, что Боб отправляет Алисе шифротекст C<sub>0,B</sub> с меткой сообщения T<sub>0,B</sub>. Шифротекст содержит сообщение, а также идентификатор (BOB) и порядковый номер (0). Метка T<sub>0,B</sub> создается для всего шифротекста. В последующих коммуникациях Алиса и Боб поддерживают этот протокол, обновляя поля по мере необходимости.
*Рисунок 12: Безопасная сессия связи*

![Рисунок 12: Безопасная сессия связи](assets/Figure4-12.webp "Рисунок 12: Безопасная сессия связи")


## Примечания
<chapterId>b96d38dd-c9cb-56a7-8764-4af8526bc63f</chapterId>

[^1]: Согласно Светонию, в военной связи Юлием Цезарем использовался шифр сдвига с постоянным ключом равным 3. Таким образом, A всегда становилась D, B всегда E, C всегда F и так далее. Эта конкретная версия шифра сдвига, таким образом, стала известна как **Шифр Цезаря** (хотя в современном понимании слова это не совсем шифр, так как значение ключа постоянно). Шифр Цезаря мог быть безопасен в первом веке до нашей эры, если враги Рима были очень незнакомы с шифрованием. Но в современные времена это явно не было бы очень безопасной схемой [^1].

[^2]: Джонатан Кац и Йехуда Линделл, *Введение в современную криптографию*, CRC Press (Бока-Ратон, Флорида: 2015), стр. 7f [^2].

[^3]: Эрик Реймонд, “Собор и базар”, доклад был представлен на Linux Kongress, Вюрцбург, Германия (27 мая 1997 года). Существует ряд последующих версий, а также книга. Мои цитаты из страницы 30 книги: Эрик Реймонд, *Собор и базар: Размышления о Linux и Open Source случайного революционера*, пересмотренное издание. (2001), O’Reilly: Себастополь, Калифорния [^3].

[^4]: Крипто Музей, "Горячая линия Вашингтон-Москва", 2013, доступно на [Crypto Museum](https://www.cryptomuseum.com/crypto/hotline/index.htm) [^4].

[^5]: Важность вероятностного шифрования впервые была подчеркнута Шафи Голдвассер и Сильвио Микали, “Вероятностное шифрование”, *Журнал Co [^5].



# RC4 и AES
<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

В этой главе мы обсудим детали схемы шифрования с современным потоковым шифром, RC4 (или "шифр Ривеста 4"), и современным блочным шифром, AES. Хотя шифр RC4 вышел из употребления как метод шифрования, AES является стандартом для современного симметричного шифрования. Эти два примера должны дать лучшее представление о том, как работает симметричное шифрование изнутри.


## Потоковый шифр RC4
<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>
Чтобы понять, как работают современные псевдослучайные потоковые шифры, я сосредоточусь на потоковом шифре RC4. Это псевдослучайный потоковый шифр, который использовался в протоколах безопасности беспроводных точек доступа WEP и WAP, а также в TLS. Поскольку у RC4 обнаружено множество слабостей, он вышел из употребления. Фактически, Инженерная группа Интернета (Internet Engineering Task Force) теперь запрещает использование наборов RC4 клиентскими и серверными приложениями во всех случаях TLS.<sup>[3](#footnote3)</sup> Тем не менее, он хорошо подходит в качестве примера для иллюстрации работы примитивного потокового шифра.
Для начала я покажу, как зашифровать текстовое сообщение с помощью упрощенного шифра RC4. Предположим, наше текстовое сообщение — «SOUP». Шифрование с нашим упрощенным шифром RC4, следовательно, происходит в четыре этапа.

### Шаг 1

Сначала определите массив S с S[0] = 0 до S[7] = 7. Здесь массив просто означает изменяемую коллекцию значений, организованных по индексу, также называемую списком в некоторых языках программирования (например, Python). В данном случае индекс идет от 0 до 7, а значения также идут от 0 до 7. Таким образом, S выглядит следующим образом:

- S = [0,1,2,3,4,5,6,7]

Здесь значения не являются числами ASCII, а десятичными представлениями значений 1-байтовых строк. Так что значение 2 будет равно 0000 0011. Длина массива S, таким образом, составляет 8 байт.

### Шаг 2

Во-вторых, определите массив ключа K длиной 8 байт, выбрав ключ длиной от 1 до 8 байт (доли байт недопустимы). Поскольку каждый байт состоит из 8 бит, вы можете выбрать любое число от 0 до 255 для каждого байта вашего ключа.

Предположим, мы выбираем наш ключ k как [14,48,9], так что его длина составляет 3 байта. Каждый индекс нашего массива ключей, таким образом, устанавливается в соответствии с десятичным значением для этого конкретного элемента ключа, по порядку. Если вы прошли через весь ключ, начните снова с начала, пока не заполните 8 слотов массива ключей. Следовательно, наш массив ключей выглядит следующим образом:

- K = [14,48,9,14,48,9,14,48]

### Шаг 3

В-третьих, мы преобразуем массив S с использованием массива ключей K в процессе, известном как планирование ключа. Процесс выглядит следующим образом в псевдокоде:

- Создайте переменные j и i
- Установите переменную j = 0
- Для каждого i от 0 до 7:
	- Установите j = j + S[i] + K[i] mod 8
	- Поменяйте местами S[i] и S[j]

Преобразование массива S представлено *Таблицей 1*.

Для начала вы можете увидеть исходное состояние S как [0,1,2,3,4,5,6,7] с начальным значением 0 для j. Это будет преобразовано с использованием массива ключей [14,48,9,14,48,9,14,48].
Цикл for начинается с i = 0. Согласно нашему псевдокоду выше, новое значение j становится 6 (j = j + S[0] + K[0] mod 8 = 0 + 0 + 14 mod 8 = 6 mod 8). После обмена S[0] и S[6], состояние S после 1 раунда становится [6,1,2,3,4,5,0,7]. 
В следующей строке, i = 1. Проходя через цикл for снова, j получает значение 7 (j = j + S[1] + K[1] mod 8 = 6 + 1 + 48 mod 8 = 55 mod 8 = 7 mod 8). Обмен S[1] и S[7] из текущего состояния S, [6,1,2,3,4,5,0,7], приводит к [6,7,2,3,4,5,0,1] после 2 раунда.

Мы продолжаем этот процесс до тех пор, пока не получим конечную строку внизу для массива S, [6,4,1,0,3,7,5,2].

*Таблица 1: Таблица планирования ключей*

![Таблица 1: Таблица планирования ключей](assets/Table5-1.webp "Таблица 1: Таблица планирования ключей")

### Шаг 4

На четвертом шаге мы производим ключевой поток. Это псевдослучайная строка длиной, равной сообщению, которое мы хотим отправить. Это то, что будет использоваться для шифрования исходного сообщения «SOUP». Поскольку ключевой поток должен быть такой же длины, как сообщение, нам нужен один, который имеет 4 байта.

Ключевой поток производится следующим псевдокодом:

- Создайте переменные j, i и t
- Установите j = 0
- Для каждого i из открытого текста, начиная с i = 1 и до i = 4, каждый байт ключевого потока производится следующим образом:
    - j = j + S[i] mod 8
	- Поменяйте местами S[i] и S[j]
	- t = S[i] + S[j] mod 8
	- i-й байт ключевого потока = S[t]

Вы можете следить за расчетами в *Таблице 2*.

Исходное состояние S = S = [6,4,1,0,3,7,5,2]. Установив i = 1, значение j становится 4 (j = j + S[i] mod 8 = 0 + 4 mod 8 = 4). Затем мы меняем местами S[1] и S[4], чтобы получить преобразование S во второй строке, [6,3,1,0,4,7,5,2]. Значение t тогда равно 7 (t = S[i] + S[j] mod 8 = 3 + 4 mod 8 = 7). Наконец, байт для ключевого потока тогда равен S[7], или 2.

Затем мы можем продолжить производство других байтов, пока у нас не будет следующих четырех байтов: 2, 6, 3 и 7. Каждый из этих байтов затем может быть использован для шифрования каждой буквы открытого текста, "SOUP".
Для начала, используя таблицу ASCII, мы видим, что слово "SOUP", закодированное десятичными значениями базовых строк байтов, это "83 79 85 80". Комбинация с ключевым потоком "2 6 3 2" дает "85 85 88 82", что остается неизменным после операции модуля 256. В ASCII шифротекст "85 85 88 82" равен "UUXR". 
Что произойдет, если слово для шифрования будет длиннее массива S? В этом случае массив S просто продолжает трансформироваться таким образом, как показано выше, для каждого байта i открытого текста, пока количество байтов в ключевом потоке не станет равным количеству букв в открытом тексте.

*Таблица 2: Генерация ключевого потока*

![Таблица 2: Генерация ключевого потока](assets/Table5-2.webp "Таблица 2: Генерация ключевого потока")

Пример, который мы только что обсудили, является лишь упрощенной версией потокового шифра RC4. Фактический потоковый шифр RC4 имеет массив S длиной 256 байтов, а не 8 байтов, и ключ, который может быть от 1 до 256 байтов, а не от 1 до 8 байтов. Массив ключей и ключевые потоки, таким образом, все производятся, учитывая длину массива S в 256 байтов. Расчеты становятся невероятно сложнее, но принципы остаются теми же. Используя тот же ключ, [14,48,9], со стандартным шифром RC4, открытое сообщение "SOUP" шифруется как 67 02 ed df в шестнадцатеричном формате.

Потоковый шифр, в котором ключевой поток обновляется независимо от открытого текста или шифротекста, является **синхронным потоковым шифром**. Ключевой поток зависит только от ключа. Ясно, что RC4 является примером синхронного потокового шифра, поскольку ключевой поток не имеет отношения к открытому тексту или шифротексту. Все наши примитивные потоковые шифры, упомянутые в предыдущей главе, включая шифр сдвига, шифр Виженера и одноразовый блокнот, также были синхронного типа.

В отличие от этого, **асинхронный потоковый шифр** имеет ключевой поток, который производится как ключом, так и предыдущими элементами шифротекста. Этот тип шифра также называется **самосинхронизирующимся шифром**.

Важно, что ключевой поток, произведенный с помощью RC4, следует рассматривать как одноразовый блокнот, и вы не можете произвести ключевой поток точно таким же образом в следующий раз. Вместо изменения ключа каждый раз, практическое решение заключается в сочетании ключа с nonce для производства байтового потока.

## AES с 128-битным ключом
<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

Как упоминалось в предыдущей главе, Национальный институт стандартов и технологий (NIST) провел конкурс между 1997 и 2000 годами, чтобы определить новый стандарт симметричного шифрования. Шифр Rijndael оказался победителем. Название является игрой слов на именах бельгийских создателей, Винсента Реймена и Йоана Даемена.

Шифр Rijndael является блочным шифром, что означает наличие основного алгоритма, который может использоваться с различными спецификациями для длин ключей и размеров блоков. Таким образом, его можно использовать с различными режимами работы для построения схем шифрования.
Комитет конкурса NIST принял ограниченную версию шифра Рейндал, а именно ту, которая требует размер блока в 128 бит и длину ключа 128 бит, 192 бита или 256 бит, в качестве части стандарта продвинутого шифрования. Эта ограниченная версия шифра Рейндал также может использоваться в нескольких режимах работы. Спецификация стандарта известна как Стандарт Продвинутого Шифрования (AES).

Чтобы показать, как работает шифр Рейндал, ядро AES, я продемонстрирую процесс шифрования с 128-битным ключом. Размер ключа влияет на количество раундов для каждого блока шифрования. Для ключей 128 бит требуется 10 раундов. Для 192 и 256 бит это было бы 12 и 14 раундов соответственно.

Кроме того, я предполагаю, что AES используется в режиме ECB. Это делает изложение немного проще и не имеет значения для алгоритма Рейндал. Надо быть уверенным, режим ECB на практике не является безопасным, поскольку приводит к детерминированному шифрованию. Наиболее часто используемый безопасный режим с AES - это CBC.

Давайте назовем ключ K<sub>0</sub>. Таким образом, конструкция с вышеуказанными параметрами выглядит как на Рисунке 1, где M<sub>i</sub> обозначает часть открытого текста размером 128 бит и C<sub>i</sub> - часть шифртекста размером 128 бит. К открытому тексту последнего блока добавляется дополнение, если текст не может быть равномерно разделен на размер блока.

*Рисунок 1: AES-ECB с 128-битным ключом*

![Рисунок 1: AES-ECB с 128-битным ключом](assets/Figure5-1.webp "Рисунок 1: AES-ECB с 128-битным ключом")

Каждый 128-битный блок текста проходит через десять раундов в схеме шифрования Рейндал. Это требует отдельного раундового ключа для каждого раунда (K<sub>1</sub> до K<sub>10</sub>). Эти ключи производятся для каждого раунда из исходного 128-битного ключа K<sub>0</sub> с использованием алгоритма расширения ключа. Таким образом, для каждого блока текста, который нужно зашифровать, мы будем использовать исходный ключ K<sub>0</sub>, а также десять отдельных раундовых ключей. Заметим, что эти же 11 ключей используются для каждого 128-битного блока открытого текста, который требует шифрования.

Алгоритм расширения ключа длинный и сложный. Разбираться в нем имеет мало учебной пользы. Вы можете самостоятельно ознакомиться с алгоритмом расширения ключа, если хотите. Как только раундовые ключи произведены, шифр Рейндал будет манипулировать первым 128-битным блоком открытого текста, M<sub>1</sub>, как показано на Рисунке 2. Теперь мы рассмотрим эти шаги.

*Рисунок 2: Манипуляции с M<sub>1</sub> с использованием шифра Рейндал*

![Рисунок 2: AES-ECB с 128-битным ключом](assets/Figure5-2.webp "Рисунок 2: AES-ECB с 128-битным ключом")

### Раунд 0

Раунд 0 шифра Рейндал прост. Массив S<sub>0</sub> производится операцией XOR между 128-битным открытым текстом и приватным ключом. То есть,

- S<sub>0</sub> = M<sub>1</sub> XOR K<sub>0</sub>
На первом раунде массив S<sub>0</sub> сначала комбинируется с ключом раунда K<sub>1</sub> с использованием операции XOR. Это приводит к новому состоянию S.
Во-вторых, выполняется операция замены байтов в текущем состоянии S. Она работает, беря каждый байт из 16-байтового массива S и заменяя его байтом из массива, называемого **S-блок Рейндала**. Каждый байт имеет уникальное преобразование, и в результате производится новое состояние S. S-блок Рейндала показан на *Рисунке 3*.

*Рисунок 3: S-блок Рейндала*

![Рисунок 3: S-блок Рейндала](assets/Figure5-3.webp "Рисунок 3: S-блок Рейндала")

Этот S-блок - одно из мест, где абстрактная алгебра играет роль в шифре Рейндала, в частности, поля Галуа.

Для начала вы определяете каждый возможный байтовый элемент от 00 до FF как 8-битный вектор. Каждый такой вектор является элементом поля Галуа GF(2<sup>8</sup>), где неприводимый полином для операции модуля - это x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1. Поле Галуа с этими спецификациями также называется конечным полем Рейндала.

Далее, для каждого возможного элемента в поле мы создаем то, что называется **S-блок Ниберга**. В этом блоке каждый байт отображается на его мультипликативный обратный элемент (т.е., так, чтобы их произведение равнялось 1). Затем мы отображаем эти значения из S-блока Ниберга в S-блок Рейндала с использованием аффинного преобразования.

Третья операция над массивом S - это операция сдвига строк. Она берет состояние S и выстраивает все шестнадцать байтов в матрицу. Заполнение матрицы начинается с верхнего левого угла и продвигается вокруг, идя сверху вниз, а затем, каждый раз когда колонка заполняется, сдвигаясь на одну колонку вправо и вверх.

Как только матрица S построена, четыре строки сдвигаются. Первая строка остается на месте. Вторая строка сдвигается на одну позицию влево. Третья сдвигается на две позиции влево. Четвертая сдвигается на три позиции влево. Пример процесса представлен на *Рисунке 4*. Исходное состояние S показано сверху, результативное состояние после операции сдвига строк показано ниже.

*Рисунок 4: Операция сдвига строк*

![Рисунок 4: Операция сдвига строк](assets/Figure5-4.webp "Рисунок 4: Операция сдвига строк")

На четвертом этапе поля Галуа снова вступают в игру. Для начала, каждая колонка матрицы S умножается на колонку матрицы 4 x 4, видимой на *Рисунке 5*. Но вместо обычного умножения матриц, это векторное умножение по модулю неприводимого полинома, x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1. Результирующие коэффициенты вектора представляют отдельные биты байта.

*Рисунок 5: Матрица смешивания столбцов*

![Рисунок 5: Матрица смешивания столбцов](assets/Figure5-5.webp "Рисунок 5: Матрица смешивания столбцов")

Умножение первой колонки матрицы S на матрицу 4 x 4, показанную выше, дает результат на *Рисунке 6*.
*Рисунок 6: Умножение первого столбца*
![Рисунок 6: Умножение первого столбца](assets/Figure5-6.webp "Рисунок 6: Умножение первого столбца")

На следующем этапе все элементы матрицы должны быть преобразованы в полиномы. Например, F1 представляет 1 байт и будет преобразован в x<sup>7</sup> + x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup> + 1, а 03 представляет 1 байт и будет преобразован в x + 1.

Затем все умножения выполняются по модулю x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1. В результате в каждой из четырех ячеек столбца получается сумма четырех полиномов. После выполнения этих сложений по модулю 2, вы получите четыре полинома. Каждый из этих полиномов представляет 8-битную строку или 1 байт S. Мы не будем выполнять все эти расчеты здесь для матрицы на *Рисунке 6*, поскольку они обширны.

После обработки первого столбца, другие три столбца матрицы S обрабатываются аналогичным образом. В конечном итоге это даст матрицу из шестнадцати байтов, которую можно преобразовать в массив.

На последнем этапе массив S снова комбинируется с раундовым ключом в операции XOR. Это дает состояние S<sub>1</sub>. То есть,

- S<sub>1</sub> = S XOR K<sub>0</sub>

### Раунды с 2 по 10

Раунды с 2 по 9 являются просто повторением раунда 1, *mutatis mutandis*. Последний раунд очень похож на предыдущие, за исключением того, что шаг смешивания столбцов убран. То есть, раунд 10 выполняется следующим образом:

- S<sub>9</sub> XOR K<sub>10</sub>
- Замена байтов
- Сдвиг строк
- S<sub>10</sub> = S XOR K<sub>10</sub>

Состояние S<sub>10</sub> теперь установлено как C<sub>1</sub>, первые 128 бит шифртекста. Продолжение работы с оставшимися блоками открытого текста размером 128 бит дает полный шифртекст.

### Операции шифра Рейндала

Какова логика различных операций, наблюдаемых в шифре Рейндала?

Не вдаваясь в подробности, схемы шифрования оцениваются на основе степени создания ими путаницы и диффузии. Если у схемы шифрования высокая степень **путаницы**, это означает, что шифртекст сильно отличается от открытого текста. Если у схемы шифрования высокая степень **диффузии**, это означает, что любое небольшое изменение в открытом тексте производит сильно отличающийся шифртекст.

Логика операций за шифром Рейндала заключается в том, что они обеспечивают высокую степень как путаницы, так и диффузии. Путаница создается операцией замены байтов, в то время как диффузия создается операциями сдвига строк и смешивания столбцов.

# Асимметричное шифрование
<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

Как и в случае с симметричным шифрованием, асимметричные схемы могут использоваться для обеспечения как секретности, так и аутентификации. Однако в отличие от них, эти схемы используют два ключа вместо одного: приватный и публичный ключ.
Мы начинаем наше исследование с открытия асимметричной криптографии, в частности, с проблем, которые сподвигли к ее развитию. Затем мы обсуждаем, как на высоком уровне работают асимметричные схемы шифрования и аутентификации. После этого мы знакомим с хеш-функциями, которые являются ключом к пониманию схем асимметричной аутентификации и также имеют значение в других криптографических контекстах, например, для кодов аутентификации сообщений на основе хеша, о которых мы говорили в главе 4.

## Проблема распределения и управления ключами
<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

Предположим, что Боб хочет купить новый дождевик в магазине спортивных товаров Jim’s Sporting Goods, онлайн-ритейлере со множеством клиентов в Северной Америке. Это будет его первая покупка у них, и он хочет использовать свою кредитную карту. Таким образом, Бобу сначала нужно создать аккаунт в Jim’s Sporting Goods, что требует отправки личных данных, таких как его адрес и информация о кредитной карте. Затем он может пройти через необходимые шаги для покупки дождевика.

Боб и Jim’s Sporting Goods захотят убедиться, что их коммуникация защищена на протяжении всего процесса, учитывая, что Интернет является открытой системой связи. Они захотят убедиться, например, что никакой потенциальный злоумышленник не сможет узнать детали кредитной карты и адреса Боба, и что никакой потенциальный злоумышленник не сможет повторить его покупки или создать фальшивые от его имени.

Продвинутая схема аутентифицированного шифрования, обсуждаемая в предыдущей главе, определенно могла бы сделать коммуникацию между Бобом и Jim’s Sporting Goods безопасной. Но очевидно существуют практические препятствия для реализации такой схемы.

Чтобы проиллюстрировать эти практические препятствия, предположим, что мы живем в мире, в котором существуют только инструменты симметричной криптографии. Что могли бы сделать Jim’s Sporting Goods и Боб, чтобы обеспечить безопасную коммуникацию?

В таких обстоятельствах они столкнулись бы с значительными затратами на обеспечение безопасной коммуникации. Поскольку Интернет является открытой системой связи, они не могут просто обменяться набором ключей через него. Следовательно, Бобу и представителю Jim’s Sporting Goods придется осуществить обмен ключами лично.

Одна из возможностей заключается в том, что Jim’s Sporting Goods создает специальные места для обмена ключами, где Боб и другие новые клиенты могут получить набор ключей для безопасной коммуникации. Очевидно, это потребовало бы значительных организационных затрат и сильно снизило бы эффективность, с которой новые клиенты могут совершать покупки.

В качестве альтернативы, Jim’s Sporting Goods может отправить Бобу пару ключей с помощью высоко доверенного курьера. Это, вероятно, более эффективно, чем организация мест для обмена ключами. Но это все равно потребует значительных затрат, особенно если многие клиенты совершают только одну или несколько покупок.

Далее, симметричная схема аутентифицированного шифрования также заставляет Jim’s Sporting Goods хранить отдельные наборы ключей для всех своих клиентов. Это была бы значительная практическая проблема для тысяч клиентов, не говоря уже о миллионах.

Чтобы понять этот последний пункт, предположим, что Jim’s Sporting Goods предоставляет каждому клиенту одну и ту же пару ключей. Это позволило бы каждому клиенту — или любому другому, кто мог бы получить эту пару ключей — читать и даже манипулировать всей коммуникацией между Jim’s Sporting Goods и его клиентами. Тогда, возможно, вообще не стоит использовать криптографию в своих коммуникациях.

Даже повторение набора ключей для только некоторых клиентов является ужасной практикой безопасности. Любой потенциальный злоумышленник мог бы попытаться использовать эту особенность схемы (помните, что предполагается, что злоумышленники знают все о схеме, кроме ключей, в соответствии с принципом Керкгоффа).

Таким образом, Jim’s Sporting Goods придется хранить пару ключей для каждого клиента, независимо от того, как эти пары ключей распределяются. Это явно представляет несколько практических проблем.

- Jim’s Sporting Goods придется хранить миллионы пар ключей, один набор для каждого клиента.
- Эти ключи должны быть надежно защищены, поскольку они будут являться верной целью для хакеров. Любые нарушения безопасности потребуют повторения дорогостоящих обменов ключами, либо в специальных пунктах обмена ключами, либо с помощью курьера.
- Любой покупатель магазина спортивных товаров Джима должен будет безопасно хранить пару ключей дома. Потери и кражи будут происходить, что потребует повторения обмена ключами. Клиентам также придется проходить этот процесс для любых других интернет-магазинов или других типов сущностей, с которыми они хотят общаться и совершать транзакции через Интернет.

Эти две основные проблемы, описанные выше, были очень фундаментальными до конца 1970-х годов. Они были известны как **проблема распределения ключей** и **проблема управления ключами** соответственно.

Эти проблемы всегда существовали, конечно, и часто вызывали головную боль в прошлом. Военные силы, например, должны были постоянно распространять книги с ключами для безопасной связи среди персонала на поле боя, неся при этом большие риски и затраты. Но эти проблемы усугублялись по мере того, как мир все больше переходил к дальней, цифровой коммуникации, особенно для неправительственных сущностей.

Если бы эти проблемы не были решены в 1970-х годах, эффективные и безопасные покупки в магазине спортивных товаров Джима, вероятно, не существовали бы. Фактически, большая часть нашего современного мира с практичной и безопасной электронной почтой, онлайн-банкингом и покупками, вероятно, была бы всего лишь далекой фантазией. Что-то даже напоминающее Bitcoin вообще не могло бы существовать.

Итак, что произошло в 1970-х годах? Как возможно, что мы можем мгновенно совершать покупки в Интернете и безопасно пользоваться Всемирной паутиной? Как возможно, что мы можем мгновенно отправлять Bitcoin по всему миру со своих смартфонов?

## Новые направления в криптографии
<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

К 1970-м годам проблемы распределения и управления ключами привлекли внимание группы американских академических криптографов: Уитфилда Диффи, Мартина Хеллмана и Ральфа Меркла. Несмотря на серьезный скептицизм со стороны большинства их коллег, они решились найти решение этой проблемы.

По крайней мере одной из основных мотиваций их начинания было предвидение, что открытые компьютерные коммуникации глубоко повлияют на наш мир. Как отмечают Диффи и Хеллман в 1976 году,

> Развитие компьютерных коммуникационных сетей обещает легкий и недорогой контакт между людьми или компьютерами на противоположных сторонах мира, заменяя большинство почтовых отправлений и многие поездки телекоммуникациями. Для многих приложений эти контакты должны быть защищены как от подслушивания, так и от внедрения нелегитимных сообщений. В настоящее время, однако, решение проблем безопасности отстает далеко позади других областей технологии связи. *Современная криптография не в состоянии удовлетворить требованиям, поскольку ее использование наложило бы такие серьезные неудобства на пользователей системы, что это уничтожило бы многие из преимуществ телепроцессинга.*<sup>[1](#footnote1)</sup>

Упорство Диффи, Хеллмана и Меркла окупилось. Первая публикация их результатов была статьей Диффи и Хеллмана в 1976 году под названием «Новые направления в криптографии». В ней они представили два оригинальных способа решения проблем распределения и управления ключами.
Первым решением, которое они предложили, был протокол удаленного *обмена ключами*, то есть набор правил для обмена одним или несколькими симметричными ключами по незащищенному каналу связи. Сейчас этот протокол известен как *обмен ключами Диффи-Хеллмана* или *обмен ключами Диффи-Хеллмана-Меркла*.<sup>[2](#footnote2)</sup>
С помощью обмена ключами Диффи-Хеллмана две стороны сначала обмениваются некоторой информацией публично по незащищенному каналу, такому как Интернет. На основе этой информации они затем независимо создают симметричный ключ (или пару симметричных ключей) для безопасного общения. Хотя обе стороны создают свои ключи независимо, общедоступная информация, которой они поделились, гарантирует, что процесс создания ключа приведет к одинаковому результату для обеих сторон.

Важно, что, хотя любой может наблюдать за информацией, которой стороны обмениваются публично по незащищенному каналу, только две стороны, участвующие в обмене информацией, могут создать из неё симметричные ключи.

Это, конечно, звучит совершенно контринтуитивно. Как две стороны могут обмениваться некоторой информацией публично, которая позволит только им создать симметричные ключи из неё? Почему кто-то другой, наблюдающий за обменом информацией, не сможет создать те же ключи?

Это основывается на некоторых красивых математических принципах, конечно. Обмен ключами Диффи-Хеллмана работает через однонаправленную функцию с лазейкой. Давайте обсудим значение этих двух терминов по очереди.

Предположим, вам дана некоторая функция f(x) и результат f(a) = y, где a - это конкретное значение для x. Мы говорим, что f(x) является **однонаправленной функцией**, если легко вычислить значение y, зная a и f(x), но вычислить значение a, зная y и f(x), вычислительно невозможно. Название однонаправленная функция, конечно, происходит от того факта, что такую функцию практически возможно вычислить только в одном направлении.

Некоторые однонаправленные функции имеют то, что известно как лазейка. Хотя практически невозможно вычислить a, зная только y и f(x), существует определенная информация Z, которая делает вычисление a из y вычислительно выполнимым. Эта информация Z известна как **лазейка**. Однонаправленные функции, имеющие лазейку, известны как **функции с лазейкой**.

Мы не будем углубляться в детали обмена ключами Диффи-Хеллмана здесь. Но в сущности каждый участник создает некоторую информацию, часть которой делится публично, а часть остается секретной. Затем каждая сторона берет свою секретную информацию и публичную информацию, поделенную другой стороной, чтобы создать приватный ключ. И довольно чудесным образом, обе стороны в итоге получают один и тот же приватный ключ.

Любая сторона, наблюдающая только за публично поделенной информацией между двумя сторонами в обмене ключами Диффи-Хеллмана, не сможет воспроизвести эти вычисления. Им была бы нужна приватная информация одной из двух сторон для этого.

Хотя базовая версия обмена ключами Диффи-Хеллмана, представленная в статье 1976 года, не очень безопасна, более сложные версии базового протокола определенно все еще используются сегодня. Что наиболее важно, каждый протокол обмена ключами в последней версии протокола безопасности транспортного уровня (версия 1.3) по сути является обогащенной версией протокола, представленного Диффи и Хеллманом в 1976 году. Протокол безопасности транспортного уровня является доминирующим протоколом для безопасного обмена информацией, форматированной в соответствии с протоколом передачи гипертекста (http), стандартом для обмена веб-контентом.
Важно отметить, что обмен ключами Диффи-Хеллмана не является асимметричной схемой. Строго говоря, он, возможно, относится к области симметричной криптографии. Но поскольку как обмен ключами Диффи-Хеллмана, так и асимметричная криптография опираются на однонаправленные функции теории чисел с ловушками, они обычно обсуждаются вместе.
Второй способ, который Диффи и Хеллман предложили для решения проблемы распределения и управления ключами в своей статье 1976 года, был, конечно, через асимметричную криптографию.

В отличие от их представления обмена ключами Диффи-Хеллмана, они предоставили только общие контуры того, как могли бы быть построены асимметричные криптографические схемы. Они не предложили никакой конкретной однонаправленной функции, которая могла бы специально удовлетворить условиям, необходимым для разумной безопасности в таких схемах.

Однако практическая реализация асимметричной схемы была найдена год спустя тремя разными академическими криптографами и математиками: Рональдом Ривестом, Ади Шамиром и Леонардом Адлеманом. Криптосистема, которую они ввели, стала известна как **криптосистема RSA** (по их фамилиям).

Функции с ловушкой, используемые в асимметричной криптографии (и обмене ключами Диффи-Хеллмана), связаны с двумя основными **вычислительно сложными задачами**: факторизацией простых чисел и вычислением дискретных логарифмов.

**Факторизация простых чисел** требует, как следует из названия, разложения целого числа на его простые множители. Проблема RSA является, пожалуй, самым известным примером криптосистемы, связанной с факторизацией простых чисел.

**Проблема дискретного логарифма** возникает в циклических группах. Имея генератор в определенной циклической группе, требуется вычисление уникального показателя степени, необходимого для получения другого элемента группы из генератора.

Схемы, основанные на дискретном логарифме, опираются на два основных типа циклических групп: мультипликативные группы целых чисел и группы, включающие точки на эллиптических кривых. Исходный обмен ключами Диффи-Хеллмана, представленный в статье "Новые направления в криптографии", работает с циклической мультипликативной группой целых чисел. Алгоритм цифровой подписи Bitcoin и недавно представленная схема подписи Шнорра (2021) оба основаны на проблеме дискретного логарифма для определенной группы циклических эллиптических кривых.

Далее мы перейдем к обзору секретности и аутентификации в асимметричной среде. Однако перед этим нам нужно сделать краткое историческое замечание.

Теперь кажется вероятным, что группа британских криптографов и математиков, работающих на Главное управление связи правительства (GCHQ), независимо сделала вышеупомянутые открытия на несколько лет раньше. В эту группу входили Джеймс Эллис, Клиффорд Кокс и Малкольм Уильямсон.

Согласно их собственным заявлениям и заявлениям GCHQ, именно Джеймс Эллис впервые разработал концепцию криптографии с открытым ключом в 1969 году. Предположительно, Клиффорд Кокс затем открыл криптографическую систему RSA в 1973 году, а Малкольм Уильямсон - концепцию обмена ключами Диффи-Хеллмана в 1974 году. Однако утверждается, что их открытия не были раскрыты до 1997 года из-за секретного характера работы, проводимой в GCHQ.

## Асимметричное шифрование и аутентификация
<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

Обзор асимметричного шифрования с помощью Боба и Алисы представлен на *Рисунке 1*.
Алиса сначала создает пару ключей, состоящую из одного публичного ключа (K<sub>P</sub>) и одного приватного ключа (K<sub>S</sub>), где "P" в K<sub>P</sub> означает "публичный" (public), а "S" в K<sub>S</sub> - "секретный" (secret). Затем она свободно распространяет этот публичный ключ среди других. Мы вернемся к деталям этого процесса распространения немного позже. Но пока предположим, что любой, включая Боба, может безопасно получить публичный ключ Алисы K<sub>P</sub>.
В какой-то момент позже Боб хочет написать сообщение M Алисе. Поскольку оно содержит конфиденциальную информацию, он хочет, чтобы содержимое оставалось секретом для всех, кроме Алисы. Поэтому Боб сначала шифрует свое сообщение M, используя K<sub>P</sub>. Затем он отправляет полученный шифротекст C Алисе, которая расшифровывает C с помощью K<sub>S</sub>, чтобы восстановить исходное сообщение M.

*Рисунок 1: Асимметричное шифрование*

![Рисунок 1: Асимметричное шифрование](assets/Figure6-1.webp "Рисунок 1: Асимметричное шифрование")

Любой противник, который подслушивает общение Боба и Алисы, может наблюдать C. Она также знает K<sub>P</sub> и алгоритм шифрования E(·). Однако важно, что эта информация не позволяет атакующему выполнимо расшифровать шифротекст C. Для расшифровки конкретно требуется K<sub>S</sub>, которого у атакующего нет.

Схемы симметричного шифрования, как правило, должны быть защищены от атакующего, который может законно шифровать открытые тексты (безопасность от атак с выбранным шифротекстом). Однако они не разработаны с явной целью позволить создавать такие законные шифротексты атакующему или кому-либо еще.

Это резко контрастирует с асимметричной схемой шифрования, цель которой - позволить любому, включая атакующих, производить законные шифротексты. Таким образом, асимметричные схемы шифрования могут быть обозначены как **шифры с множественным доступом**.

Чтобы лучше понять, что происходит, представьте, что вместо отправки сообщения электронно, Боб хотел бы отправить физическое письмо в тайне. Один из способов обеспечить секретность - чтобы Алиса отправила Бобу надежный замок, но оставила ключ у себя. После написания своего письма, Боб мог бы положить письмо в ящик и закрыть его замком Алисы. Затем он мог бы отправить закрытый ящик с сообщением Алисе, у которой есть ключ, чтобы его открыть.

Хотя Боб может закрыть замок, ни он, ни любой другой человек, который перехватит ящик, не сможет открыть замок, если он действительно надежен. Только Алиса может его открыть и увидеть содержимое письма Боба, потому что у нее есть ключ.

Асимметричная схема шифрования, грубо говоря, является цифровой версией этого процесса. Замок аналогичен публичному ключу, а ключ от замка аналогичен приватному ключу. Однако, поскольку замок цифровой, Алисе гораздо легче и не так дорого распространять его среди всех, кто может захотеть отправлять ей секретные сообщения.

Для аутентификации в асимметричной среде мы используем **цифровые подписи**. Таким образом, они выполняют ту же функцию, что и коды аутентификации сообщений в симметричной среде. Обзор цифровых подписей представлен на *Рисунке 2*.
Боб сначала создает пару ключей, состоящую из открытого ключа (K<sub>P</sub>) и закрытого ключа (K<sub>S</sub>), и распространяет свой открытый ключ. Когда он хочет отправить аутентифицированное сообщение Алисе, он сначала берет свое сообщение M и свой закрытый ключ, чтобы создать цифровую подпись D. Затем Боб отправляет Алисе свое сообщение вместе с цифровой подписью. Алиса вставляет сообщение, открытый ключ и цифровую подпись в алгоритм проверки. Этот алгоритм выдает либо true для действительной подписи, либо false для недействительной подписи.
Цифровая подпись, как ясно следует из названия, является цифровым эквивалентом письменной подписи на письмах, контрактах и так далее. Фактически, цифровая подпись обычно намного более безопасна. С некоторыми усилиями вы можете подделать письменную подпись; процесс упрощается из-за того, что письменные подписи часто не проверяются тщательно. Однако безопасная цифровая подпись, так же как и безопасный код аутентификации сообщений, **экзистенциально неподделываемая**: то есть, при использовании безопасной схемы цифровой подписи, никто не может реально создать подпись для сообщения, которая прошла бы процедуру проверки, если у него нет закрытого ключа.

*Рисунок 2: Асимметричная аутентификация*

![Рисунок 2: Асимметричная аутентификация](assets/Figure6-2.webp "Рисунок 2: Асимметричная аутентификация")

Как и в случае с асимметричным шифрованием, мы видим интересное противопоставление между цифровыми подписями и кодами аутентификации сообщений. Для последних алгоритм проверки может быть использован только одной из сторон, знающих о безопасном общении. Это потому, что он требует закрытый ключ. Однако, в асимметричной ситуации, любой может проверить цифровую подпись S, сделанную Бобом.

Все это делает цифровые подписи чрезвычайно мощным инструментом. Они лежат в основе, например, создания подписей на контрактах, которые могут быть проверены в юридических целях. Если бы Боб сделал подпись на контракте в вышеописанном обмене, Алиса может показать сообщение M, контракт и подпись S в суде. Суд, в свою очередь, может проверить подпись, используя открытый ключ Боба.<sup>[5](#footnote5)</sup>

В качестве другого примера, цифровые подписи являются важным аспектом обеспечения безопасности программного обеспечения и распространения обновлений программного обеспечения. Такой тип публичной проверяемости никогда не мог бы быть создан с использованием только кодов аутентификации сообщений.

Как последний пример мощи цифровых подписей, рассмотрим Bitcoin. Одно из самых распространенных заблуждений о Bitcoin, особенно в СМИ, заключается в том, что транзакции зашифрованы: это не так. Вместо этого, транзакции Bitcoin работают с цифровыми подписями для обеспечения безопасности.

Bitcoins существуют в партиях, называемых непотраченными выходами транзакций (или UTXO). Предположим, вы получили три платежа на определенный адрес Bitcoin по 2 биткоина каждый. Технически у вас теперь нет 6 биткоинов на этом адресе. Вместо этого у вас есть три партии по 2 биткоина, которые заблокированы криптографической задачей, связанной с этим адресом. Для любого платежа, который вы совершаете, вы можете использовать одну, две или все три эти партии, в зависимости от того, сколько вам нужно для транзакции.

Доказательство владения непотраченными выходами транзакций обычно демонстрируется через одну или несколько цифровых подписей. Bitcoin работает именно потому, что создание действительных цифровых подписей на непотраченных выходах транзакций вычислительно невозможно, если у вас нет секретной информации, необходимой для их создания.
В настоящее время транзакции Bitcoin прозрачно включают всю информацию, которая должна быть проверена участниками сети, такую как источники неизрасходованных выходов транзакций, используемых в транзакции. Хотя возможно скрыть некоторую часть этой информации и все же позволить провести верификацию (как это делают некоторые альтернативные криптовалюты, такие как Monero), это также создает определенные риски безопасности.
Иногда возникает путаница между цифровыми подписями и письменными подписями, зафиксированными в цифровом виде. В последнем случае вы захватываете изображение своей письменной подписи и вставляете его в электронный документ, такой как трудовой договор. Однако это не является цифровой подписью в криптографическом смысле. Последняя представляет собой просто длинное число, которое может быть создано только при наличии личного ключа.

Так же, как и в симметричной криптографии, вы также можете использовать асимметричное шифрование и схемы аутентификации вместе. Применяются аналогичные принципы. Прежде всего, вы должны использовать разные пары личных и публичных ключей для шифрования и создания цифровых подписей. Кроме того, вы должны сначала зашифровать сообщение, а затем аутентифицировать его.

Важно, что во многих приложениях асимметричная криптография не используется на протяжении всего процесса коммуникации. Вместо этого она обычно используется только для *обмена симметричными ключами* между сторонами, которые будут фактически общаться.

Это случай, например, когда вы покупаете товары в интернете. Зная публичный ключ продавца, он может отправлять вам цифровые подписанные сообщения, которые вы можете проверить на подлинность. На этой основе вы можете следовать одному из нескольких протоколов для обмена симметричными ключами для безопасного общения.

Основная причина частоты упомянутого подхода заключается в том, что асимметричная криптография намного менее эффективна, чем симметричная криптография, в обеспечении определенного уровня безопасности. Это одна из причин, по которой нам все еще нужна симметричная криптография наряду с публичной криптографией. Кроме того, симметричная криптография гораздо более естественна в определенных приложениях, таких как шифрование собственных данных пользователем компьютера.

Так как же цифровые подписи и шифрование с использованием публичного ключа решают проблемы распределения и управления ключами?

Здесь нет однозначного ответа. Асимметричная криптография - это инструмент, и нет единственного способа использовать этот инструмент. Но давайте рассмотрим наш ранний пример из магазина спортивных товаров Джима, чтобы показать, как обычно решаются эти вопросы в этом примере.

Для начала магазин спортивных товаров Джима, вероятно, обратится к **органу по сертификации**, организации, которая поддерживает распространение публичных ключей. Орган по сертификации зарегистрирует некоторые детали о магазине спортивных товаров Джима и предоставит ему публичный ключ. Затем он отправит магазину спортивных товаров Джима сертификат, известный как **TLS/SSL сертификат**, с публичным ключом магазина спортивных товаров Джима, цифровая подпись которого выполнена с использованием собственного публичного ключа органа по сертификации. Таким образом, орган по сертификации подтверждает, что определенный публичный ключ действительно принадлежит магазину спортивных товаров Джима.

Ключ к пониманию этого процесса с TLS/SSL сертификатами заключается в том, что, хотя у вас обычно не будет храниться публичный ключ магазина спортивных товаров Джима где-либо на вашем компьютере, публичные ключи признанных органов по сертификации действительно хранятся в вашем браузере или в вашей операционной системе. Они хранятся в так называемых **корневых сертификатах**.

Следовательно, когда магазин спортивных товаров Джима предоставляет вам свой TLS/SSL сертификат, вы можете проверить цифровую подпись органа по сертификации через корневой сертификат в вашем браузере или операционной системе. Если подпись действительна, вы можете быть относительно уверены, что публичный ключ на сертификате действительно принадлежит магазину спортивных товаров Джима. На этой основе легко настроить протокол для безопасного общения с магазином спортивных товаров Джима.
Распределение ключей теперь стало значительно проще для компании "Jim’s Sporting Goods". Не трудно заметить, что управление ключами также значительно упрощено. Вместо необходимости хранить тысячи ключей, "Jim’s Sporting Goods" теперь нужно хранить только один приватный ключ, который позволяет ей создавать подписи для публичного ключа на её SSL-сертификате. Каждый раз, когда клиент заходит на сайт "Jim’s Sporting Goods", он может установить безопасную сессию связи с использованием этого публичного ключа. Клиентам также не нужно хранить какую-либо информацию (кроме публичных ключей признанных центров сертификации в их операционной системе и браузере).

## Хеш-функции
<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

Хеш-функции повсеместно используются в криптографии. Они не являются ни симметричными, ни асимметричными схемами, но относятся к собственной криптографической категории.

Мы уже сталкивались с хеш-функциями в главе 4 при создании сообщений аутентификации на основе хеша. Они также важны в контексте цифровых подписей, хотя по немного другой причине: цифровые подписи, как правило, создаются на основе хеш-значения некоторого (зашифрованного) сообщения, а не самого (зашифрованного) сообщения. В этом разделе я предложу более подробное введение в хеш-функции.

Давайте начнем с определения хеш-функции. **Хеш-функция** - это любая эффективно вычислимая функция, которая принимает на вход данные произвольного размера и выдает результаты фиксированной длины.

**Криптографическая хеш-функция** - это просто хеш-функция, которая полезна для приложений в криптографии. Результат криптографической хеш-функции обычно называется **хешем**, **хеш-значением** или **дайджестом сообщения**.

В контексте криптографии "хеш-функция" обычно относится к криптографической хеш-функции. Я буду придерживаться этой практики отныне.

Пример популярной хеш-функции - **SHA-256** (алгоритм безопасного хеширования 256). Независимо от размера входных данных (например, 15 бит, 100 бит или 10 000 бит), эта функция выдаст 256-битное хеш-значение. Ниже вы можете увидеть несколько примеров результатов функции SHA-256.

* “Hello”: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
* “52398”: a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90
* “Cryptography is fun”: 3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c

Все результаты точно 256 бит, записанные в шестнадцатеричном формате (каждая шестнадцатеричная цифра может быть представлена четырьмя двоичными цифрами). Так что даже если бы вы вставили книгу Толкиена "Властелин колец" в функцию SHA-256, результат все равно был бы 256 бит.

Хеш-функции, такие как SHA-256, используются для различных целей в криптографии. Какие свойства требуются от хеш-функции, действительно зависит от контекста конкретного приложения. Есть два основных свойства, обычно желаемых от хеш-функций в криптографии:<sup>[6](#footnote6)</sup>

1.	Стойкость к коллизиям
2.	Скрытие

Говорят, что хеш-функция H обладает **стойкостью к коллизиям**, если невозможно найти два значения, x и y, таких, что x ≠ y, но H(x) = H(y).
Функции хэширования, устойчивые к коллизиям, важны, например, при верификации программного обеспечения. Предположим, что вы хотите скачать релиз Windows Bitcoin Core 0.21.0 (серверное приложение для обработки трафика сети Bitcoin). Основные шаги, которые вам необходимо предпринять для проверки легитимности программного обеспечения, следующие:
1. Сначала вам нужно скачать и импортировать публичные ключи одного или нескольких участников Bitcoin Core в программное обеспечение, которое может проверять цифровые подписи (например, Kleopetra). Эти публичные ключи можно найти [здесь](https://github.com/bitcoin/bitcoin/blob/master/contrib/builder-keys/keys.txt). Рекомендуется проверять программное обеспечение Bitcoin Core с публичными ключами нескольких участников.
2. Далее вам нужно проверить импортированные публичные ключи. Как минимум один шаг, который вы должны предпринять, - это убедиться, что публичные ключи, которые вы нашли, совпадают с опубликованными в различных других местах. Например, вы можете проконсультироваться с личными веб-страницами, страницами в Twitter или страницами на Github людей, чьи публичные ключи вы импортировали. Обычно это сравнение публичных ключей происходит путем сравнения короткого хэша публичного ключа, известного как отпечаток.
3. Далее вам нужно скачать исполняемый файл Bitcoin Core с их [веб-сайта](www.bitcoincore.org). Будут доступны пакеты для операционных систем Linux, Windows и MAC.
4. Затем вам нужно найти два файла релиза. Первый содержит официальный хэш SHA-256 для скачанного вами исполняемого файла вместе с хэшами всех других выпущенных пакетов. Другой файл релиза будет содержать подписи различных участников над файлом релиза с хэшами пакетов. Оба эти файла релиза должны быть размещены на веб-сайте Bitcoin Core.
5. Далее вам нужно будет вычислить хэш SHA-256 исполняемого файла, который вы скачали с веб-сайта Bitcoin Core, на своем компьютере. Затем сравните этот результат с официальным хэшем пакета для исполняемого файла. Они должны совпадать.
6. Наконец, вам нужно будет проверить, что одна или несколько цифровых подписей над файлом релиза с официальными хэшами пакетов действительно соответствуют одному или нескольким публичным ключам, которые вы импортировали (релизы Bitcoin Core не всегда подписываются всеми). Это можно сделать с помощью приложения, такого как Kleopetra.

Этот процесс верификации программного обеспечения имеет два основных преимущества. Во-первых, он гарантирует, что при скачивании с веб-сайта Bitcoin Core не произошло ошибок передачи. Во-вторых, он обеспечивает защиту от возможности скачивания измененного, вредоносного кода, будь то в результате взлома веб-сайта Bitcoin Core или перехвата трафика.

Как именно процесс верификации программного обеспечения, описанный выше, защищает от этих проблем?

Если вы тщательно проверили импортированные публичные ключи, то можете быть довольно уверены, что эти ключи действительно принадлежат их владельцам и не были скомпрометированы. Учитывая, что цифровые подписи обладают свойством экзистенциальной нефальсифицируемости, вы знаете, что только эти участники могли сделать цифровую подпись над официальными хэшами пакетов в файле релиза.

Предположим, подписи в скачанном вами файле релиза подтверждаются. Теперь вы можете сравнить значение хэша, которое вы вычислили локально для скачанного исполняемого файла Windows, с тем, которое включено в должным образом подписанный файл релиза. Поскольку вы знаете, что функция хэширования SHA-256 устойчива к коллизиям, совпадение означает, что ваш исполняемый файл точно такой же, как официальный исполняемый файл.

Теперь давайте обратимся ко второму общему свойству хэш-функций: скрытию. Любая хэш-функция H обладает свойством скрытия, если для любого случайно выбранного x из очень большого диапазона невозможно найти x, зная только H(x).
Ниже вы можете увидеть результат SHA-256 для сообщения, которое я написал. Чтобы обеспечить достаточную случайность, в конце сообщения была добавлена случайно сгенерированная строка символов. Учитывая, что SHA-256 обладает свойством скрытия, никто не сможет расшифровать это сообщение.
* b194221b37fa4cd1cfce15aaef90351d70de17a98ee6225088b523b586c32ded

Но я не буду держать вас в напряжении до тех пор, пока SHA-256 не станет слабее. Исходное сообщение, которое я написал, было следующим:

* “Это очень случайное сообщение, ну или скорее случайное. Эта начальная часть не является таковой, но я закончу некоторыми относительно случайными символами, чтобы обеспечить очень непредсказуемое сообщение. XLWz4dVG3BxUWm7zQ9qS”.

Обычный способ использования хеш-функций со свойством скрытия заключается в управлении паролями (стойкость к коллизиям также важна для этого применения). Любая приличная онлайн-служба, основанная на учетных записях, такая как Facebook или Google, не будет хранить ваши пароли напрямую для управления доступом к вашей учетной записи. Вместо этого они будут хранить только хеш этого пароля. Каждый раз, когда вы вводите свой пароль в браузере, сначала рассчитывается хеш. Только этот хеш отправляется на сервер поставщика услуг и сравнивается с хешем, хранящимся в базе данных на сервере. Свойство скрытия может помочь обеспечить, что атакующие не смогут восстановить его из значения хеша.

Управление паролями через хеши, конечно, работает только в том случае, если пользователи действительно выбирают сложные пароли. Свойство скрытия предполагает, что x выбирается случайным образом из очень большого диапазона. Выбор паролей вроде “1234”, “mypassword” или вашей даты рождения не обеспечит никакой реальной безопасности. Существуют длинные списки распространенных паролей и их хешей, которыми могут воспользоваться атакующие, если они когда-либо получат хеш вашего пароля. Такие типы атак известны как **словарные атаки**. Если атакующие знают некоторые ваши личные данные, они также могут попытаться сделать некоторые обоснованные предположения. Поэтому вам всегда нужны длинные, надежные пароли (желательно длинные, случайные строки из менеджера паролей).

Иногда приложению может потребоваться хеш-функция, которая обладает как стойкостью к коллизиям, так и скрытием. Но определенно не всегда. Процесс верификации программного обеспечения, о котором мы говорили, например, требует только, чтобы хеш-функция обладала стойкостью к коллизиям, скрытие не важно.

Хотя стойкость к коллизиям и скрытие являются основными свойствами, которые ищут от хеш-функций в криптографии, в некоторых приложениях могут быть желательны и другие типы свойств.

### Примечания
[^1]: Уитфилд Диффи и Мартин Хеллман, “Новые направления в криптографии,” *IEEE Transactions on Information Theory* IT-22 (1976), стр. 644–654, на стр. 644 [^1].

[^2]: Ральф Меркл также обсуждает протокол обмена ключами в “Безопасная связь по незащищенным каналам”, *Communications of the Association for Computing Machinery*, 21 (1978), 294–99. Хотя Меркл подал эту статью до работы Диффи и Хеллмана, она была опубликована позже. Решение Меркла не является экспоненциально безопасным, в отличие от Диффи-Хеллмана [^2].

[^3]: Рон Ривест, Ади Шамир и Леонард Адлеман, “Метод получения цифровых подписей и криптосистем с открытым ключом”, *Communications of the Association for Computing Machinery*, 21 (1978), стр. 120–26 [^3].

[^4]: Хорошую историю этих открытий предоставляет Саймон Сингх в книге *Кодовая книга*, Fourth Estate (Лондон, 1999), Глава 6 [^4].
[^5]: Любые схемы, пытающиеся достичь неотказуемости, другая тема, которую мы обсуждали в *Главе 1*, в своей основе должны включать цифровые подписи [^5].
[^6]: Терминология "скрытие" не является общеупотребительной, а взята специально из работы Арвинда Нараянана, Джозефа Бонно, Эдварда Фелтена, Эндрю Миллера и Стивена Голдфедера, *Bitcoin and Cryptocurrency Technologies*, Princeton University Press (Принстон, 2016), Глава 1 [^6].

# Криптосистема RSA
<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

Хотя симметричная криптография обычно довольно интуитивно понятна для большинства людей, это обычно не относится к асимметричной криптографии. Несмотря на то, что вы, вероятно, удобно ориентируетесь в общем описании, предложенном в предыдущих разделах, вы, вероятно, задаетесь вопросом, что именно представляют собой однонаправленные функции и как именно они используются для создания асимметричных схем.

В этой главе я сниму некоторую тайну, окружающую асимметричную криптографию, более подробно рассмотрев конкретный пример, а именно криптосистему RSA. В первом разделе я представлю проблему факторизации, на которой основана проблема RSA. Затем я рассмотрю ряд ключевых результатов из теории чисел. В последнем разделе мы объединим эту информацию, чтобы объяснить проблему RSA и как это может быть использовано для создания асимметричных криптографических схем.

Добавление этой глубины к нашему обсуждению не является легкой задачей. Это требует введения довольно большого количества теорем и предложений теории чисел. Но не позволяйте математике отпугнуть вас. Проработка этого обсуждения значительно улучшит ваше понимание того, что лежит в основе асимметричной криптографии, и является ценным вложением.

Давайте теперь первым делом обратимся к проблеме факторизации.

## Проблема факторизации
<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

Когда вы умножаете два числа, скажем a и b, мы называем числа a и b **факторами**, а результат **произведением**. Попытка записать число N в виде умножения двух или более факторов называется **факторизацией** или **разложением на множители**.<sup>[1](#footnote1)</sup> Любую проблему, требующую этого, можно назвать **проблемой факторизации**.

Около 2,500 лет назад греческий математик Евклид из Александрии открыл ключевую теорему о факторизации целых чисел. Обычно ее называют **теоремой о единственном разложении на простые множители** и она утверждает следующее:

*Теорема 1*. Каждое целое число N, большее 1, является либо простым числом, либо может быть выражено как произведение простых множителей.

Все, что означает последняя часть этого утверждения, это то, что вы можете взять любое составное целое число N больше 1 и записать его как умножение простых чисел. Ниже приведены несколько примеров составных целых чисел, записанных как произведение простых множителей.

* 18 = 2 • 3 • 3 = 2 • 3<sup>2</sup>
* 84 = 2 • 2 • 3 • 7 = 2<sup>2</sup> • 3 • 7
* 144 = 2 • 2 • 2 • 2 • 3 • 3 = 2<sup>4</sup> • 3<sup>2</sup>
Для всех трех целых чисел, указанных выше, вычисление их простых множителей относительно просто, даже если вам дано только N. Вы начинаете с наименьшего простого числа, а именно 2, и смотрите, сколько раз целое число N делится на него. Затем вы переходите к проверке делимости N на 3, 5, 7 и так далее. Вы продолжаете этот процесс до тех пор, пока ваше целое число N не будет представлено в виде произведения только простых чисел.
Возьмем, к примеру, целое число 84. Ниже вы можете увидеть процесс определения его простых множителей. На каждом шаге мы выносим наименьший оставшийся простой множитель (слева) и определяем остаточный член для факторизации. Мы продолжаем, пока остаточный член также не станет простым числом. На каждом шаге текущая факторизация 84 отображается справа.

* Простой множитель = 2: остаточный член = 42 (84 = 2 • 42)
* Простой множитель = 2: остаточный член = 21 (84 = 2 • 2 • 21)
* Простой множитель = 3: остаточный член = 7 (84 = 2 • 2 • 3 • 7)
* Поскольку 7 является простым числом, результатом будет 2 • 2 • 3 • 7, или 2<sup>2</sup> • 3 • 7.

Предположим теперь, что N очень велико. Насколько сложно будет разложить N на его простые множители?

Это действительно зависит от N. Предположим, например, что N равно 50,450,400. Хотя это число выглядит пугающим, расчеты не так сложны и могут быть легко выполнены вручную. Как и выше, вы просто начинаете с 2 и продолжаете дальше. Ниже вы можете увидеть результат этого процесса аналогичным образом.

* 2: 25,225,200 (50,450,400 = 2 • 25,225,200)
* 2: 12,612,600 (50,450,400 = 2<sup>2</sup> • 12,612,600)
* 2: 6,306,300 (50,450,400 = 2<sup>3</sup> • 6,306,300)
* 2: 3,153,150 (50,450,400 = 2<sup>4</sup> • 3,153,150)
* 2: 1,576,575 (50,450,400 = 2<sup>5</sup> • 1,576,575)
* 3: 525,525 (50,450,400 = 2<sup>5</sup> • 3 • 525,525)
* 3: 175,175 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 175,175)
* 5: 35,035 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5 • 35,035)
* 5: 7,007 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7,007)
* 7: 1,001 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7 • 1,001) * 7: 143 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 143)
* 11: 13 (50,450,400 = 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13)
* Поскольку 13 является простым числом, результатом будет 2<sup>5</sup> • 3<sup>2</sup> • 5<sup>2</sup> • 7<sup>2</sup> • 11 • 13.

Решение этой задачи вручную занимает некоторое время. Компьютер, конечно, может сделать все это за долю секунды. Фактически, компьютер часто может даже факторизовать чрезвычайно большие целые числа за долю секунды.

Однако есть определенные исключения. Предположим, что мы сначала случайным образом выбираем два очень больших простых числа. Обычно их обозначают как p и q, и я буду придерживаться этой конвенции здесь.

Для конкретности, скажем, что p и q оба являются 1024-битными простыми числами, и что для их представления действительно требуется как минимум 1024 бита (так что первый бит должен быть 1). Так, например, 37 не могло бы быть одним из простых чисел. Вы, конечно, можете представить 37 с помощью 1024 битов. Но очевидно, что *вам не нужно* столько битов для его представления. Вы можете представить 37 любой строкой, которая имеет 6 битов или больше. (В 6 битах 37 будет представлено как 100101).

Важно оценить, насколько велики p и q, если выбраны в соответствии с вышеуказанными условиями. В качестве примера я выбрал случайное простое число, которое требует как минимум 1024 битов для представления ниже.

* 14,752,173,874,503,595,484,930,006,383,670,759,559,764,562,721,397,166,747,289,220,945,457,932,666,751,048,198,854,920,097,085,690,793,755,254,946,188,163,753,506,778,089,706,699,671,722,089,715,624,760,049,594,106,189,662,669,156,149,028,900,805,928,183,585,427,782,974,951,355,515,394,807,209,836,870,484,558,332,897,443,152,653,214,483,870,992,618,171,825,921,582,253,023,974,514,209,142,520,026,807,636,589

Предположим теперь, после случайного выбора простых чисел p и q, мы умножаем их, чтобы получить целое число N. Это последнее целое число, следовательно, является 2048-битным числом, которое требует как минимум 2048 битов для его представления. Оно намного, намного больше, чем любое из чисел p или q.
Предположим, вы даете компьютеру число N и просите его найти два 1024-битных простых множителя числа N. Вероятность того, что компьютер обнаружит p и q, крайне мала. Можно сказать, что для всех практических целей это невозможно. Это так, даже если вы будете использовать суперкомпьютер или даже сеть суперкомпьютеров.

Для начала предположим, что компьютер пытается решить проблему, перебирая 1024-битные числа, проверяя в каждом случае, являются ли они простыми и являются ли они множителями N. Тогда набор простых чисел для проверки примерно равен 1.265 • 10<sup>305</sup>.<sup>[2](#footnote2)</sup>

Даже если вы возьмете все компьютеры на планете и заставите их пытаться найти и проверить 1024-битные простые числа таким образом, шанс в один из миллиарда успешно найти простой множитель N потребует периода вычислений, намного превышающего возраст Вселенной.

Теперь на практике компьютер может справиться с задачей лучше, чем было описано. Существует несколько алгоритмов, которые компьютер может применить для более быстрого получения факторизации. Однако суть в том, что даже используя эти более эффективные алгоритмы, задача для компьютера все еще вычислительно невыполнима.<sup>[3](#footnote3)</sup>

Важно, что сложность факторизации в только что описанных условиях основана на предположении, что не существует вычислительно эффективных алгоритмов для вычисления простых множителей. Мы не можем действительно доказать, что эффективный алгоритм не существует. Тем не менее, это предположение очень правдоподобно: несмотря на обширные усилия, продолжающиеся сотни лет, мы до сих пор не нашли такого вычислительно эффективного алгоритма.

Следовательно, проблема факторизации в определенных обстоятельствах может с уверенностью считаться сложной задачей. В частности, когда p и q являются очень большими простыми числами, их произведение N несложно вычислить; но факторизация, зная только N, практически невозможна.

## Теоретико-числовые результаты
<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

К сожалению, проблема факторизации не может быть использована напрямую для асимметричных криптографических схем. Однако мы можем использовать более сложную, но связанную с этим проблему: проблему RSA.

Для понимания проблемы RSA нам нужно будет разобраться в ряде теорем и предложений из теории чисел. Они представлены в этом разделе в трех подразделах: (1) порядок N, (2) обратимость по модулю N и (3) теорема Эйлера.

Некоторый материал в этих трех подразделах уже был представлен в *Главе 3*. Но я здесь повторю этот материал для удобства.

### Порядок N

Целое число a является **взаимно простым** или **относительно простым** с целым числом N, если наибольший общий делитель между ними равен 1. Хотя 1 по соглашению не является простым числом, оно является взаимно простым для каждого целого числа (как и –1).

Например, рассмотрим случай, когда a = 18 и N = 37. Очевидно, они являются взаимно простыми. Наибольшее целое число, которое делит как 18, так и 37, равно 1. В отличие от этого, рассмотрим случай, когда a = 42 и N = 16. Очевидно, они не являются взаимно простыми. Оба числа делятся на 2, что больше 1.
Теперь мы можем определить порядок N следующим образом. Предположим, что N - это целое число, большее 1. **Порядок N** - это количество всех взаимно простых чисел с N таких, что для каждого взаимно простого числа a выполняется следующее условие: 1 ≤ a < N.
Например, если N = 12, то 1, 5, 7 и 11 - это единственные взаимно простые числа, которые соответствуют вышеуказанному требованию. Следовательно, порядок 12 равен 4.

Предположим, что N - это простое число. Тогда любое целое число, меньшее N, но большее или равное 1, взаимно просто с ним. Это включает все элементы в следующем наборе: {1,2,3….,N – 1}. Следовательно, когда N простое, порядок N равен N – 1. Это утверждается в предложении 1, где φ(N) обозначает порядок N.

**Предложение 1**. φ(N) = N – 1, когда N простое

Предположим, что N не является простым. Тогда вы можете рассчитать его порядок, используя **функцию Эйлера φ**. Хотя расчет порядка малого целого числа относительно прост, функция Эйлера φ становится особенно важной для больших целых чисел. Предложение функции Эйлера φ приведено ниже.

*Теорема 2*. Пусть N равно p<sub>1</sub><sup>e_1</sup> • p<sub>2</sub><sup>e_2</sup> • … • p<sub>i</sub><sup>e_i</sup> • … • p<sub>n</sub><sup>e_n</sup>, где набор {p<sub>i</sub>} состоит из всех различных простых множителей N и каждый e_i указывает, сколько раз простой множитель p<sub>i</sub> встречается для N. Тогда, φ(N) = p<sub>1</sub><sup>e_1 - 1</sup> • (p<sub>1</sub> - 1) • p<sub>2</sub><sup>e_2 - 1</sup> • (p<sub>2</sub> - 1) • … • p<sub>n</sub><sup>e_n - 1</sup> • (p<sub>n</sub> - 1).

*Теорема 2* показывает, что как только вы разложите любое непростое N на его различные простые множители, легко рассчитать порядок N.

Например, предположим, что N = 270. Очевидно, это не простое число. Разложение N на его простые множители дает выражение: 2 • 3<sup>3</sup> • 5. Согласно функции Эйлера φ, порядок N тогда следующий:

* φ(N) = 2<sup>1 – 1</sup> (2 – 1) + 3<sup>3 – 1</sup> (3 – 1) + 5<sup>1 – 1</sup> (5 – 1) = 1 (1) + 9 (2) + 1 (4) = 1 + 18 + 4 = 23
Предположим далее, что N является произведением двух простых чисел, p и q. *Теорема 2*, таким образом, утверждает, что порядок N следующий: p<sup>1 – 1</sup> (p – 1) x q<sup>1 – 1</sup> (q – 1) = (p – 1) x (q – 1). Это ключевой результат для проблемы RSA в частности и изложен в *Предложении 2* ниже.
*Предложение 2*. Если N является произведением двух простых чисел, p и q, порядок N является произведением (p – 1) x (q – 1).

Для иллюстрации предположим, что N = 119. Это целое число может быть разложено на два простых числа, а именно 7 и 17. Следовательно, функция Эйлера Фи предполагает, что порядок 119 следующий:

* φ(119) = (7 – 1) • (17 – 1) = 6 • 16 = 96.

Другими словами, целое число 119 имеет 96 взаимно простых чисел в диапазоне от 1 до 119. Фактически, этот набор включает все целые числа от 1 до 119, которые не являются кратными ни 7, ни 17.

Отсюда и далее обозначим набор взаимно простых чисел, определяющих порядок N, как **C<sub>N</sub>**. Для нашего примера, где N = 119, набор **C<sub>119</sub>** слишком велик, чтобы перечислить его полностью. Но некоторые из элементов следующие: **C<sub>119</sub>** = {1,2,….6,8….13,15,16,18,….,33,35….,96}.

### Обратимость по модулю N

Мы можем сказать, что целое число a является **обратимым по модулю N**, если существует по крайней мере одно целое число b такое, что a x b по модулю N = 1 по модулю N. Любое такое целое число b называется **обратным** (или **мультипликативным обратным**) данного сокращения по модулю N.

Предположим, например, что a = 5 и N = 11. Существует множество целых чисел, на которые вы можете умножить 5, так что 5 x b mod 11 = 1 mod 11. Рассмотрим, например, целые числа 20 и 31. Легко видеть, что оба этих числа являются обратными к 5 при сокращении по модулю 11.

* 5 x 20 mod 11 = 100 mod 11 = 1 mod 11
* 5 x 31 mod 11 = 155 mod 11 = 1 mod 11

Хотя у 5 есть много обратных чисел по модулю 11, можно показать, что существует только одно положительное обратное число 5, которое меньше 11. Фактически, это не уникально для нашего конкретного примера, но является общим результатом.

*Предложение 3*. Если целое число a обратимо по модулю N, то должно быть так, что существует ровно одно положительное обратное a, которое меньше N. (Так что это уникальное обратное a должно входить в набор {1,…,N – 1}).
Давайте обозначим уникальный обратный элемент к a из Утверждения 3 как a<sup>-1</sup>. В случае, когда a = 5 и N = 11, вы можете видеть, что a<sup>-1</sup> = 9, учитывая, что 5 x 9 mod 11 = 45 mod 11 = 1 mod 11.
Обратите внимание, что значение 9 для a<sup>-1</sup> в нашем примере можно также получить, просто уменьшив любой другой обратный элемент к a по модулю 11. Например, 20 mod 11 = 31 mod 11 = 9 mod 11. Таким образом, когда целое число a > N обратимо по модулю N, тогда a mod N также должно быть обратимым по модулю N.

Не всегда существует обратный элемент к a при редукции по модулю N. Предположим, например, что a = 2 и N = 8. Не существует такого b, или конкретно a<sup>-1</sup>, что 2 x b mod 8 = 1 mod 8. Это потому, что любое значение b всегда будет производить кратное 2, так что никакое деление на 8 никогда не даст остаток, равный 1.

Как именно мы знаем, существует ли обратный элемент к некоторому целому числу a для данного N? Как вы могли заметить в примере выше, наибольший общий делитель между 2 и 8 больше 1, а именно 2. И это на самом деле иллюстрирует следующий общий результат:

*Утверждение 4*. Обратный элемент существует для целого числа a при редукции по модулю N, и конкретно уникальный положительный обратный элемент меньше N, тогда и только тогда, когда наибольший общий делитель между a и N равен 1 (то есть, если они взаимно просты).

В случае, когда a = 5 и N = 11, мы пришли к выводу, что a<sup>-1</sup> = 9, учитывая, что 5 x 9 mod 11 = 45 mod 11 = 1 mod 11. Важно отметить, что обратное также верно. То есть, когда a = 9 и N = 11, получается, что a<sup>-1</sup> = 5.

### Теорема Эйлера

Прежде чем перейти к проблеме RSA, нам нужно понять еще одну критически важную теорему, а именно **Теорему Эйлера**. Она утверждает следующее:

*Теорема 3*. Предположим, что два целых числа a и N взаимно просты. Тогда, a<sup>φ(N)</sup> mod N = 1 mod N.

Это замечательный результат, но немного сбивающий с толку с первого взгляда. Давайте обратимся к примеру, чтобы понять его.

Предположим, что a = 5 и N = 7. Эти числа действительно взаимно просты, как требует Теорема Эйлера. Мы знаем, что порядок 7 равен 6, учитывая, что 7 - простое число (см. **Утверждение 1**).

Теперь Теорема Эйлера утверждает, что 5<sup>6</sup> mod 7 должно быть равно 1 mod 7. Ниже приведены расчеты, показывающие, что это действительно так.

* 5<sup>6</sup> mod 7 = 15,625 mod 7 = 1 mod N

Целое число 7 делит 15,624 в общей сложности 2,233 раза. Следовательно, остаток от деления 16,625 на 7 равен 1.

Далее, используя функцию Фи Эйлера, *Теорема 2*, вы можете вывести *Утверждение 5*, приведенное ниже.
*Предложение 5*. φ(a • b) = φ(a) • φ(b) для любых положительных целых чисел a и b.
Мы не будем объяснять, почему это так. Но просто отметим, что вы уже видели доказательства этого предложения по факту того, что φ(p • q) = φ(p) • φ(q) = (p – 1) • (q – 1), когда p и q являются простыми числами, как указано в *Предложении 2*.

Теорема Эйлера в сочетании с *Предложением 5* имеет важные следствия. Посмотрите, что происходит, например, в следующих выражениях, где a и N взаимно простые.

* a<sup>2 • φ(N)</sup> mod N = a<sup>φ(N)</sup> • a<sup>φ(N)</sup> mod N = 1 • 1 mod N = 1 mod N
* a<sup>φ(N) + 1</sup> mod N = a<sup>φ(N)</sup> • a<sup>1</sup> mod N = 1 • a<sup>1</sup> mod N = a mod N
* a<sup>8 • φ(N) + 3</sup> mod N = a<sup>8 • φ(N)</sup> • a<sup>3</sup> mod N = 1 • a<sup>3</sup> mod N = a<sup>3</sup> mod N

Таким образом, сочетание теоремы Эйлера и *Предложения 5* позволяет нам просто вычислить ряд выражений. В общем, мы можем суммировать вывод в *Предложении 6*.

*Предложение 6*. a<sup>x</sup> mod N = a<sup>x mod φ(N)</sup>

Теперь нам нужно собрать все вместе в хитром последнем шаге.

Так как N имеет порядок φ(N), который включает элементы множества **C<sub>N</sub>**, мы знаем, что целое число φ(N) в свою очередь также должно иметь порядок и множество взаимно простых чисел. Пусть φ(N) = R. Тогда мы знаем, что существует также значение для φ(R) и множество взаимно простых чисел **C<sub>R</sub>**.

Предположим, что мы теперь выбираем целое число e из множества **C<sub>R</sub>**. Мы знаем из *Предложения 3*, что это целое число e имеет только один уникальный положительный обратный элемент меньше R. То есть, e имеет один уникальный обратный элемент из множества **C<sub>R</sub>**. Назовем этот обратный элемент d. Исходя из определения обратного элемента, это означает, что e • d = 1 mod R.

Мы можем использовать этот результат, чтобы сделать заявление о нашем исходном целом числе N. Это суммировано в *Предложении 7*.

*Предложение 7*. Предположим, что e • d mod φ(N) = 1 mod φ(N). Тогда для любого элемента a из множества **C<sub>N</sub>** должно быть так, что a<sup>e • d mod φ(N)</sup> = a<sup>1 mod φ(N)</sup> = a mod N.

Теперь у нас есть все необходимые теоретико-числовые результаты, чтобы четко сформулировать проблему RSA.

## Криптосистема RSA
<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>
Теперь мы готовы описать проблему RSA. Предположим, вы создаете набор переменных, состоящий из p, q, N, φ(N), e, d и y. Назовем этот набор Π. Он создается следующим образом:
1. Генерируются два случайных простых числа p и q одинакового размера и вычисляется их произведение N.
2. Вычисляется порядок N, φ(N), по следующему произведению: (p – 1) • (q – 1).
3. Выбирается e > 2 так, чтобы оно было меньше и взаимно просто с φ(N).
4. Вычисляется d путем установки e • d mod φ(N) = 1.
5. Выбирается случайное значение y, которое меньше и взаимно просто с N.

Проблема RSA заключается в нахождении такого x, что x<sup>e</sup> = y, при этом дана только подмножество информации о Π, а именно переменные N, e и y. Когда p и q очень велики, обычно рекомендуется, чтобы они были размером в 1024 бита, считается, что проблема RSA трудно решаема. Теперь вы видите, почему это так, исходя из предыдущего обсуждения.

Простой способ вычислить x, когда x<sup>e</sup> mod N = y mod N, - это просто вычислить y<sup>d</sup> mod N. Мы знаем, что y<sup>d</sup> mod N = x mod N по следующим вычислениям:

* y<sup>d</sup> mod N = x<sup>e • d</sup> mod N = x<sup>e • d mod φ(N)</sup> mod N = x<sup>1 mod φ(N)</sup> mod N = x mod N.

Проблема в том, что мы не знаем значение d, так как оно не дано в задаче. Следовательно, мы не можем напрямую вычислить y<sup>d</sup> mod N, чтобы получить x mod N.

Однако мы могли бы косвенно вычислить d из порядка N, φ(n), так как мы знаем, что e • d mod φ(N) = 1 mod φ(N). Но по предположению в задаче также не дано значение для φ(N).

Наконец, порядок можно было бы вычислить косвенно с помощью простых множителей p и q, так что в конечном итоге мы могли бы вычислить d. Но по предположению значения p и q также не были предоставлены нам.

Строго говоря, даже если задача факторизации в рамках проблемы RSA сложна, мы не можем доказать, что проблема RSA также сложна. Возможно, существуют и другие способы решения проблемы RSA, помимо факторизации. Однако обычно принято и предполагается, что если задача факторизации в рамках проблемы RSA сложна, то сама проблема RSA также сложна.

Если проблема RSA действительно сложна, то она создает одностороннюю функцию с лазейкой. Здесь функция f(g) = g<sup>e</sup> mod N. Зная f(g), любой может легко вычислить значение y для конкретного g = x. Однако практически невозможно вычислить конкретное значение x, зная только значение y и функцию f(g). Исключение составляет случай, когда вам дана часть информации d, лазейка. В этом случае вы можете просто вычислить y<sup>d</sup>, чтобы получить x.

Давайте рассмотрим конкретный пример, чтобы иллюстрировать проблему RSA. Я не могу выбрать проблему RSA, которая считалась бы сложной при вышеуказанных условиях, так как числа были бы неудобными для работы. Вместо этого этот пример просто иллюстрирует, как в общем работает проблема RSA.
Для начала предположим, что вы выбрали два случайных простых числа 13 и 31. Таким образом, p = 13 и q = 31. Произведение N этих двух простых чисел равно 403. Мы легко можем вычислить порядок числа 403. Он эквивалентен (13 – 1) • (31 – 1) = 360.
Далее, как указано на шаге 3 задачи RSA, нам нужно выбрать взаимно простое число для 360, которое больше 2 и меньше 360. Нам не обязательно выбирать это значение случайным образом. Предположим, что мы выбрали 103. Это взаимно простое число с 360, так как их наибольший общий делитель с 103 равен 1.

На шаге 4 теперь требуется, чтобы мы вычислили значение d такое, что 103 • d mod 360 = 1. Это не простая задача для ручного вычисления, когда значение N велико. Требуется использование процедуры, называемой **расширенным алгоритмом Евклида**.

Хотя я здесь не показываю процедуру, она дает значение 7, когда e = 103. Вы можете проверить, что пара значений 103 и 7 действительно удовлетворяет общему условию e • d mod φ(n) = 1 по следующим расчетам.

* 103 • 7 mod 360 = 721 mod 360 = 1 mod 360

Важно, что, учитывая *Предложение 4*, мы знаем, что никакое другое целое число между 1 и 360 для d не даст результата, что 103 • d = 1 mod 360. Кроме того, предложение подразумевает, что выбор другого значения для e даст другое уникальное значение для d.

На шаге 5 задачи RSA нам нужно выбрать некоторое положительное целое число y, которое является меньшим взаимно простым числом для 403. Предположим, что мы установили y = 2<sup>103</sup>. Возведение 2 в степень 103 дает результат ниже.

* 2<sup>103</sup> mod 403 = 10,141,204,801,825,835,211,973,625,643,008 mod 403 = 349 mod 403

Задача RSA в данном конкретном примере теперь следующая: Вам даны N = 403, e = 103 и y = 349 mod 403. Теперь вы должны вычислить x так, чтобы x<sup>103</sup> = 349 mod 403. То есть, вы должны найти исходное значение до возведения в степень 103, которое было 2.

Было бы легко (по крайней мере для компьютера) вычислить x, если бы мы знали, что d = 7. В этом случае вы могли бы просто определить x как ниже.

* x = y<sup>7</sup> mod 403 = 349<sup>7</sup> mod 403 = 630,634,881,591,804,949 mod 403 = 2 mod 403

Проблема в том, что вам не предоставлена информация о том, что d = 7. Конечно, вы могли бы вычислить d из того факта, что 103 • d = 1 mod 360. Проблема в том, что вам также не дана информация о том, что порядок N = 360. Наконец, вы также могли бы вычислить порядок 403, вычислив следующий продукт: (p – 1) • (q – 1). Но вам также не сказали, что p = 13 и q = 31.
Конечно, компьютер все еще может сравнительно легко решить задачу RSA для данного примера, поскольку задействованные простые числа не являются большими. Но когда простые числа становятся очень большими, он сталкивается с практически невыполнимой задачей.
Теперь мы представили задачу RSA, набор условий, при которых она становится сложной, и основополагающую математику. Как это все помогает с асимметричной криптографией? В частности, как мы можем использовать сложность задачи RSA в определенных условиях для создания схемы шифрования или схемы цифровой подписи?

Один из подходов заключается в том, чтобы взять задачу RSA и разработать схемы прямым способом. Например, предположим, что вы сгенерировали набор переменных Π, как описано в задаче RSA, и убедились, что p и q достаточно велики. Вы устанавливаете свой открытый ключ равным (N, e) и делитесь этой информацией со всем миром. Как описано выше, вы держите в секрете значения для p, q, φ(n) и d. Фактически, d является вашим закрытым ключом.

Любой, кто хочет отправить вам сообщение m, которое является элементом **C<sub>N</sub>**, может просто зашифровать его следующим образом: c = m<sup>e</sup> mod N. (Здесь шифротекст c эквивалентен значению y в задаче RSA.) Вы можете легко расшифровать это сообщение, просто вычислив c<sup>d</sup> mod N.

Вы также можете попытаться создать схему цифровой подписи таким же образом. Предположим, что вы хотите отправить кому-то сообщение m с цифровой подписью S. Вы могли бы просто установить S = m<sup>d</sup> mod N и отправить пару (m,S) получателю. Любой может проверить цифровую подпись, просто проверив, равно ли S<sup>e</sup> mod N = m mod N. Однако любой атакующий будет иметь действительно трудное время для создания действительного S для сообщения, учитывая, что они не обладают d.

К сожалению, превращение самой по себе сложной задачи, задачи RSA, в криптографическую схему не так просто. Для прямолинейной схемы шифрования вы можете выбирать только взаимно простые с N сообщения. Это не оставляет нам много возможных сообщений, определенно недостаточно для стандартной коммуникации. Кроме того, эти сообщения должны быть выбраны случайным образом. Это кажется несколько непрактичным. Наконец, любое сообщение, выбранное дважды, приведет к точно такому же шифротексту. Это крайне нежелательно в любой схеме шифрования и не соответствует никаким строгим современным стандартам безопасности в шифровании.

Проблемы становятся еще хуже для нашей прямолинейной схемы цифровой подписи. Как оно есть, любой атакующий может легко подделать цифровые подписи, просто сначала выбрав взаимно простое с N в качестве подписи, а затем вычислив соответствующее исходное сообщение. Это явно нарушает требование о невозможности подделки.

Тем не менее, добавив немного изобретательной сложности, задачу RSA можно использовать для создания безопасной схемы шифрования с открытым ключом, а также безопасной схемы цифровой подписи. Мы не будем вдаваться в детали таких конструкций здесь.<sup>[4](#footnote4)</sup> Важно, однако, что эта дополнительная сложность не меняет фундаментальную основополагающую задачу RSA, на которой основаны эти схемы.

### Примечания

[^1]: Факторизация также может быть важна для работы с другими типами математических объектов, кроме чисел. Например, она может быть полезна для факторизации полиномиальных выражений, таких как x^2 – 2x + 1. В нашем обсуждении мы будем сосредотачиваться только на факторизации чисел, в частности целых чисел [^1].
[^2]: Согласно теореме о простых числах, количество простых чисел, меньших или равных N, приблизительно равно N/ln(N). Это означает, что вы можете приблизительно оценить количество простых чисел длиной в 1024 бита как 2^1024/ln(2^1024) - 2^1023/ln(2^1023), что равно приблизительно 1.265 x 10^305 [^2].

# Вклады
<partId>4556aab1-4876-552a-b6db-df6837bbf27a</partId>

## О книге
<chapterId>ff08a57b-740f-5d7e-8cf2-81db0908166e</chapterId>

Любые вклады приветствуются. Прежде чем делать вклад, пожалуйста, ознакомьтесь с нижеприведенной информацией о моих планах на книгу, а также с рекомендациями по внесению вкладов.

### Текущие планы

Мои текущие планы по дальнейшему развитию книги следующие:

- Создать заключительную главу, которая будет посвящена деталям практического применения криптографии, таких как безопасность транспортного уровня, маршрутизация через луковицу и обмен ценностями в Bitcoin.
- Создать лучшие и более наглядные рисунки и диаграммы для поддержки письменного обсуждения.
- Использовать LaTeX Math или какое-либо другое приложение для набора формул (вместо простого Markdown).

### Рекомендации для вкладов

Если у вас есть небольшие исправления или предложения по существующему тексту, вы можете создать pull request или поднять issue. Если вы создаете pull request, пожалуйста, учитывайте следующие рекомендации:

- Создавайте коммиты в отдельной ветке в вашем форке репозитория.
- Ясно обозначайте коммиты.
- Создавайте отдельные коммиты для логически различных вопросов, чтобы упростить процесс рецензирования.

Если у вас есть более существенные предложения по книге, пожалуйста, поднимите issue или свяжитесь со мной напрямую по адресу **jaburgers@protonmail.com**.

### Лицензия

Работа в этом репозитории лицензирована по лицензии Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0).

Краткое описание лицензии можно найти [здесь](https://creativecommons.org/licenses/by-nc-nd/4.0/).

Полная версия лицензии доступна [здесь](https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode).

## Обозначения
<chapterId>07250f8d-ad7c-5531-a70c-4417d6d1b865</chapterId>

### Ключевые термины

Ключевые термины в первичных источниках выделяются жирным шрифтом. Например, введение шифра Рейндал как ключевого термина будет выглядеть следующим образом: **шифр Рейндал**.

Ключевые термины явно определяются, если только они не являются собственными именами или их значение очевидно из обсуждения.

Определение обычно даётся при введении ключевого термина, хотя иногда более удобно оставить определение до более позднего момента.

### Выделенные слова и фразы

Слова и фразы выделяются курсивом. Например, фраза "Помните ваш пароль" будет выглядеть следующим образом: *Помните ваш пароль*.

### Формальные обозначения

Формальные обозначения в основном касаются переменных, случайных переменных и множеств.

* Переменные: Обычно они просто обозначаются строчной буквой (например, "x" или "y"). Иногда они пишутся с заглавной буквы для ясности (например, "M" или "K").
* Случайные переменные: Всегда обозначаются заглавной буквой (например, "X" или "Y").
* Множества: Они всегда обозначаются жирным шрифтом, заглавными буквами (например, **S**)