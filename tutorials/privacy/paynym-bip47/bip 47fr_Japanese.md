名前：BIP47 - PayNym

説明：PayNym の動作原理

# BIP47、かわいそうな小さなアヒル

> 「彼は大きすぎる」とみんなが言った。トルコの雄鶏はトゲを持って生まれ、自分が皇帝だと思い込んでいた。彼は全速力で膨らみ、怒りに震えながらまっすぐに歩いてきた。かわいそうなアヒルは立ち止まるべきか歩き続けるべきかわからなかった。彼は宮廷のアヒルたちに嘲笑されることに悲しみを感じた。

![BIP47、かわいそうな小さなアヒルのイラスト](assets/1.png)

ビットコインプロトコルにおける最も重要な問題の一つは、アドレスの再利用です。ネットワークの透明性と分散性により、この慣行はユーザーのプライバシーに対して危険です。この問題を回避するためには、新しい受信アドレスを使用して新しい入金に対応することが推奨されていますが、特定の場合には複雑な手続きが必要です。

この妥協案は、ホワイトペーパーの時代から存在しています。サトシは 2008 年末に公開された彼の著作で、このリスクに対する警告を既に行っていました。

> "追加のファイアウォールとして、各トランザクションに新しいキーペアを使用して、それらを共通の所有者に関連付けないようにすることができる。"

複数の支払いを受け取るためのさまざまな解決策が存在しますが、アドレスの再利用を避けるものもあります。それぞれには妥協点と欠点があります。これらの解決策の中には、[BIP47](https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki)という提案があります。これは Justus Ranvier によって開発され、2015 年に公開されたもので、再利用可能な支払いコードを生成することができます。その目的は、同じ人物に対して複数のトランザクションを行うことができるようにすることですが、アドレスの再利用は行いません。

最初は、この提案はコミュニティの一部から軽蔑され、Bitcoin Core には追加されませんでした。しかし、一部のソフトウェアは独自に実装することを選びました。例えば、[Samourai Wallet](https://samouraiwallet.com/)は BIP47 の独自の実装である PayNym を開発しました。現在、この実装はもちろんスマートフォン用の Samourai Wallet で利用できますが、PC 用の[Sparrow Wallet](https://sparrowwallet.com/)でも利用できます。

時間の経過とともに、Samourai は PayNym に関連する新機能をプログラムしました。現在、PayNym と BIP47 を基にしたユーザーのプライバシーを最適化するためのツールのエコシステムが存在します。
この記事では、BIP47 と PayNym の原則、これらのプロトコルのメカニズム、およびそれに基づく実用的なアプリケーションについて説明します。私は BIP47 の最初のバージョンについてのみ取り上げますが、PayNym で現在使用されているバージョンですが、バージョン 2、3、および 4 はほぼ同じ方法で機能します。

> 唯一の主な違いは、通知トランザクションのレベルにあります。バージョン 1 では、通知に OP_RETURN を使用した単純なアドレスを使用し、バージョン 2 では OP_RETURN を使用したマルチシグスクリプト（bloom-multisig）を使用し、バージョン 3 および 4 では単にマルチシグスクリプト（cfilter-multisig）を使用します。この記事で説明されているメカニズム、特に研究されている暗号化手法は、したがって 4 つのバージョンに適用できます。現時点では、Samourai Wallet と Sparrow での PayNym の実装は、BIP47 の最初のバージョンを使用しています。

## 目次：

1- アドレスの再利用の問題。

2- BIP47 と PayNym の原則。

3- チュートリアル：PayNym の使用。

- Samourai Wallet での BIP47 トランザクションの構築。

- Sparrow Wallet での BIP47 トランザクションの構築。

4- BIP47 の仕組み。

- 再利用可能な支払いコード。
- 暗号化手法：楕円曲線上で確立された Diffie-Hellman 鍵交換（ECDH）。

- 通知トランザクション。
- 通知トランザクションの構築。
- 通知トランザクションの受信。
- BIP47 支払いトランザクション。
- BIP47 支払いの受信と秘密鍵の派生。
- BIP47 支払いの返金。

5- PayNym の派生的な使用法。

6- BIP47 に対する私の個人的な意見。

## アドレスの再利用の問題。

受信アドレスはビットコインを受け取るために使用されます。それは公開鍵から生成され、ハッシュ化され、特定の形式が適用されます。これにより、コインの新しい支出条件が作成され、所有者を変更することができます。

> 受信アドレスの生成について詳しくは、この記事の最後の部分を読むことをお勧めします：Le portefeuille Bitcoin - extrait [ebook Bitcoin Démocratisé 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2#viewer-epio7)。

また、おそらくビットコインのエキスパートから、受信アドレスは一度しか使用できず、新しい支払いがあるたびに新しいアドレスを生成する必要があると聞いたことがあるでしょう。それはわかりますが、なぜですか？
基本的に、アドレスの再利用は直接的に資金を危険にさらすことはありません。楕円曲線暗号の使用により、秘密鍵を明かさずにネットワークに対して自分が秘密鍵を持っていることを証明することができます。したがって、同じアドレスに複数の異なる UTXO（未使用のトランザクション出力）をロックし、異なるタイミングでそれらを使うことができます。このアドレスに関連付けられた秘密鍵を明かさなければ、誰もあなたの資金にアクセスすることはできません。アドレスの再利用の問題は、プライバシーの問題です。

導入で述べたように、ビットコインネットワークの透明性と分散性により、ノードにアクセスできる限り、どのユーザーでも支払いシステムのトランザクションを観察することができます。そのため、異なるアドレスの残高を見ることができます。そのため、新しい支払いがウォレットに入金されるたびに、新しいキーペアと新しいアドレスを生成する可能性があります。その目的は、ユーザーの身元とそのキーペアの関連付けの場合に備えた追加の防火壁を持つことです。

今日では、チェーン分析会社の存在や KYC の発展により、空のアドレスの使用は追加の防火壁ではなく、個人のプライバシーに最低限の関心を持つ人々にとっては義務となっています。

プライバシーの追求は、ビットコインの最大主義者の快適さや幻想ではありません。これは、個人の安全性と資金の保護に直接関わる特定のパラメータです。理解してもらうために、具体的な例を挙げます：

- ボブは DCA（ドルコスト平均法）でビットコインを購入します。つまり、定期的な間隔で少額のビットコインを購入し、購入価格を平準化します。ボブは毎週 0.01 ビットコインを購入し、同じアドレスに送金します。2 年後、ボブはこのアドレスに 1 ビットコインを蓄積しています。

- ボブの近所のパン屋はビットコインで支払いを受け付けます。ビットコインを使ってパンを買うことができることに喜んだボブは、サトシでパンを買いに行きます。支払いには、彼のアドレスにロックされた資金を使用します。パン屋は今や彼が 1 ビットコインを持っていることを知っています。この大きな金額は嫉妬を引き起こす可能性があり、ボブは将来的に身体的な攻撃を受ける可能性があります。

したがって、アドレスの再利用により、観察者が異なる UTXO と、場合によってはあなたの身元と全体のウォレットを結び付けることができます。
これが、ほとんどの Bitcoin ウォレットソフトウェアが、「受信」ボタンをクリックすると自動的に新しい受信アドレスを生成する理由です。通常のユーザーにとって、空のアドレスを使用する習慣を身につけることは大きな不便ではありません。しかし、オンラインのビジネス、取引所、または寄付キャンペーンの場合、この制約はすぐに取り扱いが困難になる可能性があります。

これらの組織には多くの解決策があります。それぞれに利点と欠点がありますが、今日では、他の解決策とは異なる BIP47 が実際に異なることがわかります。

アドレスの再利用の問題は、Bitcoin において無視できないものです。[oxt.me](http://oxt.me/)のウェブサイトから抜粋した以下のグラフでわかるように、Bitcoin ユーザーによるアドレスの再利用率は現在 52％です。

![image](assets/2.png)

クレジット：https://oxt.me/charts

これらの再利用の大部分は、効率と利便性のために同じアドレスを何度も再利用する取引所から発生しています。現時点では、BIP47 が取引所でこの現象を抑制するための最良の解決策であるとされています。これにより、アドレスの再利用率を低下させることができますが、これらのエンティティに対してあまり多くの摩擦を引き起こすことはありません。

この全体的な対策は、この場合に特に一貫性のあるデータです。実際、アドレスの再利用は、このような実践を行う個人だけでなく、その個人と取引を行うすべての人にとって問題です。Bitcoin 上のプライバシーの喪失はウイルスのように作用し、ユーザーからユーザーへと広がります。ネットワーク全体のトランザクションに対する全体的な対策を研究することで、この現象の大きさに気づくことができます。

## BIP47 と PayNym の原則

BIP47 は、アドレスの再利用を行わずに多くの支払いを受け取る簡単な方法を提供することを目指しています。その動作は、再利用可能な支払いコードの使用に基づいています。

したがって、複数の送信者が別のユーザーの再利用可能な支払いコードに複数の支払いを送信できますが、受信者は新しい空のアドレスを毎回送信する必要はありません。

ユーザーは、受け取りアドレスや公開鍵とは異なり、支払いコードを自由に共有することができ、プライバシーの損失のリスクがありません。
送金を行うために、両方のユーザーは Samourai Wallet や Sparrow Wallet のような BIP47 の実装を持つ Bitcoin ウォレットを持っている必要があります。両ユーザーの支払いコードの関連付けにより、彼らの間に秘密のチャネルを確立することができます。このチャネルを正しく確立するために、送信者は Bitcoin チェーン上で通知トランザクションを行う必要があります（後ほど詳しく説明します）。

両ユーザーの支払いコードの関連付けにより、共有されたシークレットが生成され、それ自体が Bitcoin の受信アドレス（厳密には 2^32 個）を生成するために使用されます。したがって、BIP47 による支払いは、支払いコード宛てではなく、プロトコルの支払いアドレス宛てに送信されます。

支払いコードは、ウォレットのシードから派生した仮想的な識別子として機能します。HD ウォレットの派生構造では、支払いコードはウォレットのアカウントレベルで深さ 3 にあります。

![image](assets/3.png)

BIP47 に関連付けられた派生パスは、47'（0x8000002F）と表記されます。再利用可能な支払いコードの派生パスの例は次のとおりです：

> m/47'/0'/0'/

支払いコードの例を想像していただくために、私の支払いコードを示します：

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

これは QR コードにエンコードされ、コミュニケーションを容易にすることもできます：

![image](assets/4.png)

PayNym Bots については、Twitter で見かけるこれらのロボットは、単に Samourai Wallet によって作成された支払いコードの視覚的な表現です。ハッシュ関数によって生成されるため、ほぼユニークです。以下は、私の支払いコードとその識別子です：

> +throbbingpond8B1

![image](assets/5.png)

これらの Bots には実際の技術的な利点はありません。代わりに、仮想的な視覚的なアイデンティティを作成することで、ユーザー間の相互作用を容易にする役割を果たしています。

ユーザーにとって、PayNym の実装を使用した BIP47 の支払いプロセスは非常にシンプルです。例えば、Alice が Bob に支払いを送りたいとします：

1. Bob は自身の QR コードまたは再利用可能な支払いコードを公開します。これを自身のウェブサイトやさまざまな公開されたソーシャルネットワークに掲載するか、別のコミュニケーション手段を介して Alice に送信することができます。
2. アリスは Samourai または Sparrow というソフトウェアを開き、ボブの支払いコードをスキャンまたは貼り付けます。
3. アリスは自分の PayNym をボブの PayNym と関連付けます（英語では「Follow」）。この操作はブロックチェーンの外で行われ、完全に無料です。

4. アリスは自分の PayNym をボブの PayNym と接続します（英語では「Connect」）。この操作は「on chain」で行われます。アリスはトランザクションのマイニング手数料と、Samourai のサービスに対する固定手数料（15,000 sats）を支払う必要があります。Sparrow ではサービス手数料は提供されていません。このステップは、通知トランザクションと呼ばれます。

5. 通知トランザクションが確認されると、アリスはボブ宛に BIP47 支払いトランザクションを作成することができます。彼女のウォレットは自動的に、ボブだけが秘密鍵を持つ新しい受信アドレスを生成します。

通知トランザクションを実行すること、つまり PayNym を接続することは、BIP47 支払いを行うための前提条件です。ただし、この操作が完了すると、送信者は通知トランザクションを再度実行する必要なく、受信者に対して複数の支払い（2^32 個まで）を行うことができます。

PayNym をリンクさせるための 2 つの異なる操作があることがわかりました：リンクと接続。接続操作（"connecter"）は、BIP47 の通知トランザクションに対応し、特定の情報を OP_RETURN 出力を介して送信することで、単に Bitcoin トランザクションです。これにより、2 つのユーザー間で暗号化された通信を確立し、新しい受信アドレスを生成するために必要な共有シークレットを生成するのに役立ちます。

一方、リンク操作（"follow"または"relier"）は、Samourai チームによって特別に開発された Tor ベースの暗号化通信プロトコルである Soroban 上でリンクを確立するためのものです。

要約すると：

- 2 つの PayNym をリンクさせる（"follow"）ことは完全に無料です。これにより、Samourai の共同トランザクションツール（Stowaway または StonewallX2）を使用するために、オフチェーンでの暗号化通信が確立されます。この操作は PayNym 固有のものであり、BIP47 には記載されていません。

- 2 つの PayNym を接続することは有料です。これには通知トランザクションを実行して接続を開始する必要があります。その費用には、サービス手数料、トランザクションのマイニング手数料、およびトンネルの開通を受信者に通知するために送信される 546 sats が含まれます。この操作は BIP47 に関連しています。一度実行されると、送信者は受信者に対して複数の BIP47 支払いを行うことができます。

2 つの PayNym を接続するためには、それらがすでにリンクされている必要があります。

## チュートリアル：PayNym の使用方法。

理論を見たので、実際に学んでみましょう。以下のチュートリアルのアイデアは、Sparrow ウォレットの PayNym と Samourai ウォレットの PayNym を接続することです。最初のチュートリアルでは、Samourai から Sparrow に再利用可能な支払いコードを使用してトランザクションを行う方法を示し、2 番目のチュートリアルでは、Sparrow から Samourai に同じメカニズムを説明します。

> これらのチュートリアルはテストネットで行われました。これらは実際のビットコインではありません。

### Samourai ウォレットで BIP47 トランザクションを作成する。

まず、もちろん Samourai ウォレットアプリが必要です。Google Play ストアから直接ダウンロードするか、Samourai の公式サイトで利用可能な APK ファイルを使用してダウンロードできます。

ウォレットを初期化したら、まだ行っていない場合は、右下のプラス（+）をクリックして「PayNym」をクリックして PayNym を要求します。

BIP47 支払いを行うための最初のステップは、受信者の再利用可能な支払いコードを取得することです。その後、それと接続し、その後接続します：

![video](assets/6.mp4)

通知トランザクションが確認されたら、受信者に複数の支払いを送信できます。各トランザクションは、受信者がキーを持つ新しい空のアドレスで自動的に行われます。受信者は何もする必要はありません、すべて私の側で計算されます。

Samourai ウォレットで BIP47 トランザクションを行う方法は次のとおりです：

![video](assets/7.mp4)

### Sparrow ウォレットで BIP47 トランザクションを作成する。

Samourai と同様に、Sparrow ソフトウェアが必要です。これはコンピュータ上で利用できます。[公式ウェブサイト](https://sparrowwallet.com/)からダウンロードできます。

インストールする前に、開発者の署名とダウンロードしたソフトウェアの完全性を確認してください。

ウォレットを作成し、上部のメニューの「ツール」から「Show PayNym」をクリックして PayNym を要求します：

![image](assets/8.png)

次に、相手の PayNym と自分の PayNym をリンクして接続する必要があります。これを行うには、「Find Contact」ウィンドウに再利用可能な支払いコードを入力し、それに従って、[Link Contact]をクリックして通知トランザクションを行います：

![image](assets/9.png)

通知トランザクションが確認されたら、再利用可能な支払いコードに支払いを送信できます。以下は手順です：

![video](assets/10.mp4)

BIP47 の PayNym 実装の実践的な側面を学んだので、これらのメカニズムがどのように機能し、どのような暗号化手法が使用されているかを見てみましょう。

## BIP47 の仕組み。

BIP47 のメカニズムを研究するためには、階層的決定論的ウォレット（HD ウォレット）の構造、子鍵の導出メカニズム、および楕円曲線上の暗号化の原則を理解することが不可欠です。幸いなことに、この部分の理解に必要な情報は、私のブログですべて見つけることができます：

- [ビットコインウォレットの導出パスの理解](https://www.pandul.fr/post/comprendre-les-chemins-de-d%C3%A9rivation-d-un-portefeuille-bitcoin)

- [ビットコインウォレット - Bitcoin Démocratisé 2 の抜粋](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2)

### 再利用可能な支払いコード

この論文の第 2 部で説明されているように、再利用可能な支払いコードは HD ウォレットの深さ 3 にあります。その配置や構造、役割において、xpub といくらか似ています。

80 バイトの支払いコードを構成するさまざまな部分は次のとおりです：

- バイト 0：バージョン。BIP47 の最初のバージョンを使用する場合、このバイトは 0x01 になります。

- バイト 1：ビットフィールド。特定の使用方法に関する追加の情報を提供するために予約されています。単に PayNym を使用する場合、このバイトは 0x00 になります。

- バイト 2：y の偶奇。このバイトは、公開鍵の y 座標の偶奇（偶数または奇数）に応じて 0x02 または 0x03 を示します。この実践についての詳細は、この記事の「アドレスの導出」のステップ 1 をお読みください。

- バイト 3 からバイト 34：x の値。これらのバイトは、公開鍵の x 座標を示します。x と y の偶奇の連結により、圧縮された公開鍵が得られます。

- バイト 35 からバイト 66：チェーンコード。この領域は、前述の公開鍵に関連するチェーンコードに予約されています。

- バイト 67 からバイト 79：パディング。この領域は、将来の進展のために予約されています。バージョン 1 では、80 バイト（OP_RETURN 出力のデータサイズ）に埋めるために単にゼロを入れます。

以下は、前の部分で紹介した再利用可能な支払いコードの 16 進数表現であり、上記のバイトに対応する色が付いています：

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4

次に、支払いコードであることを一目で識別するために、プレフィックスのバイト「P」を追加する必要があります。このバイトは 0x47 です。

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000

最後に、この支払いコードのチェックサムを HASH256 で計算します。つまり、SHA256 関数を使用してダブルハッシュを行います。このハッシュの最初の 4 バイトを取得し、最後に連結します（ピンクで表示）。

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4

支払いコードは準備ができました。最後に、Base 58 に変換するだけです。

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

この構造は、「xpub」というタイプの拡張公開鍵の構造に非常に似ていることにお気づきかもしれません。

この支払いコードを作成するプロセスでは、圧縮された公開鍵とチェーンコードを使用しました。これらの要素は、ウォレットのシードから決定論的かつ階層的に派生されたものであり、次の派生パスをたどっています：m/47'/0'/0'/。
具体的には、再利用可能な支払いコードの公開鍵とチェーンコードを取得するために、シードからマスタープライベートキーを計算し、派生させた子ペアをインデックス 47 + 2^31（強化派生）で派生させます。その後、インデックス 2^31（強化派生）で 2 回子ペアを派生させます。

> ビットコインの階層的決定ウォレット内での子鍵の派生について詳しく知りたい場合は、CRYPTO301 を参照してください。

### 暗号化方式：楕円曲線上の Diffie-Hellman 鍵交換（ECDH）

BIP47 の基礎となる暗号化方式は、ECDH（楕円曲線上の Diffie-Hellman 鍵交換）です。このプロトコルは、通常の Diffie-Hellman 鍵交換の変種です。

Diffie-Hellman は、1976 年に提案された鍵合意プロトコルであり、2 つの人物が 2 つの鍵ペア（公開鍵と秘密鍵）を使用して、非安全な通信チャネルを介して共有秘密を決定することを可能にします。

![image](assets/11.png)

この共有秘密（赤い鍵）は、他のタスクを実行するために使用することができます。通常、この共有秘密を使用して、非安全なネットワーク上での通信の暗号化と復号化を行うことができます。

![image](assets/12.png)

Diffie-Hellman は、共通の色（ここでは黄色）を決定します。この色はすべてに知られている公開データです。

Alice は秘密の色（ここでは赤）を選びます。彼女は 2 つの色を混ぜてオレンジを作ります。

Bob は秘密の色（ここではカーキブルー）を選びます。彼は 2 つの色を混ぜてスカイブルーを作ります。

Alice と Bob は、オレンジとスカイブルーの色を交換することができます。この交換は、攻撃者によって監視される非安全なネットワーク上で行われる可能性があります。

Alice は Bob から受け取ったスカイブルーの色を彼女の秘密の色（赤）と混ぜます。彼女は茶色を得ます。

Bob は Alice から受け取ったオレンジの色を彼の秘密の色（カーキブルー）と混ぜます。彼も同じ茶色を得ます。

![image](assets/13.png)

> クレジット：オリジナルアイデア：A.J. Han Vinck ベクトルバージョン：Flugaal 翻訳：Dereckson、パブリックドメイン、via Wikimedia Commons. https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange_(fr).svg
> この解説では、茶色はアリスとボブの間で共有される秘密を表しています。実際には、攻撃者がオレンジ色とスカイブルーの色を分離してアリスやボブの秘密の色を取り戻すことは不可能です。

さて、実際の動作を見てみましょう。最初に見ると、Diffie-Hellman は理解するのが複雑に思えます。しかし、実際には、その動作原理は非常に単純です。メカニズムの詳細を説明する前に、必要となる 2 つの数学的概念を簡単に思い出しておきます（そして、偶然にも、これらは多くの他の暗号化方法でも使用されています）。

1. 素数は、1 とそれ自体の 2 つの約数しか持たない自然数です。例えば、数字 7 は素数です。なぜなら、1 と 7（それ自体）でしか割ることができません。一方、数字 8 は素数ではありません。なぜなら、1、2、4、8 で割ることができるからです。したがって、8 は 2 つの約数だけでなく、4 つの整数で割り切れるのです。

2. "モジュロ"（"mod"または"%"と表記される）は、2 つの整数の間で行われる数学的操作であり、最初の数を 2 番目の数で割った余りを返します。例えば、16 mod 5 は 1 となります。

アリスとボブの間の Diffie-Hellman 鍵交換は次のように機能します：

- アリスとボブは、2 つの共通の数、p と g を決定します。p は素数です。p が大きいほど、Diffie-Hellman はより安全になります。g は p の原始根です。これら 2 つの数は、上記の解説での黄色の相当物です。アリスとボブは、p と g の値が完全に一致している必要があります。

- パラメータが選択されたら、アリスとボブはそれぞれ秘密のランダムな数を決定します。アリスが得たランダムな数を a（赤色の相当物）とし、ボブが得たランダムな数を b（スカイブルーの相当物）とします。これら 2 つの数は秘密のままでなければなりません。

- 数字 a と b を交換する代わりに、各パーティは A（大文字）と B（大文字）を計算します：

> A は、g の a 乗を p で割った余りと等しい：
> A = g^a % p

> B は、g の b 乗を p で割った余りと等しい：
> B = g^b % p

- これらの数 A（オレンジの相当物）と B（スカイブルーの相当物）は、両方のパーティ間で交換されます。交換は、セキュリティのないネットワーク上で平文で行われることができます。

- B の値を知ったアリスは、z の値を計算します：

> z は、B の a 乗を p で割った余りと等しい：
> z = B^a % p

- リマインダーとして、B = g^b % p です。したがって、次のようになります：

  > z = B^a % p
  > z = (g^b)^a % p
  >
  > べき乗の計算ルールに従って：
  >
  > (x^n)^m = x^nm
  >
  > したがって、次のようになります：
  >
  > z = g^ba % p

- A を知っている Bob も、次のように z の値を計算します：

> z は A の b 乗を p で割った余りと等しい：
>
> z = A^b % p
>
> したがって、次のようになります：
>
> z = (g^a)^b % p
> z = g^ab % p
> z = g^ba % p

モジュロ演算子の分配性により、Alice と Bob はまったく同じ値 z を見つけることができます。この数値は彼らの共通の秘密を表し、前述の説明での茶色の色の相当物です。彼らはこの共通の秘密を使用して、セキュリティのないネットワーク上での相互通信を暗号化することができます。

![Diffie-Hellmanの技術的な動作の図](assets/14.png)

p、g、A、B を持つ攻撃者は、a、b、または z を計算することはできません。この操作を行うことは、指数関数の逆演算を行うことに等しいからです。有限体上で作業しているため、この計算は一度にすべての可能性を試す以外には不可能です。これは離散対数の計算、つまり有限巡回群での指数関数の逆数を計算することに等しいです。

したがって、a、b、および p を十分に大きな値で選択する限り、Diffie-Hellman は安全です。典型的には、2,048 ビットのパラメータ（10 進数で 600 桁の数）を使用すると、a と b のすべての可能性をテストすることは現実的ではありません。現在、このサイズの数値では、このアルゴリズムは安全とされています。

これが Diffie-Hellman プロトコルの主な欠点です。安全性を確保するためには、アルゴリズムは大きな数値を使用する必要があります。その結果、現在では、楕円曲線を使用する Diffie-Hellman の変種である ECDH アルゴリズムが好まれます。これにより、計算とストレージに必要なリソースを削減しながら、同等のセキュリティを維持するために、はるかに小さな数値で作業することができます。

アルゴリズムの一般的な原則は同じですが、乱数 a と乱数 A を使用して指数関数のモジュラ演算を行う代わりに、楕円曲線上で確立された鍵のペアを使用します。モジュロ演算子の分配性に頼る代わりに、ここでは楕円曲線上の群の法則、具体的にはその結合法則を使用します。

> 楕円曲線上の秘密鍵と公開鍵の動作について何の知識も持っていない場合、この記事の最初の 6 つの部分でこの方法の基礎を説明します。

大まかに言えば、秘密鍵は 1 から n-1 までのランダムな数であり（n は曲線の次数）、公開鍵は秘密鍵によって決定される曲線上の一意の点であり、生成点からの点の加算と倍加によって決定されます。

> K = k·G

ここで、K は公開鍵、k は秘密鍵、G は生成点です。

この鍵ペアの特性の 1 つは、k と G がわかっている場合に K を非常に簡単に決定できるが、K と G がわかっている場合に k を決定することは現在不可能であるということです。これは一方向関数です。

言い換えると、秘密鍵がわかっている場合に公開鍵を簡単に計算できますが、公開鍵がわかっている場合に秘密鍵を計算することはできません。このセキュリティは離散対数の計算が不可能であることに基づいています。

したがって、この特性を利用して Diffie-Hellman アルゴリズムを適応します。したがって、ECDH の動作原理は次のとおりです：

- Alice と Bob は、暗号的に安全な楕円曲線とそのパラメータを共同で合意します。これらの情報は公開されます。

- Alice は、秘密鍵となるランダムな数 ka を生成します。この秘密鍵は秘密に保たれる必要があります。彼女は選択した楕円曲線上での点の加算と倍加によって彼女の公開鍵 Ka を決定します。

> Ka = ka·G

- Bob も同様に、秘密鍵となるランダムな数 kb を生成します。そして、関連する公開鍵 Kb を計算します。

> Kb = kb·G

- Alice と Bob は、公開されていないネットワーク上で互いの公開鍵 Ka と Kb を交換します。

- Alice は、Bob の公開鍵 Kb から彼女の秘密鍵 ka を適用して曲線上の点(x,y)を計算します。

> (x,y) = ka·Kb

- Bob は、Alice の公開鍵 Ka から彼の秘密鍵 kb を適用して曲線上の点(x,y)を計算します。

> (x,y) = kb·Ka

- Alice と Bob は、楕円曲線上で同じ点を得ます。共有される秘密は、この点の x 座標です。

彼らは同じ共有秘密を得るので、

> (x,y) = ka·Kb = ka·kb·G = kb·ka·G = kb·Ka

公開されていないネットワークを監視する潜在的な攻撃者は、各自の公開鍵と選択された曲線のパラメータのみを取得することができます。先に説明したように、これらの 2 つの情報だけでは秘密鍵を決定することはできず、したがって攻撃者は秘密にアクセスすることはできません。
ECDH は鍵交換を可能にするアルゴリズムです。通常、他の暗号化方法と組み合わせてプロトコルを定義するために使用されます。例えば、ECDH は TLS（Transport Layer Security）の中核で使用されます。TLS はインターネットのトランスポート層で使用される暗号化と認証のプロトコルです。TLS は鍵交換のために ECDHE を使用し、鍵が一時的であるために持続的な機密性を提供します。TLS は ECDSA のような認証アルゴリズム、AES のような暗号化アルゴリズム、および SHA256 のようなハッシュ関数も使用します。

TLS は「https」の「s」や、ブラウザの左上に表示される小さな鍵マークを定義しており、通信の暗号化を保証します。したがって、この記事を読んでいる間は ECDH を使用しており、おそらく気づかずに毎日使用しています。

### 通知トランザクション

前のセクションで説明したように、ECDH は楕円曲線上で確立された鍵ペアを使用する Diffie-Hellman 鍵交換の一種です。幸いなことに、Bitcoin の階層的決定性ウォレットにはこの標準を満たす鍵ペアがたくさんあります。

したがって、Bitcoin Improvement Proposal 47（BIP47）では、関係者の両方の階層的決定性 Bitcoin ウォレットの鍵ペアを使用して、彼らの間で共有される一時的な秘密を確立することが提案されています。BIP47 では、ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）が使用されます。

BIP47 では、最初に ECDHE が使用され、送信者から受信者への支払いコードが送信されます。これが有名な通知トランザクションです。実際、BIP47 を使用するためには、支払いを送信する送信者と支払いを受け取る受信者の両方が相手の支払いコードを知っている必要があります。これは一時的な公開鍵と専用の受信アドレスを派生させるために必要です。

この交換の前に、送信者は受信者の支払いコードを既に知っているはずです。たとえば、ウェブサイトやソーシャルメディアなどでオフチェーンで取得できるからです。一方、受信者は送信者の支払いコードを必ずしも知らないかもしれません。そのため、送信者から受信者に支払いコードを伝える必要があります。そうしないと、受信者は一時的な鍵を派生させることができず、自分のビットコインの場所を知ることができず、資金を解放することができません。これをオフチェーンで伝えることもできますが、ウォレットのシードからの復元時に問題が発生する可能性があります。
実際に、私がすでに触れたように、BIP47 アドレスは受信者のシードから派生していません（そうでなければ、直接 xpub の 1 つを使用すればよいです）、しかし、受信者と送信者の 2 つの支払いコードを含む計算の結果です。したがって、受信者がウォレットを紛失し、シードから回復しようとする場合、BIP47 を介してビットコインを送った人々のすべての支払いコードを持っている必要があります。

したがって、通知トランザクションなしで BIP47 を簡単に使用することができますが、各ユーザーがピアの支払いコードのバックアップを作成する必要があります。この状況は、バックアップを作成し、保存し、最新の状態に保つための簡単で堅牢な方法が見つかるまで、管理できないままです。したがって、現在の状況では、通知トランザクションはほぼ必須です。

支払いコードのバックアップの役割に加えて、その名前が示すように、このトランザクションは受信者への通知の役割も果たします。これにより、クライアントにトンネルが開かれたことが通知されます。

通知トランザクションの技術的な動作について詳しく説明する前に、プライバシーモデルについて少し話したいと思います。実際に、BIP47 のモデルは、この初期トランザクションの構築時に取られるいくつかの注意を正当化します。

支払いコード自体は直接的なプライバシーの損失のリスクを構成しません。ユーザーのアイデンティティとトランザクションの間の情報フローを分断することができるビットコインのクラシックモデルとは異なり、公開鍵を匿名に保持することで、支払いコードは直接的にアイデンティティに関連付けることができます。これは必須ではありませんが、この関連は危険ではありません。

実際に、支払いコードは BIP47 の支払いを受け取るために使用されるアドレスを直接的に派生させません。代わりに、アドレスは双方の支払いコードの子キー間で ECDHE を適用することで取得されます。

したがって、支払いコード単体では直接的なプライバシーの損失のリスクを構成しません。いくつかの情報を得ることはできますが、通常は誰と取引しているかはわかりません。

したがって、ユーザーの支払いコードの間には厳格な分離を維持することが重要です。この目的のために、コードの初期通信ステップは支払いのプライバシーにとって重要な時点であり、プロトコルの正常な動作のために必須です。たとえば、2 つの支払いコードのうち 1 つが公に回収可能な場合（たとえば、ウェブサイト上で）、2 番目のコード、つまり送信者のコードは最初のコードと関連付けられてはいけません。

例えば、私が BIP47 を使用してカナダの平和的な抗議運動に寄付をしたいとします：

- この組織は、支払いコードを直接ウェブサイトやソーシャルメディアに公開しています。
- したがって、このコードは運動に関連付けられています。

- 私はこの支払いコードを取得します。

- トランザクションを送信する前に、私は彼らが私の個人的な支払いコードを知っていることを確認する必要があります。この支払いコードは私のアイデンティティにも関連付けられています。なぜなら、私はソーシャルメディアからトランザクションを受け取るために使用しているからです。

どのようにそれを彼らに伝えることができますか？通常のコミュニケーション手段で送信すると、情報が漏れる可能性があり、平和的な運動を支持する人物として登録される可能性があります。

通知トランザクションは、送信者の支払いコードを秘密裏に伝えるための唯一の解決策ではありませんが、複数のセキュリティレイヤーを適用することで、現時点ではこの役割を完全に果たしています。

以下の図では、赤い線は情報フローが切断される時点を示し、黒い矢印は外部の観察者が行うことができる明確な関連付けを示しています：

![支払いコードのプライバシーモデルのスキーマ](assets/15.png)

実際には、Bitcoin のクラシックなプライバシーモデルでは、キーペアとユーザー間の情報フローを完全に切断することはしばしば困難です。特にリモートでトランザクションを行う場合にはそうです。たとえば、寄付キャンペーンの場合、受取人はウェブサイトやソーシャルメディアでアドレスや公開鍵を公開する必要があります。BIP47 の適切な使用、つまり通知トランザクションを使用することで、ECDHE と私たちが学ぶ暗号化レイヤーによってこれを解決することができます。

もちろん、Bitcoin のクラシックなプライバシーモデルは、2 つの支払いコードの関連付けから派生した一時的な公開鍵のレベルで常に観察されます。両方のモデルは相互に依存しています。ここでは、ビットコインを受け取るための公開鍵の通常の使用とは異なり、支払いコードはアイデンティティに関連付けることができることを明示的に示したいと思います。なぜなら、「Bob が Alice とトランザクションを行う」という情報は別の時点で切断されるからです。支払いコードは支払いアドレスを生成するために使用されますが、ブロックチェーンだけを観察しても、BIP47 の支払いトランザクションをそれを実行するために使用された支払いコードに関連付けることはできません。

### 通知トランザクションの構築

さて、この通知トランザクションの動作を見てみましょう。Alice が BIP47 を使用して Bob に資金を送りたいとします。私の例では、Alice は送信者として、Bob は受信者として行動します。Bob は自分の支払いコードをウェブサイトに公開しています。したがって、Alice はすでに Bob の支払いコードを知っています。

1. Alice は ECDH で共有秘密を計算します：

- 彼女は支払いコードのコードとは異なるブランチにある彼女の HD ウォレットからキーペアを選択します。注意：このキーペアは、アリスの通知アドレスやアリスの身元と簡単に関連付けられるべきではありません（前の部分を参照）。
- アリスはこのキーペアの秘密鍵を選択します。私たちはこれを「a」と呼びます（小文字）。

> a

- アリスはボブの通知アドレスに関連付けられた公開鍵を取得します。この公開鍵は、ボブの支払いコード（インデックス 0）から派生した最初の子です。この公開鍵を「B」と呼びます（大文字）。この公開鍵に関連付けられた秘密鍵は「b」と呼ばれます（小文字）。"B"は、"G"（生成点）と"b"（秘密鍵）を用いて楕円曲線上で点の加算と倍加によって決定されます。

> B = b·G

- アリスはボブの公開鍵「B」に対して、自身の秘密鍵「a」を適用して楕円曲線上で秘密点「S」（大文字）を計算します。

> S = a·B

- アリスは支払いコードを暗号化するためのブラインドファクター「f」を計算します。これには、HMAC-SHA512 関数を使用して擬似乱数を生成します。この関数の第 2 入力として、アリスは以前に計算した秘密点の x 座標である「x」を使用します。最初の入力は、このトランザクションの入力として消費される UTXO（アウトポイント）である「o」です。

> f = HMAC-SHA512(o, x)

2. アリスは自身の支払いコードを 2 進数（バイナリ）に変換します。

3. アリスはこのブラインドファクターを使用して、支払いコードのペイロードを対称暗号化します。使用される暗号化アルゴリズムは XOR です。この操作は、Vernam 暗号または「ワンタイムパッド」とも呼ばれる操作と類似しています。

- アリスはまずブラインドファクターを 2 つに分割します：最初の 32 バイトを「f1」とし、最後の 32 バイトを「f2」とします。したがって、次のようになります：

> f = f1 || f2

- アリスは支払いコードの公開鍵の x 座標（x）の暗号化された値（x'）とチェーンコード（c）の暗号化された値（c'）を個別に計算します。"f1"と"f2"はそれぞれ暗号化の鍵として機能します。使用される操作は XOR（排他的論理和）です。

> x' = x XOR f1
>
> c' = c XOR f2

- アリスは、公開鍵の x 座標とチェーンコードの値(c)を、暗号化された値(x')と(c')に置き換えて支払いコードのコードに入れます。

このトランザクションの技術的な説明を続ける前に、XOR 演算について少し詳しく説明しましょう。XOR は、ブール代数に基づいたビットレベルの論理演算子です。2 つのビットオペランドから、同じ位置のビットが異なる場合は 1 を返し、同じ位置のビットが等しい場合は 0 を返します。以下は、オペランド D と E の値に応じた XOR の真理値表です：

| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

例えば：

> 0110 XOR 1110 = 1000

または：

> 010011 XOR 110110 = 100101

ECDH では、XOR を暗号化の層として使用することは特に一貫しています。まず、この演算子により、暗号化は対称的になります。これにより、受信者は暗号化に使用された同じ鍵で支払いコードを復号化することができます。暗号化および復号化の鍵は、ECDH によって共有された秘密から計算されます。

この対称性は、XOR 演算子の可換性と結合性の特性によって可能になります：

- その他の特性：
  -> D ⊕ D = 0
  -> D ⊕ 0 = D

- 可換性：
  D ⊕ E = E ⊕ D

- 結合性：
  D ⊕ (E ⊕ Z) = (D ⊕ E) ⊕ Z = D ⊕ E ⊕ Z

- 対称性：
  もし：D ⊕ E = L
  ならば：D ⊕ L = D ⊕ (D ⊕ E) = D ⊕ D ⊕ E = 0 ⊕ E = E
  -> D ⊕ L = E
  次に、この暗号化方法は、Vernam 暗号（ワンタイムパッド）に非常に似ています。これは、現在までに唯一の絶対的なセキュリティを持つ既知の暗号化アルゴリズムです。Vernam 暗号がこの特性を持つためには、暗号化キーが完全にランダムであり、メッセージと同じサイズであり、一度だけ使用される必要があります。BIP47 で使用される暗号化方法では、キーはメッセージと同じサイズであり、ブラインドファクターは公開鍵の x 座標と支払いコードの連結と同じサイズです。この暗号化キーは一度だけ使用されます。ただし、このキーは HMAC であるため、完全なランダムではありません。むしろ、擬似乱数です。したがって、これは Vernam 暗号ではありませんが、この方法はそれに近いものです。

次に、通知トランザクションの構築に戻りましょう：

4. アリスは現在、暗号化されたペイロードを持つ支払いコードを持っています。彼女は、彼女の公開鍵 "A" を入力として、ボブの通知アドレスに向けた出力、および彼女の暗号化されたペイロードを含む OP_RETURN 出力を含むトランザクションを構築してブロードキャストします。このトランザクションは通知トランザクションです。

OP_RETURN は、ビットコイントランザクションの出力を無効にするためのスクリプトであるオペコードです。現在では、ビットコインのブロックチェーン上に情報をブロードキャストまたはアンカーするために使用されています。80 バイトまでのデータを格納することができ、他のすべてのユーザーによって見ることができます。

前のセクションで見たように、Diffie-Hellman は、セキュリティのないネットワーク上で通信する 2 つのユーザー間で共有される秘密を生成するために使用されます。BIP47 では、ECDH が使用されてビットコインネットワーク上で通信するために使用されます。これは、透明で多くの攻撃者によって監視される通信ネットワークです。楕円曲線上での Diffie-Hellman 鍵交換によって計算された共有秘密は、送信者（アリス）の支払いコードを暗号化するために使用されます。

以下は、先ほど説明した内容を示す BIP47 からの図です：

![AliceがBobの通知アドレスにマスクされた支払いコードを送信するスキーマ](assets/16.png)

クレジット：Reusable Payment Codes for Hierarchical Deterministic Wallets、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

この図を先ほど説明した内容に対応させると：

- Alice 側の「Wallet Priv-Key」は、a に対応します。

- Bob 側の「Child Pub-Key 0」は、B に対応します。
- "Notification Shared Secret" corresponds to: f.
- "Masked Payment Code" corresponds to the encrypted payment code, i.e., with the encrypted payload: x' and c'.

- "Notification Transaction" is the transaction that contains the OP_RETURN.

Let's recap the steps we just went through to perform a notification transaction:

- Alice retrieves Bob's payment code and notification address.

- Alice selects a UTXO that belongs to her in her HD wallet with the corresponding key pair.

- She calculates a secret point on the elliptic curve using ECDH.

- She uses this secret point to calculate an HMAC, which is the blinding factor.

- She uses this blinding factor to encrypt the payload of her personal payment code.

- She uses an OP_RETURN transaction output to transfer the masked payment code to Bob.

To better understand its operation, especially the use of OP_RETURN, let's study a real notification transaction together. I made a transaction of this type on the Testnet, which you can find by clicking here:

https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e

TXID:

> 0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e

![BIP47 Notification Transaction](assets/17.png)

Credit: https://blockstream.info/

By observing this transaction, we can already see that it has a single input and 4 outputs:

- The first output is the OP_RETURN that contains my masked payment code.

- The second output of 546 sats points to the recipient's notification address.

- The third output of 15,000 sats represents the service fee, as I used Samourai Wallet to construct this transaction.

- The fourth output of two million sats represents the change, i.e., the remaining difference from my input that goes back to another address belonging to me.

The most interesting to study is obviously output 0 using OP_RETURN. Let's take a closer look at what it contains:

![OP_RETURN Output of Notification Transaction BIP47](assets/18.png)

Credit: https://blockstream.info/

We discover the hexadecimal script of the output:

> 6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000

In this script, we can break down several parts:

> オプコード：
>
> 6a4c
>
> ペイロードのサイズを示す 1 バイト（80 バイト）：
>
> 50
>
> 私の支払いコードのメタデータ：
>
> 010002
>
> 私の支払いコードの公開鍵の暗号化された x 座標：
>
> b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
>
> 私の支払いコードの暗号化されたチェーンコード：
> 927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
>
> 80 バイトに到達するためのパディング：
> 00000000000000000000000000

オプコードの中で、OP_RETURN を示す 0x6a と OP_PUSHDATA1 を示す 0x4c が認識できます。最後のオプコードの次のバイトは、その後に続くペイロードのサイズを示します。0x50、つまり 80 バイトを示しています。

次に、暗号化されたペイロードを持つ支払いコードが続きます。

このトランザクションで使用された私の支払いコードは次のとおりです：

> Base58 形式：
>
> PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
>
> Base16 形式（HEX）：
> 4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db

私の支払いコードを OP_RETURN と比較すると、HRP（茶色で表示される部分）とチェックサム（ピンクで表示される部分）が送信されていないことがわかります。これは正常であり、これらの情報は人間向けのものです。
次に、（緑で）バージョン（0x01）、ビットフィールド（0x00）、および公開鍵のパリティ（0x02）を認識できます。そして、支払いコードの末尾には、合計 80 バイトになるようにパディングするための空のバイト（黒で 0x00）があります。これらのメタデータは、平文（暗号化されていない）で送信されます。
最後に、公開鍵の x 座標（青で）とチェーンコード（赤で）が暗号化されていることがわかります。これが支払いコードのペイロードを構成するものです。

### トランザクションの通知の受信。

アリスがボブに通知トランザクションを送信したので、ボブがそれをどのように解釈するか見てみましょう。

ボブはアリスの支払いコードにアクセスできる必要があります。この情報がない場合、次のセクションで見るように、アリスが作成した鍵のペアを派生させることができず、したがって BIP47 で受け取ったビットコインにアクセスすることができません。現時点では、アリスの支払いコードのペイロードは暗号化されています。ボブがそれを解読する方法を一緒に見てみましょう。

1. ボブは、通知アドレスに出力を作成するトランザクションを監視します。

2. トランザクションに BIP47 の標準を満たす OP_RETURN 出力が含まれているかどうかを確認するため、ボブはトランザクションを分析します。

3. OP_RETURN のペイロードの最初のバイトが 0x01 である場合、ボブは ECDH で共有される可能性のある秘密を検索を開始します：

- ボブは、トランザクションの入力である公開鍵を選択します。つまり、アリスの公開鍵である「A」という名前の公開鍵を選択します：

> A = a·G

- ボブは、個人の通知アドレスに関連付けられた秘密鍵「b」を選択します：

> b

- ボブは、楕円曲線上で点の加算と倍加を適用して、アリスの公開鍵「A」に対して秘密鍵「b」を適用することで、共有秘密「S」（ECDH で共有される秘密）を計算します：

> S = b·A

- ボブは、アリスの支払いコードのペイロードを復号化するための盲目化ファクター「f」を決定します。アリスが以前に計算したのと同じ方法で、ボブは（x）共有秘密「S」の x 座標の値と、この通知トランザクションの入力で消費される UTXO（o）に HMAC-SHA512 を適用して「f」を見つけます：

> f = HMAC-SHA512(o, x)

4. ボブは、通知トランザクションの OP_RETURN のデータを支払いコードとして解釈します。ボブは、潜在的な支払いコードのペイロードを単純に盲目化ファクター「f」を使用して復号化します。

- ボブは、盲目的な因子「f」を 2 つの部分に分けます：「f」の最初の 32 バイトは「f1」であり、最後の 32 バイトは「f2」です。
- ボブは、アリスの支払いコードの公開鍵の暗号化された x 座標（x'）の値を復号化します：

> x = x' XOR f1

- ボブは、アリスの支払いコードの暗号化されたチェーンコード（c'）の値を復号化します：

> c = c' XOR f2

5. ボブは、アリスの支払いコードの公開鍵の値が secp256k1 グループに所属しているかどうかを確認します。それが正しい場合、それを有効な支払いコードと解釈します。そうでない場合、このトランザクションを無視します。

ボブがアリスの支払いコードを知っているので、アリスはこれ以降、2^32 回までの支払いをボブに送ることができます。もう一度このような通知トランザクションを行う必要はありません。

なぜこれが機能するのでしょうか？ボブはどのようにしてアリスと同じ盲目的な因子を特定し、彼女の支払いコードを復号化することができるのでしょうか？これについて、ECDH の動作を詳しく見てみましょう。

まず、対称暗号化を扱っています。これは、暗号化キーと復号化キーが同じ値であることを意味します。トランザクションの通知におけるこのキーは、盲目的な因子（f = f1 || f2）です。したがって、アリスとボブは、秘密情報を盗み出して復号化することができる攻撃者が直接にそれを取得することができないように、f の値を直接送信することなく、同じ値を取得する必要があります。

この盲目的な因子は、秘密の点の x 座標とトランザクションの入力で消費される UTXO に HMAC-SHA512 を適用することで得られます。したがって、ボブはアリスの支払いコードのペイロードを復号化するために、これらの 2 つの情報を持っている必要があります。

入力の UTXO については、ボブは通知トランザクションを観察することで簡単に取得できます。秘密の点については、ボブは ECDH を使用する必要があります。

Diffie-Hellman のセクションで見たように、お互いの公開鍵を交換し、お互いの秘密鍵を相手の公開鍵に秘密裏に適用することで、アリスとボブは楕円曲線上の特定の秘密の点を見つけることができます。通知トランザクションは、このメカニズムに基づいています：

> ボブの鍵ペア：
>
> B = b·G
>
> アリスの鍵ペア：
>
> A = a·G
>
> 秘密の点 S（x、y）について：
>
> S = a·B = a·b·G = b·a·G = b·A

![ECDHEで共有秘密を生成するスキーマ](assets/19.png)
アリスの支払いコードを知っているボブは、彼女の BIP47 支払いを検出し、受け取ったビットコインのプライベートキーを派生させることができます。
![ボブはアリスの通知トランザクションを解釈します](assets/20.png)

クレジット：階層的決定ウォレットの再利用可能な支払いコード、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

これを以前に説明した内容と照らし合わせると：

- アリス側の「ウォレット公開鍵」は：A に対応します。

- ボブ側の「子プライベート鍵 0」は：b に対応します。

- 「通知共有秘密」は：f に対応します。

- 「マスクされた支払いコード」は、アリスの支払いコードのペイロードが暗号化されたものであり、x'と c'です。

- 「通知トランザクション」は、OP_RETURN を含むトランザクションです。

受け取りと通知トランザクションの解釈の手順をまとめます：

- ボブは通知アドレスへのトランザクションの出力を監視します。

- 検出すると、OP_RETURN に含まれる情報を取得します。

- ボブは入力の公開鍵を選択し、ECDH を使用して秘密ポイントを計算します。

- この秘密ポイントを使用して、ブラインドファクターである HMAC を計算します。

- このブラインドファクターを使用して、OP_RETURN に含まれるアリスの支払いコードのペイロードを復号化します。

### BIP47 支払いトランザクション

BIP47 を使用した支払いプロセスを一緒に見てみましょう。現在の状況を思い出すために：

- アリスはボブの支払いコードを知っており、彼のウェブサイトから簡単に取得しました。

- ボブは通知トランザクションによってアリスの支払いコードを知っています。

- アリスはボブに最初の支払いを行います。同じ方法で多くの支払いを行うこともできます。

このプロセスを説明する前に、現在作業しているインデックスを思い出すことが重要だと思います：

支払いコードの派生パスは次のように記述されます：m/47'/0'/0'/。

次の深さは、インデックスを次のように分配します：

- 最初の通常の子ペア（強化されていない）は、前の部分で説明した通知アドレスを生成するために使用されます：m/47'/0'/0'/0/。

- 通常の子キーペアは、この部分で説明するように、BIP47 支払いの受け取りアドレスを生成するために ECDH 内で使用されます：m/47'/0'/0'/0 から 2,147,483,647 まで/。

- 強化された子キーペアは、一時的な支払いコードです：m/47'/0'/0'/0'から 2,147,483,647'まで/。
  アリスがボブに支払いを送りたい場合、彼女は再び ECDH プロトコルを使用して新しい空の一意のアドレスを派生します：

* アリスは、再利用可能な個人の支払いコードから派生した最初の秘密鍵を選択します：

> a

- アリスは、ボブの支払いコードから派生した未使用の最初の公開鍵を選択します。この公開鍵を「B」と呼びます。これは、ボブだけが知っている秘密鍵「b」と関連付けられています。

> B = b·G

- アリスは、ボブの公開鍵「B」に彼女の秘密鍵「a」を適用して、楕円曲線上の秘密点「S」を加算および倍加することで計算します：

> S = a·B

- この秘密点から、アリスは共有秘密「s」（小文字）を計算します。これを行うために、彼女は「S」と呼ばれる秘密点の x 座標「Sx」を選択し、この値を SHA256 ハッシュ関数に渡します。

> s = SHA256(Sx)

信じるな、検証せよ！ハッシュ関数の基本原則を理解したい場合は、この記事で満足できるでしょう。そして、もし NIST を信用しない（正しい判断です）し、SHA256 の動作を詳細に理解したい場合は、この記事で全てを説明します。

- アリスはこの共有秘密「s」を使用して、ビットコインの受信アドレスを計算します。まず、彼女は「s」が secp256k1 曲線の順序に含まれていることを確認します。そうでない場合、彼女はボブの公開鍵のインデックスを増やして別の共有秘密を派生させます。

- 次に、彼女は楕円曲線上で「B」と「s·G」の点を加算して公開鍵「K0」を計算します。言い換えると、アリスはボブの支払いコードから派生した公開鍵「B」と、secp256k1 曲線の生成点「G」からの共有秘密「s」を加算および倍加して計算された別の点を楕円曲線上で加算します。この新しい点は公開鍵を表し、私たちはそれを「K0」と呼びます。

> K0 = B + s·G

- この公開鍵「K0」を使用して、アリスは標準的な方法で空の受信アドレス（例：Bech32 の SegWit V0）を派生させることができます。

アリスがボブに属するこの受信アドレス「K0」を取得したら、彼女は通常のビットコイントランザクションを構築することができます。彼女は自身の HD ウォレットの別の枝に所属する彼女自身の UTXO を選択し、「K0」のアドレスに対して支出します。

![Alice envoie des bitcoins avec BIP47 à Bob](assets/21.png)

クレジット：Reusable Payment Codes for Hierarchical Deterministic Wallets、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
前述の内容とこの図を対応させると、次のようになります：

- Alice 側の「Child Priv-Key」は、a に対応します。
- Bob 側の「Child Pub-Key 0」は、B に対応します。
- 「Payment Secret 0」は、s に対応します。
- 「Payment Pub-Key 0」は、K0 に対応します。

BIP47 の支払いを送信するために一緒に見た手順をまとめます：

- Alice は、個人の支払いコードから派生した最初の子プライベートキーを選択します。
- 彼女は、Bob の支払いコードから派生した未使用の最初の子パブリックキーを使用して、楕円曲線上で ECDH によって秘密ポイントを計算します。
- この秘密ポイントを使用して、SHA256 で共有シークレットを計算します。
- この共有シークレットを使用して、楕円曲線上で新しい秘密ポイントを計算します。
- この新しい秘密ポイントを Bob の公開鍵に加算します。
- 彼女は、Bob だけが関連するプライベートキーを持つ新しい一時的な公開鍵を取得します。
- Alice は、派生した一時的な受信アドレスを使用して Bob に対して通常のトランザクションを送信することができます。

もし彼女が 2 回目の支払いを行いたい場合、彼女は前述の手順を再現しますが、Bob の支払いコードから派生した 2 番目のパブリックキーを選択します。つまり、次の未使用のキーを選択します。その結果、Bob に属する 2 番目の受信アドレス「K1」を持つことになります。

![AliceがBobに対して3つのBIP47受信アドレスを派生させる](assets/22.png)

クレジット：Reusable Payment Codes for Hierarchical Deterministic Wallets、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

彼女はこのように続けることができ、Bob に属する空のアドレスを 2^32 個まで派生させることができます。

外部から見た場合、Bitcoin のブロックチェーンを観察すると、BIP47 の支払いと通常の支払いを理論的に区別することは不可能です。以下は、Testnet 上の BIP47 支払いトランザクションの例です：

https://blockstream.info/testnet/tx/94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

TXID：

> 94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

これは、消費されたインプット、210,000 sats の支払いアウトプット、およびおつりを持つ通常のトランザクションのように見えます。

![BIP47を使用したBitcoinの支払いトランザクション](assets/23.png)

クレジット：https://blockstream.info/

### BIP47 の支払いの受け取りとプライベートキーの派生

アリスは、ボブに属する BIP47 の空のアドレスに最初の支払いを行いました。今度は、ボブがこの支払いを受け取る方法を見ていきましょう。また、アリスが生成したアドレスの秘密鍵にアクセスできない理由と、ボブが受け取ったビットコインを使うためにこの鍵をどのように見つけるかも見ていきます。

ボブは、アリスからの通知トランザクションを受け取ると、対応する支払いが行われる前に BIP47 の公開鍵「K0」を派生させます。したがって、関連するアドレスへのすべての支払いを監視します。実際には、彼はすぐに複数のアドレスを派生させて監視します（K0、K1、K2、K3...）。以下は、彼がこの公開鍵「K0」を派生させる方法です：

- ボブは、支払いコードから派生した最初の子秘密鍵を選択します。この秘密鍵は「b」と呼ばれます。アリスが前のステップで計算に使用した公開鍵「B」と関連付けられています：

> b

- ボブは、通知トランザクションとともにアリスから受け取ったアリスの最初の公開鍵を選択します。この公開鍵は「A」と呼ばれます。アリスが計算に使用した秘密鍵「a」と関連付けられていますが、これはアリスだけが知っています。ボブは、通知トランザクションとともに送られてきたアリスの支払いコードを知っているため、このプロセスを実行できます。

> A = a·G

- ボブは、アリスの公開鍵「A」に対して自身の秘密鍵「b」を適用し、楕円曲線上で点の加算と倍加算を行うことで、秘密点「S」を計算します。ここで、ボブとアリスの間で同じ点「S」になることを保証する ECDH の使用があります。

> S = b·A

- アリスと同様に、ボブはこの点「S」の x 座標を取り出します。この値を「Sx」と呼びます。ボブはこの値を SHA256 関数に渡して共有秘密「s」を見つけます（小文字）。

> s = SHA256(Sx)

- アリスと同様に、ボブは楕円曲線上の点「s·G」を計算します。そして、この秘密点を自身の公開鍵「B」と加算します。すると、新しい楕円曲線上の点が得られ、これを公開鍵「K0」と解釈します。

> K0 = B + s·G

ボブがこの公開鍵「K0」を持っていると、関連する秘密鍵を派生させてビットコインを使うことができます。これは彼だけが生成できるものです。

- ボブは、自身の個人支払いコードから派生した子秘密鍵「b」を加算します。これは「b」の値を取得できる唯一の人物です。そして、共有秘密「s」との加算を行い、K0 の秘密鍵である k0 を得ます。

> k0 = b + s
> 楕円曲線の群の法則により、ボブはアリスが使用した公開鍵に対応する秘密鍵を正確に取得します。したがって、次のようになります：
> K0 = k0·G

![Bob génère ses adresses de réception BIP47](assets/24.png)

クレジット：Reusable Payment Codes for Hierarchical Deterministic Wallets、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

これを以前に説明した内容と対応させると、次のようになります：

- ボブの「Child Priv-Key 0」は、b に対応します。

- アリスの「Child Pub-Key 0」は、A に対応します。

- 「Payment Secret 0」は、s に対応します。

- 「Payment Pub-Key 0」は、K0 に対応します。

- 「Payment Priv-Key 0」は、k0 に対応します。

BIP47 の支払いを受け取り、対応する秘密鍵を計算するために一緒に見た手順をまとめます：

- ボブは、個人の支払いコードから派生した最初の子秘密鍵を選択します。

- アリスのチェーンコードから派生した最初の子公開鍵に基づいて、楕円曲線上で ECDH を使用して秘密ポイントを計算します。

- この秘密ポイントを使用して、SHA256 で共有シークレットを計算します。

- この共有シークレットを使用して、楕円曲線上で新しい秘密ポイントを計算します。

- この新しい秘密ポイントを自身の公開鍵に加算します。

- 新しい一時的な公開鍵が得られます。これはアリスが最初の支払いを送信する宛先です。

- ボブは、支払いコードから派生した子秘密鍵と共有シークレットを加算して、この一時的な公開鍵に関連する秘密鍵を計算します。

アリスはボブの受信アドレスの BIP47 に関連する秘密鍵である k0 を決定できないため、ボブの秘密鍵である b を取得することはできません。

図式的には、共有シークレット「S」の計算は次のように表されます：

![Calcule du secret partagé avec ECDHE](assets/25.png)

ECDH で共有シークレットが見つかった後、アリスとボブは BIP47 の支払い公開鍵「K0」を計算し、ボブは関連する秘密鍵「k0」も計算します：

![Dérivation de l'adresse de réception BIP47 depuis le secret partagé](assets/26.png)

### BIP47 の支払いの返金。

ボブはアリスの再利用可能な支払いコードを知っているため、彼は彼女に返金を送るために必要なすべての情報を既に持っています。彼は彼女に何か情報を求めるために再度連絡する必要はありません。彼は単に通知トランザクションを使用して彼女に通知し、彼女が彼女の BIP47 アドレスを彼女のシードで回復できるようにし、さらに 2^32 回の支払いを送ることもできます。
その後、Bob は Alice に支払いを送ったのと同じ方法で彼女に返金することができます。役割が逆転します：

![BobがBIP47でAliceに返金を送る](assets/27.png)

クレジット：Reusable Payment Codes for Hierarchical Deterministic Wallets、Justus Ranvier。https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

これで、BIP47 がどれほど素晴らしいソリューションであるかのすべての仕組みを知ることができました。

## PayNym の派生的な使用法。

Samourai Wallet でのこの BIP47 の実装により、PayNym が生まれました。これはユーザーの支払いコードから計算される識別子です。今日、その有用性は BIP47 の使用以上に広がっています。

Samourai のチームは、PayNym をベースにしたツールやサービスのエコシステムを徐々に開発しています。その中には、トランザクションにエントロピーを追加し、プライバシーを最適化するための支出ツールが当然含まれます。

Soroban（Tor 上の暗号化通信ネットワーク）と PayNym の共同利用により、このタイプの共同トランザクションの構築時にユーザーのエクスペリエンスを最適化することが大幅に可能になりました。これにより、Stowaway（PayJoin）や StonewallX2 のトランザクションを簡単に行うことができます。これらのトランザクションは、このタイプの共同トランザクションの設定に必要な多数の未署名トランザクションの手動交換を行う必要がありません。

BIP47 の使用とは異なり、これらの共同トランザクションでは通知トランザクションを行う必要がないため、これらのツールを使用するには PayNym を関連付けるだけで十分です。接続する必要はありません。

共同トランザクションについて詳しく知りたい場合や、Samourai Wallet の支出ツール全般について知りたい場合は、この記事の「Les outils de dépense」セクションを読んでください。各ツールについての技術的な説明と詳細なチュートリアルが記載されています。

これらの共同トランザクションに加えて、最近では Samourai のチームが PayNym に関連する認証プロトコルである Auth47 に取り組んでいることが観察されました。このツールは既に実装されており、例えば、この方法を受け入れるウェブサイトで PayNym を使用して認証することができます。将来的には、Auth47 は BIP47/PayNym/Samourai のエコシステムを取り巻くより大きなプロジェクトの一環として位置付けられると思います。おそらく、このプロトコルは、特に支出ツールの使用において、Samourai Wallet のユーザーエクスペリエンスをさらに最適化するために使用されるでしょう。これには注目です...

## BIP47 に対する私の個人的な意見。

BIP47 の主な欠点は、通知トランザクションです。これにより、ユーザーはそのトランザクションのマイニングに手数料を支払わなければならず、これは一部の人にとって面倒なことです。一方で、Bitcoin のブロックチェーンの「スパム」の主張は完全に受け入れられません。トランザクションの手数料を支払う人は、その目的に関係なく、そのトランザクションをレジストリに記録する能力を持っている必要があります。その逆を主張することは、検閲を支持することと同じです。

将来的には、送信者の支払いコードを受信者に伝え、受信者が安全に保存できるような、より低コストな他の解決策が見つかる可能性があります。しかし、現時点では、通知トランザクションが最も妥協の少ない解決策です。

BIP47 の利点を考慮すると、この欠点は無視できるものです。アドレスの再利用問題を解決するためのすべての提案の中で、私にとって最も優れた解決策と思われます。

前述のように、アドレスの再利用の大部分は取引所から発生しています。 BIP47 は、この問題を根本的に解決する唯一の合理的な解決策です。アドレスの再利用を減らすための提案は、この側面に焦点を当て、問題の主要な原因に対して解決策を適応する必要があります。

使用方法に関しては、BIP47 の支払い手続きは非常に複雑ですが、非常に簡単です。再利用可能な支払いコードは、初心者のユーザーでも簡単に採用できます。

プライバシーの観点から見ると、BIP47 は非常に興味深いです。通知トランザクションの部分で説明したように、支払いコードは派生した一時的なアドレスに関する情報を一切明らかにしません。従来の受信アドレスの使用とは異なり、Bitcoin のトランザクションと受信者の識別子との情報フローを断ち切ることができます。

そして何よりも、BIP47 の PayNym 実装は機能しています！これは 2016 年から Samourai Wallet で利用可能であり、今年の初めから Sparrow Wallet でも利用できます。これは科学的なプロジェクトではなく、昨日実証され、今日完全に機能している解決策です。

将来的には、これらの再利用可能な支払いコードがエコシステムの関係者によって採用され、ウォレットソフトウェアに実装され、ビットコインユーザーによって使用されることを願っています。

ユーザーのプライバシーに本当にプラスになる解決策は、ビットコインが CA の遊び場や政府の監視ツールにならないように、議論され、推進されるべきです。

> 彼はどこでも迫害され侮辱されていた方法を考えていましたが、今や彼はみんなが彼が最も美しい鳥であると言っているのを聞いています！そして、エルダーベリーの木さえも彼に枝を傾け、太陽はとても暖かくて恵まれた光を放っています！すると彼の羽がふくらみ、背が高くなり、彼は心の底から叫びました。「私がただの醜いアヒルの子だった間に、こんなに幸せを夢見ることができたのだろうか。」

## より深く掘り下げるために：

- ビットコインの CoinJoin を理解して使用する。

- ビットコインウォレットの派生パスを理解する。

- 自分の RoninDojo ビットコインノードをインストールして使用する。

### 外部リソースと謝辞：

    LaurentMTさんとThéo Pantamisさんには、この記事で説明してもらった多くの概念に感謝します。それらを正確に伝えることができたことを願っています。

    このテキストの校正と専門的なアドバイスについて、Fanis Michalakisさんに感謝します。

    https://bitcoiner.guide/paynym/

    https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

    https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman

    https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman_bas%C3%A9_sur_les_courbes_elliptiques

    https://security.stackexchange.com/questions/46802/what-is-the-difference-between-dhe-and-ecdh#:~:text=The%20difference%20between%20DHE%20and%20ECDH%20in%20two%20bullet%20points,a%20type%20of%20algebraic%20curve).

    https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art060

    https://ee.stanford.edu/~hellman/publications/24.pdf

    https://www.researchgate.net/publication/317339928_A_study_on_diffie-hellman_key_exchange_protocols
